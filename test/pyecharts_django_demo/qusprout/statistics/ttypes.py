#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:package_prefix=qusprout.
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import qusprout.code.ttypes
import qusprout.qusproutdata.ttypes

from thrift.transport import TTransport
all_structs = []


class GpuType(object):
    GpuType_Default = 0
    GpuType_Nvidia = 1

    _VALUES_TO_NAMES = {
        0: "GpuType_Default",
        1: "GpuType_Nvidia",
    }

    _NAMES_TO_VALUES = {
        "GpuType_Default": 0,
        "GpuType_Nvidia": 1,
    }


class BaseTag(object):
    """
    Attributes:
     - hostname
     - type

    """


    def __init__(self, hostname=None, type=None,):
        self.hostname = hostname
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hostname = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BaseTag')
        if self.hostname is not None:
            oprot.writeFieldBegin('hostname', TType.STRING, 1)
            oprot.writeString(self.hostname.encode('utf-8') if sys.version_info[0] == 2 else self.hostname)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hostname is None:
            raise TProtocolException(message='Required field hostname is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QubitTag(object):
    """
    Attributes:
     - base
     - qubits

    """


    def __init__(self, base=None, qubits=None,):
        self.base = base
        self.qubits = qubits

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = BaseTag()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.qubits = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QubitTag')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        if self.qubits is not None:
            oprot.writeFieldBegin('qubits', TType.I32, 2)
            oprot.writeI32(self.qubits)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        if self.qubits is None:
            raise TProtocolException(message='Required field qubits is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InterfaceTag(object):
    """
    Attributes:
     - base
     - interface_name
     - qubits

    """


    def __init__(self, base=None, interface_name=None, qubits=None,):
        self.base = base
        self.interface_name = interface_name
        self.qubits = qubits

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.base = BaseTag()
                    self.base.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.interface_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.qubits = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InterfaceTag')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.STRUCT, 1)
            self.base.write(oprot)
            oprot.writeFieldEnd()
        if self.interface_name is not None:
            oprot.writeFieldBegin('interface_name', TType.STRING, 2)
            oprot.writeString(self.interface_name.encode('utf-8') if sys.version_info[0] == 2 else self.interface_name)
            oprot.writeFieldEnd()
        if self.qubits is not None:
            oprot.writeFieldBegin('qubits', TType.I32, 3)
            oprot.writeI32(self.qubits)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.base is None:
            raise TProtocolException(message='Required field base is unset!')
        if self.interface_name is None:
            raise TProtocolException(message='Required field interface_name is unset!')
        if self.qubits is None:
            raise TProtocolException(message='Required field qubits is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SisAllTaskNum(object):
    """
    Attributes:
     - tag
     - num

    """


    def __init__(self, tag=None, num=None,):
        self.tag = tag
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tag = QubitTag()
                    self.tag.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SisAllTaskNum')
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRUCT, 1)
            self.tag.write(oprot)
            oprot.writeFieldEnd()
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 2)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tag is None:
            raise TProtocolException(message='Required field tag is unset!')
        if self.num is None:
            raise TProtocolException(message='Required field num is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SisCurrTaskNum(object):
    """
    Attributes:
     - tag
     - num
     - timeout_num

    """


    def __init__(self, tag=None, num=None, timeout_num=None,):
        self.tag = tag
        self.num = num
        self.timeout_num = timeout_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tag = QubitTag()
                    self.tag.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.timeout_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SisCurrTaskNum')
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRUCT, 1)
            self.tag.write(oprot)
            oprot.writeFieldEnd()
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 2)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        if self.timeout_num is not None:
            oprot.writeFieldBegin('timeout_num', TType.I32, 3)
            oprot.writeI32(self.timeout_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tag is None:
            raise TProtocolException(message='Required field tag is unset!')
        if self.num is None:
            raise TProtocolException(message='Required field num is unset!')
        if self.timeout_num is None:
            raise TProtocolException(message='Required field timeout_num is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SisInterfaceCount(object):
    """
    Attributes:
     - tag
     - count

    """


    def __init__(self, tag=None, count=None,):
        self.tag = tag
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tag = InterfaceTag()
                    self.tag.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SisInterfaceCount')
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRUCT, 1)
            self.tag.write(oprot)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tag is None:
            raise TProtocolException(message='Required field tag is unset!')
        if self.count is None:
            raise TProtocolException(message='Required field count is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SisInterfaceTime(object):
    """
    Attributes:
     - tag
     - elapsed
     - count

    """


    def __init__(self, tag=None, elapsed=None, count=None,):
        self.tag = tag
        self.elapsed = elapsed
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tag = InterfaceTag()
                    self.tag.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.elapsed = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SisInterfaceTime')
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRUCT, 1)
            self.tag.write(oprot)
            oprot.writeFieldEnd()
        if self.elapsed is not None:
            oprot.writeFieldBegin('elapsed', TType.I32, 2)
            oprot.writeI32(self.elapsed)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 3)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tag is None:
            raise TProtocolException(message='Required field tag is unset!')
        if self.elapsed is None:
            raise TProtocolException(message='Required field elapsed is unset!')
        if self.count is None:
            raise TProtocolException(message='Required field count is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SisCodeCount(object):
    """
    Attributes:
     - tag
     - code
     - count

    """


    def __init__(self, tag=None, code=None, count=None,):
        self.tag = tag
        self.code = code
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tag = InterfaceTag()
                    self.tag.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SisCodeCount')
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRUCT, 1)
            self.tag.write(oprot)
            oprot.writeFieldEnd()
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 2)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 3)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tag is None:
            raise TProtocolException(message='Required field tag is unset!')
        if self.code is None:
            raise TProtocolException(message='Required field code is unset!')
        if self.count is None:
            raise TProtocolException(message='Required field count is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MachineFixedInfo(object):
    """
    Attributes:
     - cpu_num
     - cpu_memory
     - gpu_type
     - gpu_memory

    """


    def __init__(self, cpu_num=None, cpu_memory=None, gpu_type=None, gpu_memory=None,):
        self.cpu_num = cpu_num
        self.cpu_memory = cpu_memory
        self.gpu_type = gpu_type
        self.gpu_memory = gpu_memory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.cpu_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.cpu_memory = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.gpu_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.gpu_memory = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MachineFixedInfo')
        if self.cpu_num is not None:
            oprot.writeFieldBegin('cpu_num', TType.I32, 1)
            oprot.writeI32(self.cpu_num)
            oprot.writeFieldEnd()
        if self.cpu_memory is not None:
            oprot.writeFieldBegin('cpu_memory', TType.I64, 2)
            oprot.writeI64(self.cpu_memory)
            oprot.writeFieldEnd()
        if self.gpu_type is not None:
            oprot.writeFieldBegin('gpu_type', TType.I32, 3)
            oprot.writeI32(self.gpu_type)
            oprot.writeFieldEnd()
        if self.gpu_memory is not None:
            oprot.writeFieldBegin('gpu_memory', TType.I64, 4)
            oprot.writeI64(self.gpu_memory)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cpu_num is None:
            raise TProtocolException(message='Required field cpu_num is unset!')
        if self.cpu_memory is None:
            raise TProtocolException(message='Required field cpu_memory is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MachineDynamicInfo(object):
    """
    Attributes:
     - cpu_used_memory
     - gpu_used_memory

    """


    def __init__(self, cpu_used_memory=None, gpu_used_memory=None,):
        self.cpu_used_memory = cpu_used_memory
        self.gpu_used_memory = gpu_used_memory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cpu_used_memory = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.gpu_used_memory = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MachineDynamicInfo')
        if self.cpu_used_memory is not None:
            oprot.writeFieldBegin('cpu_used_memory', TType.I64, 1)
            oprot.writeI64(self.cpu_used_memory)
            oprot.writeFieldEnd()
        if self.gpu_used_memory is not None:
            oprot.writeFieldBegin('gpu_used_memory', TType.I64, 2)
            oprot.writeI64(self.gpu_used_memory)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cpu_used_memory is None:
            raise TProtocolException(message='Required field cpu_used_memory is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StatisticsInfo(object):
    """
    Attributes:
     - fixed_info
     - dyna_info
     - curr_task_num
     - all_task_num
     - inter_cout
     - inter_time
     - code_count
     - begin_time
     - end_time

    """


    def __init__(self, fixed_info=None, dyna_info=None, curr_task_num=None, all_task_num=None, inter_cout=None, inter_time=None, code_count=None, begin_time=None, end_time=None,):
        self.fixed_info = fixed_info
        self.dyna_info = dyna_info
        self.curr_task_num = curr_task_num
        self.all_task_num = all_task_num
        self.inter_cout = inter_cout
        self.inter_time = inter_time
        self.code_count = code_count
        self.begin_time = begin_time
        self.end_time = end_time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fixed_info = MachineFixedInfo()
                    self.fixed_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dyna_info = MachineDynamicInfo()
                    self.dyna_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.curr_task_num = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = SisCurrTaskNum()
                        _elem5.read(iprot)
                        self.curr_task_num.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.all_task_num = {}
                    (_ktype7, _vtype8, _size6) = iprot.readMapBegin()
                    for _i10 in range(_size6):
                        _key11 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val12 = SisAllTaskNum()
                        _val12.read(iprot)
                        self.all_task_num[_key11] = _val12
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.inter_cout = {}
                    (_ktype14, _vtype15, _size13) = iprot.readMapBegin()
                    for _i17 in range(_size13):
                        _key18 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val19 = SisInterfaceCount()
                        _val19.read(iprot)
                        self.inter_cout[_key18] = _val19
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.inter_time = {}
                    (_ktype21, _vtype22, _size20) = iprot.readMapBegin()
                    for _i24 in range(_size20):
                        _key25 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val26 = SisInterfaceTime()
                        _val26.read(iprot)
                        self.inter_time[_key25] = _val26
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.code_count = {}
                    (_ktype28, _vtype29, _size27) = iprot.readMapBegin()
                    for _i31 in range(_size27):
                        _key32 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val33 = SisCodeCount()
                        _val33.read(iprot)
                        self.code_count[_key32] = _val33
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.begin_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.end_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StatisticsInfo')
        if self.fixed_info is not None:
            oprot.writeFieldBegin('fixed_info', TType.STRUCT, 1)
            self.fixed_info.write(oprot)
            oprot.writeFieldEnd()
        if self.dyna_info is not None:
            oprot.writeFieldBegin('dyna_info', TType.STRUCT, 2)
            self.dyna_info.write(oprot)
            oprot.writeFieldEnd()
        if self.curr_task_num is not None:
            oprot.writeFieldBegin('curr_task_num', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.curr_task_num))
            for iter34 in self.curr_task_num:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_task_num is not None:
            oprot.writeFieldBegin('all_task_num', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.all_task_num))
            for kiter35, viter36 in self.all_task_num.items():
                oprot.writeString(kiter35.encode('utf-8') if sys.version_info[0] == 2 else kiter35)
                viter36.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.inter_cout is not None:
            oprot.writeFieldBegin('inter_cout', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.inter_cout))
            for kiter37, viter38 in self.inter_cout.items():
                oprot.writeString(kiter37.encode('utf-8') if sys.version_info[0] == 2 else kiter37)
                viter38.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.inter_time is not None:
            oprot.writeFieldBegin('inter_time', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.inter_time))
            for kiter39, viter40 in self.inter_time.items():
                oprot.writeString(kiter39.encode('utf-8') if sys.version_info[0] == 2 else kiter39)
                viter40.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.code_count is not None:
            oprot.writeFieldBegin('code_count', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.code_count))
            for kiter41, viter42 in self.code_count.items():
                oprot.writeString(kiter41.encode('utf-8') if sys.version_info[0] == 2 else kiter41)
                viter42.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.begin_time is not None:
            oprot.writeFieldBegin('begin_time', TType.I64, 8)
            oprot.writeI64(self.begin_time)
            oprot.writeFieldEnd()
        if self.end_time is not None:
            oprot.writeFieldBegin('end_time', TType.I64, 9)
            oprot.writeI64(self.end_time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fixed_info is None:
            raise TProtocolException(message='Required field fixed_info is unset!')
        if self.dyna_info is None:
            raise TProtocolException(message='Required field dyna_info is unset!')
        if self.curr_task_num is None:
            raise TProtocolException(message='Required field curr_task_num is unset!')
        if self.all_task_num is None:
            raise TProtocolException(message='Required field all_task_num is unset!')
        if self.inter_cout is None:
            raise TProtocolException(message='Required field inter_cout is unset!')
        if self.inter_time is None:
            raise TProtocolException(message='Required field inter_time is unset!')
        if self.code_count is None:
            raise TProtocolException(message='Required field code_count is unset!')
        if self.begin_time is None:
            raise TProtocolException(message='Required field begin_time is unset!')
        if self.end_time is None:
            raise TProtocolException(message='Required field end_time is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(BaseTag)
BaseTag.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hostname', 'UTF8', None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
)
all_structs.append(QubitTag)
QubitTag.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [BaseTag, None], None, ),  # 1
    (2, TType.I32, 'qubits', None, None, ),  # 2
)
all_structs.append(InterfaceTag)
InterfaceTag.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'base', [BaseTag, None], None, ),  # 1
    (2, TType.STRING, 'interface_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'qubits', None, None, ),  # 3
)
all_structs.append(SisAllTaskNum)
SisAllTaskNum.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tag', [QubitTag, None], None, ),  # 1
    (2, TType.I32, 'num', None, None, ),  # 2
)
all_structs.append(SisCurrTaskNum)
SisCurrTaskNum.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tag', [QubitTag, None], None, ),  # 1
    (2, TType.I32, 'num', None, None, ),  # 2
    (3, TType.I32, 'timeout_num', None, None, ),  # 3
)
all_structs.append(SisInterfaceCount)
SisInterfaceCount.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tag', [InterfaceTag, None], None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
)
all_structs.append(SisInterfaceTime)
SisInterfaceTime.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tag', [InterfaceTag, None], None, ),  # 1
    (2, TType.I32, 'elapsed', None, None, ),  # 2
    (3, TType.I32, 'count', None, None, ),  # 3
)
all_structs.append(SisCodeCount)
SisCodeCount.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tag', [InterfaceTag, None], None, ),  # 1
    (2, TType.I32, 'code', None, None, ),  # 2
    (3, TType.I32, 'count', None, None, ),  # 3
)
all_structs.append(MachineFixedInfo)
MachineFixedInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'cpu_num', None, None, ),  # 1
    (2, TType.I64, 'cpu_memory', None, None, ),  # 2
    (3, TType.I32, 'gpu_type', None, None, ),  # 3
    (4, TType.I64, 'gpu_memory', None, None, ),  # 4
)
all_structs.append(MachineDynamicInfo)
MachineDynamicInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cpu_used_memory', None, None, ),  # 1
    (2, TType.I64, 'gpu_used_memory', None, None, ),  # 2
)
all_structs.append(StatisticsInfo)
StatisticsInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fixed_info', [MachineFixedInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'dyna_info', [MachineDynamicInfo, None], None, ),  # 2
    (3, TType.LIST, 'curr_task_num', (TType.STRUCT, [SisCurrTaskNum, None], False), None, ),  # 3
    (4, TType.MAP, 'all_task_num', (TType.STRING, 'UTF8', TType.STRUCT, [SisAllTaskNum, None], False), None, ),  # 4
    (5, TType.MAP, 'inter_cout', (TType.STRING, 'UTF8', TType.STRUCT, [SisInterfaceCount, None], False), None, ),  # 5
    (6, TType.MAP, 'inter_time', (TType.STRING, 'UTF8', TType.STRUCT, [SisInterfaceTime, None], False), None, ),  # 6
    (7, TType.MAP, 'code_count', (TType.STRING, 'UTF8', TType.STRUCT, [SisCodeCount, None], False), None, ),  # 7
    (8, TType.I64, 'begin_time', None, None, ),  # 8
    (9, TType.I64, 'end_time', None, None, ),  # 9
)
fix_spec(all_structs)
del all_structs
