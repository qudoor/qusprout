/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "qusproutdata_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kExecCmdTypeValues[] = {
  ExecCmdType::ExecTypeDefault,
  ExecCmdType::ExecTypeCpuSingle,
  ExecCmdType::ExecTypeCpuMpi,
  ExecCmdType::ExecTypeGpuSingle
};
const char* _kExecCmdTypeNames[] = {
  "ExecTypeDefault",
  "ExecTypeCpuSingle",
  "ExecTypeCpuMpi",
  "ExecTypeGpuSingle"
};
const std::map<int, const char*> _ExecCmdType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kExecCmdTypeValues, _kExecCmdTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ExecCmdType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExecCmdType_VALUES_TO_NAMES.find(val);
  if (it != _ExecCmdType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ExecCmdType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExecCmdType_VALUES_TO_NAMES.find(val);
  if (it != _ExecCmdType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPauliOperTypeValues[] = {
  PauliOperType::POT_PAULI_I,
  PauliOperType::POT_PAULI_X,
  PauliOperType::POT_PAULI_Y,
  PauliOperType::POT_PAULI_Z
};
const char* _kPauliOperTypeNames[] = {
  "POT_PAULI_I",
  "POT_PAULI_X",
  "POT_PAULI_Y",
  "POT_PAULI_Z"
};
const std::map<int, const char*> _PauliOperType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kPauliOperTypeValues, _kPauliOperTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PauliOperType::type& val) {
  std::map<int, const char*>::const_iterator it = _PauliOperType_VALUES_TO_NAMES.find(val);
  if (it != _PauliOperType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PauliOperType::type& val) {
  std::map<int, const char*>::const_iterator it = _PauliOperType_VALUES_TO_NAMES.find(val);
  if (it != _PauliOperType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kRandomCardStateTypeValues[] = {
  RandomCardStateType::RANDOM_MC_S0,
  RandomCardStateType::RANDOM_MC_S1,
  RandomCardStateType::RANDOM_EEPROM_S,
  RandomCardStateType::RANDOM_PAR_VALUE_S,
  RandomCardStateType::RANDOM_EEPROM_CHECK_S,
  RandomCardStateType::RANDOM_EEPROM_RW_S,
  RandomCardStateType::RANDOM_LD_TEMP_S,
  RandomCardStateType::RANDOM_BD_TEMP_S,
  RandomCardStateType::RANDOM_LINK_S
};
const char* _kRandomCardStateTypeNames[] = {
  "RANDOM_MC_S0",
  "RANDOM_MC_S1",
  "RANDOM_EEPROM_S",
  "RANDOM_PAR_VALUE_S",
  "RANDOM_EEPROM_CHECK_S",
  "RANDOM_EEPROM_RW_S",
  "RANDOM_LD_TEMP_S",
  "RANDOM_BD_TEMP_S",
  "RANDOM_LINK_S"
};
const std::map<int, const char*> _RandomCardStateType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kRandomCardStateTypeValues, _kRandomCardStateTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const RandomCardStateType::type& val) {
  std::map<int, const char*>::const_iterator it = _RandomCardStateType_VALUES_TO_NAMES.find(val);
  if (it != _RandomCardStateType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const RandomCardStateType::type& val) {
  std::map<int, const char*>::const_iterator it = _RandomCardStateType_VALUES_TO_NAMES.find(val);
  if (it != _RandomCardStateType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Amplitude::~Amplitude() noexcept {
}


void Amplitude::__set_reals(const std::vector<double> & val) {
  this->reals = val;
}

void Amplitude::__set_imags(const std::vector<double> & val) {
  this->imags = val;
}

void Amplitude::__set_startind(const int32_t val) {
  this->startind = val;
}

void Amplitude::__set_numamps(const int32_t val) {
  this->numamps = val;
}
std::ostream& operator<<(std::ostream& out, const Amplitude& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Amplitude::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reals = false;
  bool isset_imags = false;
  bool isset_startind = false;
  bool isset_numamps = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->reals.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->reals.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readDouble(this->reals[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_reals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->imags.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->imags.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readDouble(this->imags[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          isset_imags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->startind);
          isset_startind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numamps);
          isset_numamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_imags)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_startind)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Amplitude::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Amplitude");

  xfer += oprot->writeFieldBegin("reals", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->reals.size()));
    std::vector<double> ::const_iterator _iter10;
    for (_iter10 = this->reals.begin(); _iter10 != this->reals.end(); ++_iter10)
    {
      xfer += oprot->writeDouble((*_iter10));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("imags", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->imags.size()));
    std::vector<double> ::const_iterator _iter11;
    for (_iter11 = this->imags.begin(); _iter11 != this->imags.end(); ++_iter11)
    {
      xfer += oprot->writeDouble((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startind", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->startind);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numamps", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->numamps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Amplitude &a, Amplitude &b) {
  using ::std::swap;
  swap(a.reals, b.reals);
  swap(a.imags, b.imags);
  swap(a.startind, b.startind);
  swap(a.numamps, b.numamps);
}

Amplitude::Amplitude(const Amplitude& other12) {
  reals = other12.reals;
  imags = other12.imags;
  startind = other12.startind;
  numamps = other12.numamps;
}
Amplitude& Amplitude::operator=(const Amplitude& other13) {
  reals = other13.reals;
  imags = other13.imags;
  startind = other13.startind;
  numamps = other13.numamps;
  return *this;
}
void Amplitude::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Amplitude(";
  out << "reals=" << to_string(reals);
  out << ", " << "imags=" << to_string(imags);
  out << ", " << "startind=" << to_string(startind);
  out << ", " << "numamps=" << to_string(numamps);
  out << ")";
}


Matrix::~Matrix() noexcept {
}


void Matrix::__set_reals(const std::vector<std::vector<double> > & val) {
  this->reals = val;
}

void Matrix::__set_imags(const std::vector<std::vector<double> > & val) {
  this->imags = val;
}

void Matrix::__set_unitary(const bool val) {
  this->unitary = val;
}
std::ostream& operator<<(std::ostream& out, const Matrix& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Matrix::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reals = false;
  bool isset_imags = false;
  bool isset_unitary = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->reals.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->reals.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              {
                this->reals[_i18].clear();
                uint32_t _size19;
                ::apache::thrift::protocol::TType _etype22;
                xfer += iprot->readListBegin(_etype22, _size19);
                this->reals[_i18].resize(_size19);
                uint32_t _i23;
                for (_i23 = 0; _i23 < _size19; ++_i23)
                {
                  xfer += iprot->readDouble(this->reals[_i18][_i23]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_reals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->imags.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->imags.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              {
                this->imags[_i28].clear();
                uint32_t _size29;
                ::apache::thrift::protocol::TType _etype32;
                xfer += iprot->readListBegin(_etype32, _size29);
                this->imags[_i28].resize(_size29);
                uint32_t _i33;
                for (_i33 = 0; _i33 < _size29; ++_i33)
                {
                  xfer += iprot->readDouble(this->imags[_i28][_i33]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_imags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->unitary);
          isset_unitary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_imags)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unitary)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Matrix::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Matrix");

  xfer += oprot->writeFieldBegin("reals", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->reals.size()));
    std::vector<std::vector<double> > ::const_iterator _iter34;
    for (_iter34 = this->reals.begin(); _iter34 != this->reals.end(); ++_iter34)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*_iter34).size()));
        std::vector<double> ::const_iterator _iter35;
        for (_iter35 = (*_iter34).begin(); _iter35 != (*_iter34).end(); ++_iter35)
        {
          xfer += oprot->writeDouble((*_iter35));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("imags", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->imags.size()));
    std::vector<std::vector<double> > ::const_iterator _iter36;
    for (_iter36 = this->imags.begin(); _iter36 != this->imags.end(); ++_iter36)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*_iter36).size()));
        std::vector<double> ::const_iterator _iter37;
        for (_iter37 = (*_iter36).begin(); _iter37 != (*_iter36).end(); ++_iter37)
        {
          xfer += oprot->writeDouble((*_iter37));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unitary", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->unitary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Matrix &a, Matrix &b) {
  using ::std::swap;
  swap(a.reals, b.reals);
  swap(a.imags, b.imags);
  swap(a.unitary, b.unitary);
}

Matrix::Matrix(const Matrix& other38) {
  reals = other38.reals;
  imags = other38.imags;
  unitary = other38.unitary;
}
Matrix& Matrix::operator=(const Matrix& other39) {
  reals = other39.reals;
  imags = other39.imags;
  unitary = other39.unitary;
  return *this;
}
void Matrix::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Matrix(";
  out << "reals=" << to_string(reals);
  out << ", " << "imags=" << to_string(imags);
  out << ", " << "unitary=" << to_string(unitary);
  out << ")";
}


Cmdex::~Cmdex() noexcept {
}


void Cmdex::__set_amp(const Amplitude& val) {
  this->amp = val;
__isset.amp = true;
}

void Cmdex::__set_mat(const Matrix& val) {
  this->mat = val;
__isset.mat = true;
}
std::ostream& operator<<(std::ostream& out, const Cmdex& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cmdex::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->amp.read(iprot);
          this->__isset.amp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mat.read(iprot);
          this->__isset.mat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cmdex::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cmdex");

  if (this->__isset.amp) {
    xfer += oprot->writeFieldBegin("amp", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->amp.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mat) {
    xfer += oprot->writeFieldBegin("mat", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->mat.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cmdex &a, Cmdex &b) {
  using ::std::swap;
  swap(a.amp, b.amp);
  swap(a.mat, b.mat);
  swap(a.__isset, b.__isset);
}

Cmdex::Cmdex(const Cmdex& other40) {
  amp = other40.amp;
  mat = other40.mat;
  __isset = other40.__isset;
}
Cmdex& Cmdex::operator=(const Cmdex& other41) {
  amp = other41.amp;
  mat = other41.mat;
  __isset = other41.__isset;
  return *this;
}
void Cmdex::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cmdex(";
  out << "amp="; (__isset.amp ? (out << to_string(amp)) : (out << "<null>"));
  out << ", " << "mat="; (__isset.mat ? (out << to_string(mat)) : (out << "<null>"));
  out << ")";
}


Cmd::~Cmd() noexcept {
}


void Cmd::__set_gate(const std::string& val) {
  this->gate = val;
}

void Cmd::__set_targets(const std::vector<int32_t> & val) {
  this->targets = val;
}

void Cmd::__set_controls(const std::vector<int32_t> & val) {
  this->controls = val;
}

void Cmd::__set_rotation(const std::vector<double> & val) {
  this->rotation = val;
}

void Cmd::__set_desc(const std::string& val) {
  this->desc = val;
}

void Cmd::__set_inverse(const bool val) {
  this->inverse = val;
}

void Cmd::__set_cmdex(const Cmdex& val) {
  this->cmdex = val;
__isset.cmdex = true;
}
std::ostream& operator<<(std::ostream& out, const Cmd& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cmd::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_gate = false;
  bool isset_targets = false;
  bool isset_controls = false;
  bool isset_rotation = false;
  bool isset_desc = false;
  bool isset_inverse = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gate);
          isset_gate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->targets.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += iprot->readI32(this->targets[_i46]);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->controls.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->controls.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readI32(this->controls[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          isset_controls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rotation.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->rotation.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += iprot->readDouble(this->rotation[_i56]);
            }
            xfer += iprot->readListEnd();
          }
          isset_rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->desc);
          isset_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inverse);
          isset_inverse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmdex.read(iprot);
          this->__isset.cmdex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_gate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_controls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rotation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_desc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inverse)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Cmd::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cmd");

  xfer += oprot->writeFieldBegin("gate", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->gate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targets.size()));
    std::vector<int32_t> ::const_iterator _iter57;
    for (_iter57 = this->targets.begin(); _iter57 != this->targets.end(); ++_iter57)
    {
      xfer += oprot->writeI32((*_iter57));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("controls", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->controls.size()));
    std::vector<int32_t> ::const_iterator _iter58;
    for (_iter58 = this->controls.begin(); _iter58 != this->controls.end(); ++_iter58)
    {
      xfer += oprot->writeI32((*_iter58));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotation", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->rotation.size()));
    std::vector<double> ::const_iterator _iter59;
    for (_iter59 = this->rotation.begin(); _iter59 != this->rotation.end(); ++_iter59)
    {
      xfer += oprot->writeDouble((*_iter59));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("desc", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->desc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inverse", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->inverse);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cmdex) {
    xfer += oprot->writeFieldBegin("cmdex", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->cmdex.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cmd &a, Cmd &b) {
  using ::std::swap;
  swap(a.gate, b.gate);
  swap(a.targets, b.targets);
  swap(a.controls, b.controls);
  swap(a.rotation, b.rotation);
  swap(a.desc, b.desc);
  swap(a.inverse, b.inverse);
  swap(a.cmdex, b.cmdex);
  swap(a.__isset, b.__isset);
}

Cmd::Cmd(const Cmd& other60) {
  gate = other60.gate;
  targets = other60.targets;
  controls = other60.controls;
  rotation = other60.rotation;
  desc = other60.desc;
  inverse = other60.inverse;
  cmdex = other60.cmdex;
  __isset = other60.__isset;
}
Cmd& Cmd::operator=(const Cmd& other61) {
  gate = other61.gate;
  targets = other61.targets;
  controls = other61.controls;
  rotation = other61.rotation;
  desc = other61.desc;
  inverse = other61.inverse;
  cmdex = other61.cmdex;
  __isset = other61.__isset;
  return *this;
}
void Cmd::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cmd(";
  out << "gate=" << to_string(gate);
  out << ", " << "targets=" << to_string(targets);
  out << ", " << "controls=" << to_string(controls);
  out << ", " << "rotation=" << to_string(rotation);
  out << ", " << "desc=" << to_string(desc);
  out << ", " << "inverse=" << to_string(inverse);
  out << ", " << "cmdex="; (__isset.cmdex ? (out << to_string(cmdex)) : (out << "<null>"));
  out << ")";
}


Circuit::~Circuit() noexcept {
}


void Circuit::__set_cmds(const std::vector<Cmd> & val) {
  this->cmds = val;
}
std::ostream& operator<<(std::ostream& out, const Circuit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Circuit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cmds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cmds.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->cmds.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += this->cmds[_i66].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_cmds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cmds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Circuit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Circuit");

  xfer += oprot->writeFieldBegin("cmds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cmds.size()));
    std::vector<Cmd> ::const_iterator _iter67;
    for (_iter67 = this->cmds.begin(); _iter67 != this->cmds.end(); ++_iter67)
    {
      xfer += (*_iter67).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Circuit &a, Circuit &b) {
  using ::std::swap;
  swap(a.cmds, b.cmds);
}

Circuit::Circuit(const Circuit& other68) {
  cmds = other68.cmds;
}
Circuit& Circuit::operator=(const Circuit& other69) {
  cmds = other69.cmds;
  return *this;
}
void Circuit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Circuit(";
  out << "cmds=" << to_string(cmds);
  out << ")";
}


MeasureQubit::~MeasureQubit() noexcept {
}


void MeasureQubit::__set_idx(const int32_t val) {
  this->idx = val;
}

void MeasureQubit::__set_value(const int32_t val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureQubit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureQubit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_idx = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->idx);
          isset_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_idx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureQubit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureQubit");

  xfer += oprot->writeFieldBegin("idx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureQubit &a, MeasureQubit &b) {
  using ::std::swap;
  swap(a.idx, b.idx);
  swap(a.value, b.value);
}

MeasureQubit::MeasureQubit(const MeasureQubit& other70) noexcept {
  idx = other70.idx;
  value = other70.value;
}
MeasureQubit& MeasureQubit::operator=(const MeasureQubit& other71) noexcept {
  idx = other71.idx;
  value = other71.value;
  return *this;
}
void MeasureQubit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureQubit(";
  out << "idx=" << to_string(idx);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


MeasureQubits::~MeasureQubits() noexcept {
}


void MeasureQubits::__set_measure(const std::vector<MeasureQubit> & val) {
  this->measure = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureQubits& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureQubits::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_measure = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measure.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->measure.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += this->measure[_i76].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_measure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_measure)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureQubits::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureQubits");

  xfer += oprot->writeFieldBegin("measure", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->measure.size()));
    std::vector<MeasureQubit> ::const_iterator _iter77;
    for (_iter77 = this->measure.begin(); _iter77 != this->measure.end(); ++_iter77)
    {
      xfer += (*_iter77).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureQubits &a, MeasureQubits &b) {
  using ::std::swap;
  swap(a.measure, b.measure);
}

MeasureQubits::MeasureQubits(const MeasureQubits& other78) {
  measure = other78.measure;
}
MeasureQubits& MeasureQubits::operator=(const MeasureQubits& other79) {
  measure = other79.measure;
  return *this;
}
void MeasureQubits::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureQubits(";
  out << "measure=" << to_string(measure);
  out << ")";
}


MeasureResult::~MeasureResult() noexcept {
}


void MeasureResult::__set_measures(const std::vector<MeasureQubits> & val) {
  this->measures = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_measures = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measures.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _etype83;
            xfer += iprot->readListBegin(_etype83, _size80);
            this->measures.resize(_size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              xfer += this->measures[_i84].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_measures = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_measures)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureResult");

  xfer += oprot->writeFieldBegin("measures", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->measures.size()));
    std::vector<MeasureQubits> ::const_iterator _iter85;
    for (_iter85 = this->measures.begin(); _iter85 != this->measures.end(); ++_iter85)
    {
      xfer += (*_iter85).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureResult &a, MeasureResult &b) {
  using ::std::swap;
  swap(a.measures, b.measures);
}

MeasureResult::MeasureResult(const MeasureResult& other86) {
  measures = other86.measures;
}
MeasureResult& MeasureResult::operator=(const MeasureResult& other87) {
  measures = other87.measures;
  return *this;
}
void MeasureResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureResult(";
  out << "measures=" << to_string(measures);
  out << ")";
}


InitQubitsReq::~InitQubitsReq() noexcept {
}


void InitQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void InitQubitsReq::__set_qubits(const int32_t val) {
  this->qubits = val;
}

void InitQubitsReq::__set_density(const bool val) {
  this->density = val;
__isset.density = true;
}

void InitQubitsReq::__set_exec_type(const ExecCmdType::type val) {
  this->exec_type = val;
__isset.exec_type = true;
}

void InitQubitsReq::__set_hosts(const std::vector<std::string> & val) {
  this->hosts = val;
__isset.hosts = true;
}
std::ostream& operator<<(std::ostream& out, const InitQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->density);
          this->__isset.density = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast88;
          xfer += iprot->readI32(ecast88);
          this->exec_type = static_cast<ExecCmdType::type>(ecast88);
          this->__isset.exec_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hosts.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            xfer += iprot->readListBegin(_etype92, _size89);
            this->hosts.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += iprot->readString(this->hosts[_i93]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InitQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.density) {
    xfer += oprot->writeFieldBegin("density", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->density);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exec_type) {
    xfer += oprot->writeFieldBegin("exec_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->exec_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hosts) {
    xfer += oprot->writeFieldBegin("hosts", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hosts.size()));
      std::vector<std::string> ::const_iterator _iter94;
      for (_iter94 = this->hosts.begin(); _iter94 != this->hosts.end(); ++_iter94)
      {
        xfer += oprot->writeString((*_iter94));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitQubitsReq &a, InitQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
  swap(a.density, b.density);
  swap(a.exec_type, b.exec_type);
  swap(a.hosts, b.hosts);
  swap(a.__isset, b.__isset);
}

InitQubitsReq::InitQubitsReq(const InitQubitsReq& other95) {
  id = other95.id;
  qubits = other95.qubits;
  density = other95.density;
  exec_type = other95.exec_type;
  hosts = other95.hosts;
  __isset = other95.__isset;
}
InitQubitsReq& InitQubitsReq::operator=(const InitQubitsReq& other96) {
  id = other96.id;
  qubits = other96.qubits;
  density = other96.density;
  exec_type = other96.exec_type;
  hosts = other96.hosts;
  __isset = other96.__isset;
  return *this;
}
void InitQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ", " << "density="; (__isset.density ? (out << to_string(density)) : (out << "<null>"));
  out << ", " << "exec_type="; (__isset.exec_type ? (out << to_string(exec_type)) : (out << "<null>"));
  out << ", " << "hosts="; (__isset.hosts ? (out << to_string(hosts)) : (out << "<null>"));
  out << ")";
}


InitQubitsResp::~InitQubitsResp() noexcept {
}


void InitQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const InitQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InitQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitQubitsResp &a, InitQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

InitQubitsResp::InitQubitsResp(const InitQubitsResp& other97) {
  base = other97.base;
}
InitQubitsResp& InitQubitsResp::operator=(const InitQubitsResp& other98) {
  base = other98.base;
  return *this;
}
void InitQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


SendCircuitCmdReq::~SendCircuitCmdReq() noexcept {
}


void SendCircuitCmdReq::__set_id(const std::string& val) {
  this->id = val;
}

void SendCircuitCmdReq::__set_circuit(const Circuit& val) {
  this->circuit = val;
__isset.circuit = true;
}

void SendCircuitCmdReq::__set_final(const bool val) {
  this->final = val;
__isset.final = true;
}
std::ostream& operator<<(std::ostream& out, const SendCircuitCmdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SendCircuitCmdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->circuit.read(iprot);
          this->__isset.circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->final);
          this->__isset.final = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SendCircuitCmdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SendCircuitCmdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.circuit) {
    xfer += oprot->writeFieldBegin("circuit", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->circuit.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.final) {
    xfer += oprot->writeFieldBegin("final", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->final);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SendCircuitCmdReq &a, SendCircuitCmdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.circuit, b.circuit);
  swap(a.final, b.final);
  swap(a.__isset, b.__isset);
}

SendCircuitCmdReq::SendCircuitCmdReq(const SendCircuitCmdReq& other99) {
  id = other99.id;
  circuit = other99.circuit;
  final = other99.final;
  __isset = other99.__isset;
}
SendCircuitCmdReq& SendCircuitCmdReq::operator=(const SendCircuitCmdReq& other100) {
  id = other100.id;
  circuit = other100.circuit;
  final = other100.final;
  __isset = other100.__isset;
  return *this;
}
void SendCircuitCmdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SendCircuitCmdReq(";
  out << "id=" << to_string(id);
  out << ", " << "circuit="; (__isset.circuit ? (out << to_string(circuit)) : (out << "<null>"));
  out << ", " << "final="; (__isset.final ? (out << to_string(final)) : (out << "<null>"));
  out << ")";
}


SendCircuitCmdResp::~SendCircuitCmdResp() noexcept {
}


void SendCircuitCmdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const SendCircuitCmdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SendCircuitCmdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SendCircuitCmdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SendCircuitCmdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SendCircuitCmdResp &a, SendCircuitCmdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

SendCircuitCmdResp::SendCircuitCmdResp(const SendCircuitCmdResp& other101) {
  base = other101.base;
}
SendCircuitCmdResp& SendCircuitCmdResp::operator=(const SendCircuitCmdResp& other102) {
  base = other102.base;
  return *this;
}
void SendCircuitCmdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SendCircuitCmdResp(";
  out << "base=" << to_string(base);
  out << ")";
}


CancelCmdReq::~CancelCmdReq() noexcept {
}


void CancelCmdReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const CancelCmdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CancelCmdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CancelCmdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CancelCmdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CancelCmdReq &a, CancelCmdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

CancelCmdReq::CancelCmdReq(const CancelCmdReq& other103) {
  id = other103.id;
}
CancelCmdReq& CancelCmdReq::operator=(const CancelCmdReq& other104) {
  id = other104.id;
  return *this;
}
void CancelCmdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CancelCmdReq(";
  out << "id=" << to_string(id);
  out << ")";
}


CancelCmdResp::~CancelCmdResp() noexcept {
}


void CancelCmdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const CancelCmdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CancelCmdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CancelCmdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CancelCmdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CancelCmdResp &a, CancelCmdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

CancelCmdResp::CancelCmdResp(const CancelCmdResp& other105) {
  base = other105.base;
}
CancelCmdResp& CancelCmdResp::operator=(const CancelCmdResp& other106) {
  base = other106.base;
  return *this;
}
void CancelCmdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CancelCmdResp(";
  out << "base=" << to_string(base);
  out << ")";
}


GetProbAmpReq::~GetProbAmpReq() noexcept {
}


void GetProbAmpReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetProbAmpReq::__set_index(const int64_t val) {
  this->index = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbAmpReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbAmpReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_index = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->index);
          isset_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbAmpReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbAmpReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbAmpReq &a, GetProbAmpReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.index, b.index);
}

GetProbAmpReq::GetProbAmpReq(const GetProbAmpReq& other107) {
  id = other107.id;
  index = other107.index;
}
GetProbAmpReq& GetProbAmpReq::operator=(const GetProbAmpReq& other108) {
  id = other108.id;
  index = other108.index;
  return *this;
}
void GetProbAmpReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbAmpReq(";
  out << "id=" << to_string(id);
  out << ", " << "index=" << to_string(index);
  out << ")";
}


GetProbAmpResp::~GetProbAmpResp() noexcept {
}


void GetProbAmpResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbAmpResp::__set_amp(const double val) {
  this->amp = val;
__isset.amp = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbAmpResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbAmpResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->amp);
          this->__isset.amp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbAmpResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbAmpResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.amp) {
    xfer += oprot->writeFieldBegin("amp", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->amp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbAmpResp &a, GetProbAmpResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.amp, b.amp);
  swap(a.__isset, b.__isset);
}

GetProbAmpResp::GetProbAmpResp(const GetProbAmpResp& other109) {
  base = other109.base;
  amp = other109.amp;
  __isset = other109.__isset;
}
GetProbAmpResp& GetProbAmpResp::operator=(const GetProbAmpResp& other110) {
  base = other110.base;
  amp = other110.amp;
  __isset = other110.__isset;
  return *this;
}
void GetProbAmpResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbAmpResp(";
  out << "base=" << to_string(base);
  out << ", " << "amp="; (__isset.amp ? (out << to_string(amp)) : (out << "<null>"));
  out << ")";
}


GetProbOfAllOutcomReq::~GetProbOfAllOutcomReq() noexcept {
}


void GetProbOfAllOutcomReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetProbOfAllOutcomReq::__set_targets(const std::vector<int32_t> & val) {
  this->targets = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfAllOutcomReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfAllOutcomReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_targets = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size111;
            ::apache::thrift::protocol::TType _etype114;
            xfer += iprot->readListBegin(_etype114, _size111);
            this->targets.resize(_size111);
            uint32_t _i115;
            for (_i115 = 0; _i115 < _size111; ++_i115)
            {
              xfer += iprot->readI32(this->targets[_i115]);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfAllOutcomReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfAllOutcomReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targets.size()));
    std::vector<int32_t> ::const_iterator _iter116;
    for (_iter116 = this->targets.begin(); _iter116 != this->targets.end(); ++_iter116)
    {
      xfer += oprot->writeI32((*_iter116));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfAllOutcomReq &a, GetProbOfAllOutcomReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.targets, b.targets);
}

GetProbOfAllOutcomReq::GetProbOfAllOutcomReq(const GetProbOfAllOutcomReq& other117) {
  id = other117.id;
  targets = other117.targets;
}
GetProbOfAllOutcomReq& GetProbOfAllOutcomReq::operator=(const GetProbOfAllOutcomReq& other118) {
  id = other118.id;
  targets = other118.targets;
  return *this;
}
void GetProbOfAllOutcomReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfAllOutcomReq(";
  out << "id=" << to_string(id);
  out << ", " << "targets=" << to_string(targets);
  out << ")";
}


GetProbOfAllOutcomResp::~GetProbOfAllOutcomResp() noexcept {
}


void GetProbOfAllOutcomResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbOfAllOutcomResp::__set_pro_outcomes(const std::vector<double> & val) {
  this->pro_outcomes = val;
__isset.pro_outcomes = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfAllOutcomResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfAllOutcomResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pro_outcomes.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _etype122;
            xfer += iprot->readListBegin(_etype122, _size119);
            this->pro_outcomes.resize(_size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              xfer += iprot->readDouble(this->pro_outcomes[_i123]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pro_outcomes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfAllOutcomResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfAllOutcomResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pro_outcomes) {
    xfer += oprot->writeFieldBegin("pro_outcomes", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->pro_outcomes.size()));
      std::vector<double> ::const_iterator _iter124;
      for (_iter124 = this->pro_outcomes.begin(); _iter124 != this->pro_outcomes.end(); ++_iter124)
      {
        xfer += oprot->writeDouble((*_iter124));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfAllOutcomResp &a, GetProbOfAllOutcomResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.pro_outcomes, b.pro_outcomes);
  swap(a.__isset, b.__isset);
}

GetProbOfAllOutcomResp::GetProbOfAllOutcomResp(const GetProbOfAllOutcomResp& other125) {
  base = other125.base;
  pro_outcomes = other125.pro_outcomes;
  __isset = other125.__isset;
}
GetProbOfAllOutcomResp& GetProbOfAllOutcomResp::operator=(const GetProbOfAllOutcomResp& other126) {
  base = other126.base;
  pro_outcomes = other126.pro_outcomes;
  __isset = other126.__isset;
  return *this;
}
void GetProbOfAllOutcomResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfAllOutcomResp(";
  out << "base=" << to_string(base);
  out << ", " << "pro_outcomes="; (__isset.pro_outcomes ? (out << to_string(pro_outcomes)) : (out << "<null>"));
  out << ")";
}


GetAllStateReq::~GetAllStateReq() noexcept {
}


void GetAllStateReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetAllStateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllStateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetAllStateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllStateReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllStateReq &a, GetAllStateReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetAllStateReq::GetAllStateReq(const GetAllStateReq& other127) {
  id = other127.id;
}
GetAllStateReq& GetAllStateReq::operator=(const GetAllStateReq& other128) {
  id = other128.id;
  return *this;
}
void GetAllStateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllStateReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetAllStateResp::~GetAllStateResp() noexcept {
}


void GetAllStateResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetAllStateResp::__set_all_state(const std::vector<std::string> & val) {
  this->all_state = val;
__isset.all_state = true;
}
std::ostream& operator<<(std::ostream& out, const GetAllStateResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllStateResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->all_state.clear();
            uint32_t _size129;
            ::apache::thrift::protocol::TType _etype132;
            xfer += iprot->readListBegin(_etype132, _size129);
            this->all_state.resize(_size129);
            uint32_t _i133;
            for (_i133 = 0; _i133 < _size129; ++_i133)
            {
              xfer += iprot->readString(this->all_state[_i133]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.all_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetAllStateResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllStateResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.all_state) {
    xfer += oprot->writeFieldBegin("all_state", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->all_state.size()));
      std::vector<std::string> ::const_iterator _iter134;
      for (_iter134 = this->all_state.begin(); _iter134 != this->all_state.end(); ++_iter134)
      {
        xfer += oprot->writeString((*_iter134));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllStateResp &a, GetAllStateResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.all_state, b.all_state);
  swap(a.__isset, b.__isset);
}

GetAllStateResp::GetAllStateResp(const GetAllStateResp& other135) {
  base = other135.base;
  all_state = other135.all_state;
  __isset = other135.__isset;
}
GetAllStateResp& GetAllStateResp::operator=(const GetAllStateResp& other136) {
  base = other136.base;
  all_state = other136.all_state;
  __isset = other136.__isset;
  return *this;
}
void GetAllStateResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllStateResp(";
  out << "base=" << to_string(base);
  out << ", " << "all_state="; (__isset.all_state ? (out << to_string(all_state)) : (out << "<null>"));
  out << ")";
}


RunCircuitReq::~RunCircuitReq() noexcept {
}


void RunCircuitReq::__set_id(const std::string& val) {
  this->id = val;
}

void RunCircuitReq::__set_shots(const int32_t val) {
  this->shots = val;
}
std::ostream& operator<<(std::ostream& out, const RunCircuitReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RunCircuitReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_shots = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shots);
          isset_shots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_shots)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RunCircuitReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RunCircuitReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shots", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->shots);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RunCircuitReq &a, RunCircuitReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.shots, b.shots);
}

RunCircuitReq::RunCircuitReq(const RunCircuitReq& other137) {
  id = other137.id;
  shots = other137.shots;
}
RunCircuitReq& RunCircuitReq::operator=(const RunCircuitReq& other138) {
  id = other138.id;
  shots = other138.shots;
  return *this;
}
void RunCircuitReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RunCircuitReq(";
  out << "id=" << to_string(id);
  out << ", " << "shots=" << to_string(shots);
  out << ")";
}


RunCircuitResp::~RunCircuitResp() noexcept {
}


void RunCircuitResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void RunCircuitResp::__set_result(const MeasureResult& val) {
  this->result = val;
__isset.result = true;
}
std::ostream& operator<<(std::ostream& out, const RunCircuitResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RunCircuitResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RunCircuitResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RunCircuitResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.result) {
    xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->result.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RunCircuitResp &a, RunCircuitResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

RunCircuitResp::RunCircuitResp(const RunCircuitResp& other139) {
  base = other139.base;
  result = other139.result;
  __isset = other139.__isset;
}
RunCircuitResp& RunCircuitResp::operator=(const RunCircuitResp& other140) {
  base = other140.base;
  result = other140.result;
  __isset = other140.__isset;
  return *this;
}
void RunCircuitResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RunCircuitResp(";
  out << "base=" << to_string(base);
  out << ", " << "result="; (__isset.result ? (out << to_string(result)) : (out << "<null>"));
  out << ")";
}


GetExpecPauliProdReq::~GetExpecPauliProdReq() noexcept {
}


void GetExpecPauliProdReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetExpecPauliProdReq::__set_pauli_prod(const std::vector<PauliProdInfo> & val) {
  this->pauli_prod = val;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliProdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliProdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_pauli_prod = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pauli_prod.clear();
            uint32_t _size141;
            ::apache::thrift::protocol::TType _etype144;
            xfer += iprot->readListBegin(_etype144, _size141);
            this->pauli_prod.resize(_size141);
            uint32_t _i145;
            for (_i145 = 0; _i145 < _size141; ++_i145)
            {
              xfer += this->pauli_prod[_i145].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_pauli_prod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pauli_prod)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliProdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliProdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pauli_prod", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pauli_prod.size()));
    std::vector<PauliProdInfo> ::const_iterator _iter146;
    for (_iter146 = this->pauli_prod.begin(); _iter146 != this->pauli_prod.end(); ++_iter146)
    {
      xfer += (*_iter146).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliProdReq &a, GetExpecPauliProdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.pauli_prod, b.pauli_prod);
}

GetExpecPauliProdReq::GetExpecPauliProdReq(const GetExpecPauliProdReq& other147) {
  id = other147.id;
  pauli_prod = other147.pauli_prod;
}
GetExpecPauliProdReq& GetExpecPauliProdReq::operator=(const GetExpecPauliProdReq& other148) {
  id = other148.id;
  pauli_prod = other148.pauli_prod;
  return *this;
}
void GetExpecPauliProdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliProdReq(";
  out << "id=" << to_string(id);
  out << ", " << "pauli_prod=" << to_string(pauli_prod);
  out << ")";
}


GetExpecPauliProdResp::~GetExpecPauliProdResp() noexcept {
}


void GetExpecPauliProdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetExpecPauliProdResp::__set_expect(const double val) {
  this->expect = val;
__isset.expect = true;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliProdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliProdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->expect);
          this->__isset.expect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliProdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliProdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.expect) {
    xfer += oprot->writeFieldBegin("expect", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->expect);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliProdResp &a, GetExpecPauliProdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.expect, b.expect);
  swap(a.__isset, b.__isset);
}

GetExpecPauliProdResp::GetExpecPauliProdResp(const GetExpecPauliProdResp& other149) {
  base = other149.base;
  expect = other149.expect;
  __isset = other149.__isset;
}
GetExpecPauliProdResp& GetExpecPauliProdResp::operator=(const GetExpecPauliProdResp& other150) {
  base = other150.base;
  expect = other150.expect;
  __isset = other150.__isset;
  return *this;
}
void GetExpecPauliProdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliProdResp(";
  out << "base=" << to_string(base);
  out << ", " << "expect="; (__isset.expect ? (out << to_string(expect)) : (out << "<null>"));
  out << ")";
}


PauliProdInfo::~PauliProdInfo() noexcept {
}


void PauliProdInfo::__set_oper_type(const PauliOperType::type val) {
  this->oper_type = val;
}

void PauliProdInfo::__set_target(const int32_t val) {
  this->target = val;
}
std::ostream& operator<<(std::ostream& out, const PauliProdInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PauliProdInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_oper_type = false;
  bool isset_target = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast151;
          xfer += iprot->readI32(ecast151);
          this->oper_type = static_cast<PauliOperType::type>(ecast151);
          isset_oper_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->target);
          isset_target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_oper_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PauliProdInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PauliProdInfo");

  xfer += oprot->writeFieldBegin("oper_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->oper_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PauliProdInfo &a, PauliProdInfo &b) {
  using ::std::swap;
  swap(a.oper_type, b.oper_type);
  swap(a.target, b.target);
}

PauliProdInfo::PauliProdInfo(const PauliProdInfo& other152) noexcept {
  oper_type = other152.oper_type;
  target = other152.target;
}
PauliProdInfo& PauliProdInfo::operator=(const PauliProdInfo& other153) noexcept {
  oper_type = other153.oper_type;
  target = other153.target;
  return *this;
}
void PauliProdInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PauliProdInfo(";
  out << "oper_type=" << to_string(oper_type);
  out << ", " << "target=" << to_string(target);
  out << ")";
}


GetExpecPauliSumReq::~GetExpecPauliSumReq() noexcept {
}


void GetExpecPauliSumReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetExpecPauliSumReq::__set_oper_type_list(const std::vector<PauliOperType::type> & val) {
  this->oper_type_list = val;
}

void GetExpecPauliSumReq::__set_term_coeff_list(const std::vector<double> & val) {
  this->term_coeff_list = val;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliSumReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliSumReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_oper_type_list = false;
  bool isset_term_coeff_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->oper_type_list.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->oper_type_list.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              int32_t ecast159;
              xfer += iprot->readI32(ecast159);
              this->oper_type_list[_i158] = static_cast<PauliOperType::type>(ecast159);
            }
            xfer += iprot->readListEnd();
          }
          isset_oper_type_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->term_coeff_list.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readListBegin(_etype163, _size160);
            this->term_coeff_list.resize(_size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              xfer += iprot->readDouble(this->term_coeff_list[_i164]);
            }
            xfer += iprot->readListEnd();
          }
          isset_term_coeff_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_oper_type_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_term_coeff_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliSumReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliSumReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oper_type_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->oper_type_list.size()));
    std::vector<PauliOperType::type> ::const_iterator _iter165;
    for (_iter165 = this->oper_type_list.begin(); _iter165 != this->oper_type_list.end(); ++_iter165)
    {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter165)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("term_coeff_list", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->term_coeff_list.size()));
    std::vector<double> ::const_iterator _iter166;
    for (_iter166 = this->term_coeff_list.begin(); _iter166 != this->term_coeff_list.end(); ++_iter166)
    {
      xfer += oprot->writeDouble((*_iter166));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliSumReq &a, GetExpecPauliSumReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.oper_type_list, b.oper_type_list);
  swap(a.term_coeff_list, b.term_coeff_list);
}

GetExpecPauliSumReq::GetExpecPauliSumReq(const GetExpecPauliSumReq& other167) {
  id = other167.id;
  oper_type_list = other167.oper_type_list;
  term_coeff_list = other167.term_coeff_list;
}
GetExpecPauliSumReq& GetExpecPauliSumReq::operator=(const GetExpecPauliSumReq& other168) {
  id = other168.id;
  oper_type_list = other168.oper_type_list;
  term_coeff_list = other168.term_coeff_list;
  return *this;
}
void GetExpecPauliSumReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliSumReq(";
  out << "id=" << to_string(id);
  out << ", " << "oper_type_list=" << to_string(oper_type_list);
  out << ", " << "term_coeff_list=" << to_string(term_coeff_list);
  out << ")";
}


GetExpecPauliSumResp::~GetExpecPauliSumResp() noexcept {
}


void GetExpecPauliSumResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetExpecPauliSumResp::__set_expect(const double val) {
  this->expect = val;
__isset.expect = true;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliSumResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliSumResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->expect);
          this->__isset.expect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliSumResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliSumResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.expect) {
    xfer += oprot->writeFieldBegin("expect", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->expect);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliSumResp &a, GetExpecPauliSumResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.expect, b.expect);
  swap(a.__isset, b.__isset);
}

GetExpecPauliSumResp::GetExpecPauliSumResp(const GetExpecPauliSumResp& other169) {
  base = other169.base;
  expect = other169.expect;
  __isset = other169.__isset;
}
GetExpecPauliSumResp& GetExpecPauliSumResp::operator=(const GetExpecPauliSumResp& other170) {
  base = other170.base;
  expect = other170.expect;
  __isset = other170.__isset;
  return *this;
}
void GetExpecPauliSumResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliSumResp(";
  out << "base=" << to_string(base);
  out << ", " << "expect="; (__isset.expect ? (out << to_string(expect)) : (out << "<null>"));
  out << ")";
}


MeasureQubitsReq::~MeasureQubitsReq() noexcept {
}


void MeasureQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void MeasureQubitsReq::__set_qubits(const std::vector<int32_t> & val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->qubits.clear();
            uint32_t _size171;
            ::apache::thrift::protocol::TType _etype174;
            xfer += iprot->readListBegin(_etype174, _size171);
            this->qubits.resize(_size171);
            uint32_t _i175;
            for (_i175 = 0; _i175 < _size171; ++_i175)
            {
              xfer += iprot->readI32(this->qubits[_i175]);
            }
            xfer += iprot->readListEnd();
          }
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->qubits.size()));
    std::vector<int32_t> ::const_iterator _iter176;
    for (_iter176 = this->qubits.begin(); _iter176 != this->qubits.end(); ++_iter176)
    {
      xfer += oprot->writeI32((*_iter176));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureQubitsReq &a, MeasureQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

MeasureQubitsReq::MeasureQubitsReq(const MeasureQubitsReq& other177) {
  id = other177.id;
  qubits = other177.qubits;
}
MeasureQubitsReq& MeasureQubitsReq::operator=(const MeasureQubitsReq& other178) {
  id = other178.id;
  qubits = other178.qubits;
  return *this;
}
void MeasureQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


MeasureQubitsResp::~MeasureQubitsResp() noexcept {
}


void MeasureQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void MeasureQubitsResp::__set_result(const MeasureResult& val) {
  this->result = val;
__isset.result = true;
}
std::ostream& operator<<(std::ostream& out, const MeasureQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.result) {
    xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->result.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureQubitsResp &a, MeasureQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

MeasureQubitsResp::MeasureQubitsResp(const MeasureQubitsResp& other179) {
  base = other179.base;
  result = other179.result;
  __isset = other179.__isset;
}
MeasureQubitsResp& MeasureQubitsResp::operator=(const MeasureQubitsResp& other180) {
  base = other180.base;
  result = other180.result;
  __isset = other180.__isset;
  return *this;
}
void MeasureQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureQubitsResp(";
  out << "base=" << to_string(base);
  out << ", " << "result="; (__isset.result ? (out << to_string(result)) : (out << "<null>"));
  out << ")";
}


GateMatrix::~GateMatrix() noexcept {
}


void GateMatrix::__set_name(const std::string& val) {
  this->name = val;
}

void GateMatrix::__set_qubits(const int32_t val) {
  this->qubits = val;
}

void GateMatrix::__set_matrix(const std::vector<double> & val) {
  this->matrix = val;
}
std::ostream& operator<<(std::ostream& out, const GateMatrix& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GateMatrix::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_qubits = false;
  bool isset_matrix = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->matrix.clear();
            uint32_t _size181;
            ::apache::thrift::protocol::TType _etype184;
            xfer += iprot->readListBegin(_etype184, _size181);
            this->matrix.resize(_size181);
            uint32_t _i185;
            for (_i185 = 0; _i185 < _size181; ++_i185)
            {
              xfer += iprot->readDouble(this->matrix[_i185]);
            }
            xfer += iprot->readListEnd();
          }
          isset_matrix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_matrix)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GateMatrix::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GateMatrix");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matrix", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->matrix.size()));
    std::vector<double> ::const_iterator _iter186;
    for (_iter186 = this->matrix.begin(); _iter186 != this->matrix.end(); ++_iter186)
    {
      xfer += oprot->writeDouble((*_iter186));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GateMatrix &a, GateMatrix &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.qubits, b.qubits);
  swap(a.matrix, b.matrix);
}

GateMatrix::GateMatrix(const GateMatrix& other187) {
  name = other187.name;
  qubits = other187.qubits;
  matrix = other187.matrix;
}
GateMatrix& GateMatrix::operator=(const GateMatrix& other188) {
  name = other188.name;
  qubits = other188.qubits;
  matrix = other188.matrix;
  return *this;
}
void GateMatrix::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GateMatrix(";
  out << "name=" << to_string(name);
  out << ", " << "qubits=" << to_string(qubits);
  out << ", " << "matrix=" << to_string(matrix);
  out << ")";
}


AddCustomGateByMatrixReq::~AddCustomGateByMatrixReq() noexcept {
}


void AddCustomGateByMatrixReq::__set_id(const std::string& val) {
  this->id = val;
}

void AddCustomGateByMatrixReq::__set_gate(const GateMatrix& val) {
  this->gate = val;
}
std::ostream& operator<<(std::ostream& out, const AddCustomGateByMatrixReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddCustomGateByMatrixReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_gate = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gate.read(iprot);
          isset_gate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddCustomGateByMatrixReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddCustomGateByMatrixReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gate", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->gate.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddCustomGateByMatrixReq &a, AddCustomGateByMatrixReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.gate, b.gate);
}

AddCustomGateByMatrixReq::AddCustomGateByMatrixReq(const AddCustomGateByMatrixReq& other189) {
  id = other189.id;
  gate = other189.gate;
}
AddCustomGateByMatrixReq& AddCustomGateByMatrixReq::operator=(const AddCustomGateByMatrixReq& other190) {
  id = other190.id;
  gate = other190.gate;
  return *this;
}
void AddCustomGateByMatrixReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddCustomGateByMatrixReq(";
  out << "id=" << to_string(id);
  out << ", " << "gate=" << to_string(gate);
  out << ")";
}


AddCustomGateByMatrixResp::~AddCustomGateByMatrixResp() noexcept {
}


void AddCustomGateByMatrixResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AddCustomGateByMatrixResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddCustomGateByMatrixResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddCustomGateByMatrixResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddCustomGateByMatrixResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddCustomGateByMatrixResp &a, AddCustomGateByMatrixResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AddCustomGateByMatrixResp::AddCustomGateByMatrixResp(const AddCustomGateByMatrixResp& other191) {
  base = other191.base;
}
AddCustomGateByMatrixResp& AddCustomGateByMatrixResp::operator=(const AddCustomGateByMatrixResp& other192) {
  base = other192.base;
  return *this;
}
void AddCustomGateByMatrixResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddCustomGateByMatrixResp(";
  out << "base=" << to_string(base);
  out << ")";
}


SubCircuit::~SubCircuit() noexcept {
}


void SubCircuit::__set_name(const std::string& val) {
  this->name = val;
}

void SubCircuit::__set_circuit(const Circuit& val) {
  this->circuit = val;
}
std::ostream& operator<<(std::ostream& out, const SubCircuit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SubCircuit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_circuit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->circuit.read(iprot);
          isset_circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_circuit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SubCircuit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SubCircuit");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("circuit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->circuit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SubCircuit &a, SubCircuit &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.circuit, b.circuit);
}

SubCircuit::SubCircuit(const SubCircuit& other193) {
  name = other193.name;
  circuit = other193.circuit;
}
SubCircuit& SubCircuit::operator=(const SubCircuit& other194) {
  name = other194.name;
  circuit = other194.circuit;
  return *this;
}
void SubCircuit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SubCircuit(";
  out << "name=" << to_string(name);
  out << ", " << "circuit=" << to_string(circuit);
  out << ")";
}


AddSubCircuitReq::~AddSubCircuitReq() noexcept {
}


void AddSubCircuitReq::__set_id(const std::string& val) {
  this->id = val;
}

void AddSubCircuitReq::__set_sub_circuit(const SubCircuit& val) {
  this->sub_circuit = val;
}
std::ostream& operator<<(std::ostream& out, const AddSubCircuitReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddSubCircuitReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_sub_circuit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sub_circuit.read(iprot);
          isset_sub_circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sub_circuit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddSubCircuitReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddSubCircuitReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sub_circuit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->sub_circuit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddSubCircuitReq &a, AddSubCircuitReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.sub_circuit, b.sub_circuit);
}

AddSubCircuitReq::AddSubCircuitReq(const AddSubCircuitReq& other195) {
  id = other195.id;
  sub_circuit = other195.sub_circuit;
}
AddSubCircuitReq& AddSubCircuitReq::operator=(const AddSubCircuitReq& other196) {
  id = other196.id;
  sub_circuit = other196.sub_circuit;
  return *this;
}
void AddSubCircuitReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddSubCircuitReq(";
  out << "id=" << to_string(id);
  out << ", " << "sub_circuit=" << to_string(sub_circuit);
  out << ")";
}


AddSubCircuitResp::~AddSubCircuitResp() noexcept {
}


void AddSubCircuitResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AddSubCircuitResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddSubCircuitResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddSubCircuitResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddSubCircuitResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddSubCircuitResp &a, AddSubCircuitResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AddSubCircuitResp::AddSubCircuitResp(const AddSubCircuitResp& other197) {
  base = other197.base;
}
AddSubCircuitResp& AddSubCircuitResp::operator=(const AddSubCircuitResp& other198) {
  base = other198.base;
  return *this;
}
void AddSubCircuitResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddSubCircuitResp(";
  out << "base=" << to_string(base);
  out << ")";
}


AppendQubitsReq::~AppendQubitsReq() noexcept {
}


void AppendQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void AppendQubitsReq::__set_qubits(const int32_t val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const AppendQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppendQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppendQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppendQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppendQubitsReq &a, AppendQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

AppendQubitsReq::AppendQubitsReq(const AppendQubitsReq& other199) {
  id = other199.id;
  qubits = other199.qubits;
}
AppendQubitsReq& AppendQubitsReq::operator=(const AppendQubitsReq& other200) {
  id = other200.id;
  qubits = other200.qubits;
  return *this;
}
void AppendQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppendQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


AppendQubitsResp::~AppendQubitsResp() noexcept {
}


void AppendQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AppendQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppendQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppendQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppendQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppendQubitsResp &a, AppendQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AppendQubitsResp::AppendQubitsResp(const AppendQubitsResp& other201) {
  base = other201.base;
}
AppendQubitsResp& AppendQubitsResp::operator=(const AppendQubitsResp& other202) {
  base = other202.base;
  return *this;
}
void AppendQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppendQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


ResetQubitsReq::~ResetQubitsReq() noexcept {
}


void ResetQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void ResetQubitsReq::__set_qubits(const std::vector<int32_t> & val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const ResetQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResetQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->qubits.clear();
            uint32_t _size203;
            ::apache::thrift::protocol::TType _etype206;
            xfer += iprot->readListBegin(_etype206, _size203);
            this->qubits.resize(_size203);
            uint32_t _i207;
            for (_i207 = 0; _i207 < _size203; ++_i207)
            {
              xfer += iprot->readI32(this->qubits[_i207]);
            }
            xfer += iprot->readListEnd();
          }
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResetQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResetQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->qubits.size()));
    std::vector<int32_t> ::const_iterator _iter208;
    for (_iter208 = this->qubits.begin(); _iter208 != this->qubits.end(); ++_iter208)
    {
      xfer += oprot->writeI32((*_iter208));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResetQubitsReq &a, ResetQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

ResetQubitsReq::ResetQubitsReq(const ResetQubitsReq& other209) {
  id = other209.id;
  qubits = other209.qubits;
}
ResetQubitsReq& ResetQubitsReq::operator=(const ResetQubitsReq& other210) {
  id = other210.id;
  qubits = other210.qubits;
  return *this;
}
void ResetQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResetQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


ResetQubitsResp::~ResetQubitsResp() noexcept {
}


void ResetQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const ResetQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResetQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResetQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResetQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResetQubitsResp &a, ResetQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

ResetQubitsResp::ResetQubitsResp(const ResetQubitsResp& other211) {
  base = other211.base;
}
ResetQubitsResp& ResetQubitsResp::operator=(const ResetQubitsResp& other212) {
  base = other212.base;
  return *this;
}
void ResetQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResetQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


GetStateOfAllQubitsReq::~GetStateOfAllQubitsReq() noexcept {
}


void GetStateOfAllQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetStateOfAllQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetStateOfAllQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetStateOfAllQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetStateOfAllQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetStateOfAllQubitsReq &a, GetStateOfAllQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetStateOfAllQubitsReq::GetStateOfAllQubitsReq(const GetStateOfAllQubitsReq& other213) {
  id = other213.id;
}
GetStateOfAllQubitsReq& GetStateOfAllQubitsReq::operator=(const GetStateOfAllQubitsReq& other214) {
  id = other214.id;
  return *this;
}
void GetStateOfAllQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetStateOfAllQubitsReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetStateOfAllQubitsResp::~GetStateOfAllQubitsResp() noexcept {
}


void GetStateOfAllQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetStateOfAllQubitsResp::__set_state_vector(const std::vector<double> & val) {
  this->state_vector = val;
}
std::ostream& operator<<(std::ostream& out, const GetStateOfAllQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetStateOfAllQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->state_vector.clear();
            uint32_t _size215;
            ::apache::thrift::protocol::TType _etype218;
            xfer += iprot->readListBegin(_etype218, _size215);
            this->state_vector.resize(_size215);
            uint32_t _i219;
            for (_i219 = 0; _i219 < _size215; ++_i219)
            {
              xfer += iprot->readDouble(this->state_vector[_i219]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.state_vector = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetStateOfAllQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetStateOfAllQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state_vector", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->state_vector.size()));
    std::vector<double> ::const_iterator _iter220;
    for (_iter220 = this->state_vector.begin(); _iter220 != this->state_vector.end(); ++_iter220)
    {
      xfer += oprot->writeDouble((*_iter220));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetStateOfAllQubitsResp &a, GetStateOfAllQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.state_vector, b.state_vector);
  swap(a.__isset, b.__isset);
}

GetStateOfAllQubitsResp::GetStateOfAllQubitsResp(const GetStateOfAllQubitsResp& other221) {
  base = other221.base;
  state_vector = other221.state_vector;
  __isset = other221.__isset;
}
GetStateOfAllQubitsResp& GetStateOfAllQubitsResp::operator=(const GetStateOfAllQubitsResp& other222) {
  base = other222.base;
  state_vector = other222.state_vector;
  __isset = other222.__isset;
  return *this;
}
void GetStateOfAllQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetStateOfAllQubitsResp(";
  out << "base=" << to_string(base);
  out << ", " << "state_vector=" << to_string(state_vector);
  out << ")";
}


GetProbabilitiesReq::~GetProbabilitiesReq() noexcept {
}


void GetProbabilitiesReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbabilitiesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbabilitiesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbabilitiesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbabilitiesReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbabilitiesReq &a, GetProbabilitiesReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetProbabilitiesReq::GetProbabilitiesReq(const GetProbabilitiesReq& other223) {
  id = other223.id;
}
GetProbabilitiesReq& GetProbabilitiesReq::operator=(const GetProbabilitiesReq& other224) {
  id = other224.id;
  return *this;
}
void GetProbabilitiesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbabilitiesReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetProbabilitiesResp::~GetProbabilitiesResp() noexcept {
}


void GetProbabilitiesResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbabilitiesResp::__set_probabilities(const std::vector<double> & val) {
  this->probabilities = val;
__isset.probabilities = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbabilitiesResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbabilitiesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->probabilities.clear();
            uint32_t _size225;
            ::apache::thrift::protocol::TType _etype228;
            xfer += iprot->readListBegin(_etype228, _size225);
            this->probabilities.resize(_size225);
            uint32_t _i229;
            for (_i229 = 0; _i229 < _size225; ++_i229)
            {
              xfer += iprot->readDouble(this->probabilities[_i229]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.probabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbabilitiesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbabilitiesResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.probabilities) {
    xfer += oprot->writeFieldBegin("probabilities", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->probabilities.size()));
      std::vector<double> ::const_iterator _iter230;
      for (_iter230 = this->probabilities.begin(); _iter230 != this->probabilities.end(); ++_iter230)
      {
        xfer += oprot->writeDouble((*_iter230));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbabilitiesResp &a, GetProbabilitiesResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.probabilities, b.probabilities);
  swap(a.__isset, b.__isset);
}

GetProbabilitiesResp::GetProbabilitiesResp(const GetProbabilitiesResp& other231) {
  base = other231.base;
  probabilities = other231.probabilities;
  __isset = other231.__isset;
}
GetProbabilitiesResp& GetProbabilitiesResp::operator=(const GetProbabilitiesResp& other232) {
  base = other232.base;
  probabilities = other232.probabilities;
  __isset = other232.__isset;
  return *this;
}
void GetProbabilitiesResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbabilitiesResp(";
  out << "base=" << to_string(base);
  out << ", " << "probabilities="; (__isset.probabilities ? (out << to_string(probabilities)) : (out << "<null>"));
  out << ")";
}


GetTaskInfoReq::~GetTaskInfoReq() noexcept {
}


void GetTaskInfoReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetTaskInfoReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTaskInfoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTaskInfoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTaskInfoReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTaskInfoReq &a, GetTaskInfoReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetTaskInfoReq::GetTaskInfoReq(const GetTaskInfoReq& other233) {
  id = other233.id;
}
GetTaskInfoReq& GetTaskInfoReq::operator=(const GetTaskInfoReq& other234) {
  id = other234.id;
  return *this;
}
void GetTaskInfoReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTaskInfoReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetTaskInfoResp::~GetTaskInfoResp() noexcept {
}


void GetTaskInfoResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetTaskInfoResp::__set_state(const int32_t val) {
  this->state = val;
}
std::ostream& operator<<(std::ostream& out, const GetTaskInfoResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTaskInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->state);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTaskInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTaskInfoResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTaskInfoResp &a, GetTaskInfoResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.state, b.state);
}

GetTaskInfoResp::GetTaskInfoResp(const GetTaskInfoResp& other235) {
  base = other235.base;
  state = other235.state;
}
GetTaskInfoResp& GetTaskInfoResp::operator=(const GetTaskInfoResp& other236) {
  base = other236.base;
  state = other236.state;
  return *this;
}
void GetTaskInfoResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTaskInfoResp(";
  out << "base=" << to_string(base);
  out << ", " << "state=" << to_string(state);
  out << ")";
}


GetRandomCardInfoReq::~GetRandomCardInfoReq() noexcept {
}

std::ostream& operator<<(std::ostream& out, const GetRandomCardInfoReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRandomCardInfoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetRandomCardInfoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRandomCardInfoReq");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRandomCardInfoReq &a, GetRandomCardInfoReq &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

GetRandomCardInfoReq::GetRandomCardInfoReq(const GetRandomCardInfoReq& other237) noexcept {
  (void) other237;
}
GetRandomCardInfoReq& GetRandomCardInfoReq::operator=(const GetRandomCardInfoReq& other238) noexcept {
  (void) other238;
  return *this;
}
void GetRandomCardInfoReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRandomCardInfoReq(";
  out << ")";
}


GetRandomCardInfoResp::~GetRandomCardInfoResp() noexcept {
}


void GetRandomCardInfoResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetRandomCardInfoResp::__set_count(const int32_t val) {
  this->count = val;
}

void GetRandomCardInfoResp::__set_driver_version(const int32_t val) {
  this->driver_version = val;
}

void GetRandomCardInfoResp::__set_library_version(const int32_t val) {
  this->library_version = val;
}

void GetRandomCardInfoResp::__set_cards(const std::vector<RandomCardInfo> & val) {
  this->cards = val;
}
std::ostream& operator<<(std::ostream& out, const GetRandomCardInfoResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRandomCardInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;
  bool isset_count = false;
  bool isset_driver_version = false;
  bool isset_library_version = false;
  bool isset_cards = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->driver_version);
          isset_driver_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->library_version);
          isset_library_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cards.clear();
            uint32_t _size239;
            ::apache::thrift::protocol::TType _etype242;
            xfer += iprot->readListBegin(_etype242, _size239);
            this->cards.resize(_size239);
            uint32_t _i243;
            for (_i243 = 0; _i243 < _size239; ++_i243)
            {
              xfer += this->cards[_i243].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_cards = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_driver_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_library_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cards)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRandomCardInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRandomCardInfoResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("driver_version", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->driver_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("library_version", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->library_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cards", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cards.size()));
    std::vector<RandomCardInfo> ::const_iterator _iter244;
    for (_iter244 = this->cards.begin(); _iter244 != this->cards.end(); ++_iter244)
    {
      xfer += (*_iter244).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRandomCardInfoResp &a, GetRandomCardInfoResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.count, b.count);
  swap(a.driver_version, b.driver_version);
  swap(a.library_version, b.library_version);
  swap(a.cards, b.cards);
}

GetRandomCardInfoResp::GetRandomCardInfoResp(const GetRandomCardInfoResp& other245) {
  base = other245.base;
  count = other245.count;
  driver_version = other245.driver_version;
  library_version = other245.library_version;
  cards = other245.cards;
}
GetRandomCardInfoResp& GetRandomCardInfoResp::operator=(const GetRandomCardInfoResp& other246) {
  base = other246.base;
  count = other246.count;
  driver_version = other246.driver_version;
  library_version = other246.library_version;
  cards = other246.cards;
  return *this;
}
void GetRandomCardInfoResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRandomCardInfoResp(";
  out << "base=" << to_string(base);
  out << ", " << "count=" << to_string(count);
  out << ", " << "driver_version=" << to_string(driver_version);
  out << ", " << "library_version=" << to_string(library_version);
  out << ", " << "cards=" << to_string(cards);
  out << ")";
}


RandomCardInfo::~RandomCardInfo() noexcept {
}


void RandomCardInfo::__set_device_index(const int32_t val) {
  this->device_index = val;
}

void RandomCardInfo::__set_mode(const int32_t val) {
  this->mode = val;
}

void RandomCardInfo::__set_ld_temp(const double val) {
  this->ld_temp = val;
}

void RandomCardInfo::__set_bd_temp(const double val) {
  this->bd_temp = val;
}

void RandomCardInfo::__set_states(const std::map<RandomCardStateType::type, int32_t> & val) {
  this->states = val;
}
std::ostream& operator<<(std::ostream& out, const RandomCardInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RandomCardInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_device_index = false;
  bool isset_mode = false;
  bool isset_ld_temp = false;
  bool isset_bd_temp = false;
  bool isset_states = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->device_index);
          isset_device_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mode);
          isset_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ld_temp);
          isset_ld_temp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->bd_temp);
          isset_bd_temp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->states.clear();
            uint32_t _size247;
            ::apache::thrift::protocol::TType _ktype248;
            ::apache::thrift::protocol::TType _vtype249;
            xfer += iprot->readMapBegin(_ktype248, _vtype249, _size247);
            uint32_t _i251;
            for (_i251 = 0; _i251 < _size247; ++_i251)
            {
              RandomCardStateType::type _key252;
              int32_t ecast254;
              xfer += iprot->readI32(ecast254);
              _key252 = static_cast<RandomCardStateType::type>(ecast254);
              int32_t& _val253 = this->states[_key252];
              xfer += iprot->readI32(_val253);
            }
            xfer += iprot->readMapEnd();
          }
          isset_states = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_device_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ld_temp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bd_temp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_states)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RandomCardInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RandomCardInfo");

  xfer += oprot->writeFieldBegin("device_index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->device_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ld_temp", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->ld_temp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bd_temp", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->bd_temp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("states", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->states.size()));
    std::map<RandomCardStateType::type, int32_t> ::const_iterator _iter255;
    for (_iter255 = this->states.begin(); _iter255 != this->states.end(); ++_iter255)
    {
      xfer += oprot->writeI32(static_cast<int32_t>(_iter255->first));
      xfer += oprot->writeI32(_iter255->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RandomCardInfo &a, RandomCardInfo &b) {
  using ::std::swap;
  swap(a.device_index, b.device_index);
  swap(a.mode, b.mode);
  swap(a.ld_temp, b.ld_temp);
  swap(a.bd_temp, b.bd_temp);
  swap(a.states, b.states);
}

RandomCardInfo::RandomCardInfo(const RandomCardInfo& other256) {
  device_index = other256.device_index;
  mode = other256.mode;
  ld_temp = other256.ld_temp;
  bd_temp = other256.bd_temp;
  states = other256.states;
}
RandomCardInfo& RandomCardInfo::operator=(const RandomCardInfo& other257) {
  device_index = other257.device_index;
  mode = other257.mode;
  ld_temp = other257.ld_temp;
  bd_temp = other257.bd_temp;
  states = other257.states;
  return *this;
}
void RandomCardInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RandomCardInfo(";
  out << "device_index=" << to_string(device_index);
  out << ", " << "mode=" << to_string(mode);
  out << ", " << "ld_temp=" << to_string(ld_temp);
  out << ", " << "bd_temp=" << to_string(bd_temp);
  out << ", " << "states=" << to_string(states);
  out << ")";
}


SetRandomCardReq::~SetRandomCardReq() noexcept {
}


void SetRandomCardReq::__set_device_index(const int32_t val) {
  this->device_index = val;
}

void SetRandomCardReq::__set_mode(const int32_t val) {
  this->mode = val;
__isset.mode = true;
}

void SetRandomCardReq::__set_reset(const bool val) {
  this->reset = val;
__isset.reset = true;
}
std::ostream& operator<<(std::ostream& out, const SetRandomCardReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetRandomCardReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_device_index = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->device_index);
          isset_device_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reset);
          this->__isset.reset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_device_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SetRandomCardReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetRandomCardReq");

  xfer += oprot->writeFieldBegin("device_index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->device_index);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.mode) {
    xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->mode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reset) {
    xfer += oprot->writeFieldBegin("reset", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->reset);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetRandomCardReq &a, SetRandomCardReq &b) {
  using ::std::swap;
  swap(a.device_index, b.device_index);
  swap(a.mode, b.mode);
  swap(a.reset, b.reset);
  swap(a.__isset, b.__isset);
}

SetRandomCardReq::SetRandomCardReq(const SetRandomCardReq& other258) noexcept {
  device_index = other258.device_index;
  mode = other258.mode;
  reset = other258.reset;
  __isset = other258.__isset;
}
SetRandomCardReq& SetRandomCardReq::operator=(const SetRandomCardReq& other259) noexcept {
  device_index = other259.device_index;
  mode = other259.mode;
  reset = other259.reset;
  __isset = other259.__isset;
  return *this;
}
void SetRandomCardReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetRandomCardReq(";
  out << "device_index=" << to_string(device_index);
  out << ", " << "mode="; (__isset.mode ? (out << to_string(mode)) : (out << "<null>"));
  out << ", " << "reset="; (__isset.reset ? (out << to_string(reset)) : (out << "<null>"));
  out << ")";
}


SetRandomCardResp::~SetRandomCardResp() noexcept {
}


void SetRandomCardResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const SetRandomCardResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetRandomCardResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SetRandomCardResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetRandomCardResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetRandomCardResp &a, SetRandomCardResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

SetRandomCardResp::SetRandomCardResp(const SetRandomCardResp& other260) {
  base = other260.base;
}
SetRandomCardResp& SetRandomCardResp::operator=(const SetRandomCardResp& other261) {
  base = other261.base;
  return *this;
}
void SetRandomCardResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetRandomCardResp(";
  out << "base=" << to_string(base);
  out << ")";
}


GetRandomReq::~GetRandomReq() noexcept {
}


void GetRandomReq::__set_random_length(const int32_t val) {
  this->random_length = val;
}

void GetRandomReq::__set_random_num(const int32_t val) {
  this->random_num = val;
}

void GetRandomReq::__set_device_index(const int32_t val) {
  this->device_index = val;
__isset.device_index = true;
}
std::ostream& operator<<(std::ostream& out, const GetRandomReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRandomReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_random_length = false;
  bool isset_random_num = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->random_length);
          isset_random_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->random_num);
          isset_random_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->device_index);
          this->__isset.device_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_random_length)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_random_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRandomReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRandomReq");

  xfer += oprot->writeFieldBegin("random_length", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->random_length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("random_num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->random_num);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.device_index) {
    xfer += oprot->writeFieldBegin("device_index", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->device_index);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRandomReq &a, GetRandomReq &b) {
  using ::std::swap;
  swap(a.random_length, b.random_length);
  swap(a.random_num, b.random_num);
  swap(a.device_index, b.device_index);
  swap(a.__isset, b.__isset);
}

GetRandomReq::GetRandomReq(const GetRandomReq& other262) noexcept {
  random_length = other262.random_length;
  random_num = other262.random_num;
  device_index = other262.device_index;
  __isset = other262.__isset;
}
GetRandomReq& GetRandomReq::operator=(const GetRandomReq& other263) noexcept {
  random_length = other263.random_length;
  random_num = other263.random_num;
  device_index = other263.device_index;
  __isset = other263.__isset;
  return *this;
}
void GetRandomReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRandomReq(";
  out << "random_length=" << to_string(random_length);
  out << ", " << "random_num=" << to_string(random_num);
  out << ", " << "device_index="; (__isset.device_index ? (out << to_string(device_index)) : (out << "<null>"));
  out << ")";
}


GetRandomResp::~GetRandomResp() noexcept {
}


void GetRandomResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetRandomResp::__set_randoms(const std::vector<std::string> & val) {
  this->randoms = val;
}
std::ostream& operator<<(std::ostream& out, const GetRandomResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRandomResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;
  bool isset_randoms = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->randoms.clear();
            uint32_t _size264;
            ::apache::thrift::protocol::TType _etype267;
            xfer += iprot->readListBegin(_etype267, _size264);
            this->randoms.resize(_size264);
            uint32_t _i268;
            for (_i268 = 0; _i268 < _size264; ++_i268)
            {
              xfer += iprot->readBinary(this->randoms[_i268]);
            }
            xfer += iprot->readListEnd();
          }
          isset_randoms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_randoms)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRandomResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRandomResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("randoms", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->randoms.size()));
    std::vector<std::string> ::const_iterator _iter269;
    for (_iter269 = this->randoms.begin(); _iter269 != this->randoms.end(); ++_iter269)
    {
      xfer += oprot->writeBinary((*_iter269));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRandomResp &a, GetRandomResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.randoms, b.randoms);
}

GetRandomResp::GetRandomResp(const GetRandomResp& other270) {
  base = other270.base;
  randoms = other270.randoms;
}
GetRandomResp& GetRandomResp::operator=(const GetRandomResp& other271) {
  base = other271.base;
  randoms = other271.randoms;
  return *this;
}
void GetRandomResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRandomResp(";
  out << "base=" << to_string(base);
  out << ", " << "randoms=" << to_string(randoms);
  out << ")";
}


