/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "qusproutdata_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kExecCmdTypeValues[] = {
  ExecCmdType::ExecTypeDefault,
  ExecCmdType::ExecTypeCpuSingle,
  ExecCmdType::ExecTypeCpuMpi,
  ExecCmdType::ExecTypeGpuSingle
};
const char* _kExecCmdTypeNames[] = {
  "ExecTypeDefault",
  "ExecTypeCpuSingle",
  "ExecTypeCpuMpi",
  "ExecTypeGpuSingle"
};
const std::map<int, const char*> _ExecCmdType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kExecCmdTypeValues, _kExecCmdTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ExecCmdType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExecCmdType_VALUES_TO_NAMES.find(val);
  if (it != _ExecCmdType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ExecCmdType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExecCmdType_VALUES_TO_NAMES.find(val);
  if (it != _ExecCmdType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPauliOperTypeValues[] = {
  PauliOperType::POT_PAULI_I,
  PauliOperType::POT_PAULI_X,
  PauliOperType::POT_PAULI_Y,
  PauliOperType::POT_PAULI_Z
};
const char* _kPauliOperTypeNames[] = {
  "POT_PAULI_I",
  "POT_PAULI_X",
  "POT_PAULI_Y",
  "POT_PAULI_Z"
};
const std::map<int, const char*> _PauliOperType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kPauliOperTypeValues, _kPauliOperTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PauliOperType::type& val) {
  std::map<int, const char*>::const_iterator it = _PauliOperType_VALUES_TO_NAMES.find(val);
  if (it != _PauliOperType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PauliOperType::type& val) {
  std::map<int, const char*>::const_iterator it = _PauliOperType_VALUES_TO_NAMES.find(val);
  if (it != _PauliOperType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Cmd::~Cmd() noexcept {
}


void Cmd::__set_gate(const std::string& val) {
  this->gate = val;
}

void Cmd::__set_targets(const std::vector<int32_t> & val) {
  this->targets = val;
}

void Cmd::__set_controls(const std::vector<int32_t> & val) {
  this->controls = val;
}

void Cmd::__set_rotation(const std::vector<double> & val) {
  this->rotation = val;
}

void Cmd::__set_desc(const std::string& val) {
  this->desc = val;
}

void Cmd::__set_inverse(const bool val) {
  this->inverse = val;
}
std::ostream& operator<<(std::ostream& out, const Cmd& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cmd::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_gate = false;
  bool isset_targets = false;
  bool isset_controls = false;
  bool isset_rotation = false;
  bool isset_desc = false;
  bool isset_inverse = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gate);
          isset_gate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->targets.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI32(this->targets[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->controls.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->controls.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readI32(this->controls[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          isset_controls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rotation.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->rotation.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readDouble(this->rotation[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          isset_rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->desc);
          isset_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inverse);
          isset_inverse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_gate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_controls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rotation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_desc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inverse)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Cmd::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cmd");

  xfer += oprot->writeFieldBegin("gate", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->gate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targets.size()));
    std::vector<int32_t> ::const_iterator _iter15;
    for (_iter15 = this->targets.begin(); _iter15 != this->targets.end(); ++_iter15)
    {
      xfer += oprot->writeI32((*_iter15));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("controls", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->controls.size()));
    std::vector<int32_t> ::const_iterator _iter16;
    for (_iter16 = this->controls.begin(); _iter16 != this->controls.end(); ++_iter16)
    {
      xfer += oprot->writeI32((*_iter16));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotation", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->rotation.size()));
    std::vector<double> ::const_iterator _iter17;
    for (_iter17 = this->rotation.begin(); _iter17 != this->rotation.end(); ++_iter17)
    {
      xfer += oprot->writeDouble((*_iter17));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("desc", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->desc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inverse", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->inverse);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cmd &a, Cmd &b) {
  using ::std::swap;
  swap(a.gate, b.gate);
  swap(a.targets, b.targets);
  swap(a.controls, b.controls);
  swap(a.rotation, b.rotation);
  swap(a.desc, b.desc);
  swap(a.inverse, b.inverse);
}

Cmd::Cmd(const Cmd& other18) {
  gate = other18.gate;
  targets = other18.targets;
  controls = other18.controls;
  rotation = other18.rotation;
  desc = other18.desc;
  inverse = other18.inverse;
}
Cmd& Cmd::operator=(const Cmd& other19) {
  gate = other19.gate;
  targets = other19.targets;
  controls = other19.controls;
  rotation = other19.rotation;
  desc = other19.desc;
  inverse = other19.inverse;
  return *this;
}
void Cmd::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cmd(";
  out << "gate=" << to_string(gate);
  out << ", " << "targets=" << to_string(targets);
  out << ", " << "controls=" << to_string(controls);
  out << ", " << "rotation=" << to_string(rotation);
  out << ", " << "desc=" << to_string(desc);
  out << ", " << "inverse=" << to_string(inverse);
  out << ")";
}


Circuit::~Circuit() noexcept {
}


void Circuit::__set_cmds(const std::vector<Cmd> & val) {
  this->cmds = val;
}
std::ostream& operator<<(std::ostream& out, const Circuit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Circuit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cmds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cmds.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->cmds.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->cmds[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_cmds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cmds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Circuit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Circuit");

  xfer += oprot->writeFieldBegin("cmds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cmds.size()));
    std::vector<Cmd> ::const_iterator _iter25;
    for (_iter25 = this->cmds.begin(); _iter25 != this->cmds.end(); ++_iter25)
    {
      xfer += (*_iter25).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Circuit &a, Circuit &b) {
  using ::std::swap;
  swap(a.cmds, b.cmds);
}

Circuit::Circuit(const Circuit& other26) {
  cmds = other26.cmds;
}
Circuit& Circuit::operator=(const Circuit& other27) {
  cmds = other27.cmds;
  return *this;
}
void Circuit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Circuit(";
  out << "cmds=" << to_string(cmds);
  out << ")";
}


MeasureResult::~MeasureResult() noexcept {
}


void MeasureResult::__set_id(const int32_t val) {
  this->id = val;
}

void MeasureResult::__set_value(const int32_t val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureResult");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureResult &a, MeasureResult &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.value, b.value);
}

MeasureResult::MeasureResult(const MeasureResult& other28) noexcept {
  id = other28.id;
  value = other28.value;
}
MeasureResult& MeasureResult::operator=(const MeasureResult& other29) noexcept {
  id = other29.id;
  value = other29.value;
  return *this;
}
void MeasureResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureResult(";
  out << "id=" << to_string(id);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


Outcome::~Outcome() noexcept {
}


void Outcome::__set_bitstr(const std::string& val) {
  this->bitstr = val;
}

void Outcome::__set_count(const int32_t val) {
  this->count = val;
}
std::ostream& operator<<(std::ostream& out, const Outcome& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Outcome::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_bitstr = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bitstr);
          isset_bitstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_bitstr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Outcome::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Outcome");

  xfer += oprot->writeFieldBegin("bitstr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bitstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Outcome &a, Outcome &b) {
  using ::std::swap;
  swap(a.bitstr, b.bitstr);
  swap(a.count, b.count);
}

Outcome::Outcome(const Outcome& other30) {
  bitstr = other30.bitstr;
  count = other30.count;
}
Outcome& Outcome::operator=(const Outcome& other31) {
  bitstr = other31.bitstr;
  count = other31.count;
  return *this;
}
void Outcome::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Outcome(";
  out << "bitstr=" << to_string(bitstr);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


Result::~Result() noexcept {
}


void Result::__set_measureSet(const std::vector<MeasureResult> & val) {
  this->measureSet = val;
}

void Result::__set_outcomeSet(const std::vector<Outcome> & val) {
  this->outcomeSet = val;
}
std::ostream& operator<<(std::ostream& out, const Result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_measureSet = false;
  bool isset_outcomeSet = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measureSet.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->measureSet.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->measureSet[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_measureSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outcomeSet.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->outcomeSet.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->outcomeSet[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_outcomeSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_measureSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_outcomeSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("measureSet", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->measureSet.size()));
    std::vector<MeasureResult> ::const_iterator _iter42;
    for (_iter42 = this->measureSet.begin(); _iter42 != this->measureSet.end(); ++_iter42)
    {
      xfer += (*_iter42).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outcomeSet", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outcomeSet.size()));
    std::vector<Outcome> ::const_iterator _iter43;
    for (_iter43 = this->outcomeSet.begin(); _iter43 != this->outcomeSet.end(); ++_iter43)
    {
      xfer += (*_iter43).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.measureSet, b.measureSet);
  swap(a.outcomeSet, b.outcomeSet);
}

Result::Result(const Result& other44) {
  measureSet = other44.measureSet;
  outcomeSet = other44.outcomeSet;
}
Result& Result::operator=(const Result& other45) {
  measureSet = other45.measureSet;
  outcomeSet = other45.outcomeSet;
  return *this;
}
void Result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Result(";
  out << "measureSet=" << to_string(measureSet);
  out << ", " << "outcomeSet=" << to_string(outcomeSet);
  out << ")";
}


InitQubitsReq::~InitQubitsReq() noexcept {
}


void InitQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void InitQubitsReq::__set_qubits(const int32_t val) {
  this->qubits = val;
}

void InitQubitsReq::__set_density(const bool val) {
  this->density = val;
__isset.density = true;
}

void InitQubitsReq::__set_exec_type(const ExecCmdType::type val) {
  this->exec_type = val;
__isset.exec_type = true;
}

void InitQubitsReq::__set_hosts(const std::vector<std::string> & val) {
  this->hosts = val;
__isset.hosts = true;
}
std::ostream& operator<<(std::ostream& out, const InitQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->density);
          this->__isset.density = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast46;
          xfer += iprot->readI32(ecast46);
          this->exec_type = static_cast<ExecCmdType::type>(ecast46);
          this->__isset.exec_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hosts.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->hosts.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readString(this->hosts[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InitQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.density) {
    xfer += oprot->writeFieldBegin("density", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->density);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exec_type) {
    xfer += oprot->writeFieldBegin("exec_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->exec_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hosts) {
    xfer += oprot->writeFieldBegin("hosts", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hosts.size()));
      std::vector<std::string> ::const_iterator _iter52;
      for (_iter52 = this->hosts.begin(); _iter52 != this->hosts.end(); ++_iter52)
      {
        xfer += oprot->writeString((*_iter52));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitQubitsReq &a, InitQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
  swap(a.density, b.density);
  swap(a.exec_type, b.exec_type);
  swap(a.hosts, b.hosts);
  swap(a.__isset, b.__isset);
}

InitQubitsReq::InitQubitsReq(const InitQubitsReq& other53) {
  id = other53.id;
  qubits = other53.qubits;
  density = other53.density;
  exec_type = other53.exec_type;
  hosts = other53.hosts;
  __isset = other53.__isset;
}
InitQubitsReq& InitQubitsReq::operator=(const InitQubitsReq& other54) {
  id = other54.id;
  qubits = other54.qubits;
  density = other54.density;
  exec_type = other54.exec_type;
  hosts = other54.hosts;
  __isset = other54.__isset;
  return *this;
}
void InitQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ", " << "density="; (__isset.density ? (out << to_string(density)) : (out << "<null>"));
  out << ", " << "exec_type="; (__isset.exec_type ? (out << to_string(exec_type)) : (out << "<null>"));
  out << ", " << "hosts="; (__isset.hosts ? (out << to_string(hosts)) : (out << "<null>"));
  out << ")";
}


InitQubitsResp::~InitQubitsResp() noexcept {
}


void InitQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const InitQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InitQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitQubitsResp &a, InitQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

InitQubitsResp::InitQubitsResp(const InitQubitsResp& other55) {
  base = other55.base;
}
InitQubitsResp& InitQubitsResp::operator=(const InitQubitsResp& other56) {
  base = other56.base;
  return *this;
}
void InitQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


SendCircuitCmdReq::~SendCircuitCmdReq() noexcept {
}


void SendCircuitCmdReq::__set_id(const std::string& val) {
  this->id = val;
}

void SendCircuitCmdReq::__set_circuit(const Circuit& val) {
  this->circuit = val;
__isset.circuit = true;
}

void SendCircuitCmdReq::__set_final(const bool val) {
  this->final = val;
__isset.final = true;
}
std::ostream& operator<<(std::ostream& out, const SendCircuitCmdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SendCircuitCmdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->circuit.read(iprot);
          this->__isset.circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->final);
          this->__isset.final = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SendCircuitCmdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SendCircuitCmdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.circuit) {
    xfer += oprot->writeFieldBegin("circuit", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->circuit.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.final) {
    xfer += oprot->writeFieldBegin("final", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->final);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SendCircuitCmdReq &a, SendCircuitCmdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.circuit, b.circuit);
  swap(a.final, b.final);
  swap(a.__isset, b.__isset);
}

SendCircuitCmdReq::SendCircuitCmdReq(const SendCircuitCmdReq& other57) {
  id = other57.id;
  circuit = other57.circuit;
  final = other57.final;
  __isset = other57.__isset;
}
SendCircuitCmdReq& SendCircuitCmdReq::operator=(const SendCircuitCmdReq& other58) {
  id = other58.id;
  circuit = other58.circuit;
  final = other58.final;
  __isset = other58.__isset;
  return *this;
}
void SendCircuitCmdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SendCircuitCmdReq(";
  out << "id=" << to_string(id);
  out << ", " << "circuit="; (__isset.circuit ? (out << to_string(circuit)) : (out << "<null>"));
  out << ", " << "final="; (__isset.final ? (out << to_string(final)) : (out << "<null>"));
  out << ")";
}


SendCircuitCmdResp::~SendCircuitCmdResp() noexcept {
}


void SendCircuitCmdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const SendCircuitCmdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SendCircuitCmdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SendCircuitCmdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SendCircuitCmdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SendCircuitCmdResp &a, SendCircuitCmdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

SendCircuitCmdResp::SendCircuitCmdResp(const SendCircuitCmdResp& other59) {
  base = other59.base;
}
SendCircuitCmdResp& SendCircuitCmdResp::operator=(const SendCircuitCmdResp& other60) {
  base = other60.base;
  return *this;
}
void SendCircuitCmdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SendCircuitCmdResp(";
  out << "base=" << to_string(base);
  out << ")";
}


CancelCmdReq::~CancelCmdReq() noexcept {
}


void CancelCmdReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const CancelCmdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CancelCmdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CancelCmdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CancelCmdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CancelCmdReq &a, CancelCmdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

CancelCmdReq::CancelCmdReq(const CancelCmdReq& other61) {
  id = other61.id;
}
CancelCmdReq& CancelCmdReq::operator=(const CancelCmdReq& other62) {
  id = other62.id;
  return *this;
}
void CancelCmdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CancelCmdReq(";
  out << "id=" << to_string(id);
  out << ")";
}


CancelCmdResp::~CancelCmdResp() noexcept {
}


void CancelCmdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const CancelCmdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CancelCmdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CancelCmdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CancelCmdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CancelCmdResp &a, CancelCmdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

CancelCmdResp::CancelCmdResp(const CancelCmdResp& other63) {
  base = other63.base;
}
CancelCmdResp& CancelCmdResp::operator=(const CancelCmdResp& other64) {
  base = other64.base;
  return *this;
}
void CancelCmdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CancelCmdResp(";
  out << "base=" << to_string(base);
  out << ")";
}


GetProbAmpReq::~GetProbAmpReq() noexcept {
}


void GetProbAmpReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetProbAmpReq::__set_index(const int64_t val) {
  this->index = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbAmpReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbAmpReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_index = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->index);
          isset_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbAmpReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbAmpReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbAmpReq &a, GetProbAmpReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.index, b.index);
}

GetProbAmpReq::GetProbAmpReq(const GetProbAmpReq& other65) {
  id = other65.id;
  index = other65.index;
}
GetProbAmpReq& GetProbAmpReq::operator=(const GetProbAmpReq& other66) {
  id = other66.id;
  index = other66.index;
  return *this;
}
void GetProbAmpReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbAmpReq(";
  out << "id=" << to_string(id);
  out << ", " << "index=" << to_string(index);
  out << ")";
}


GetProbAmpResp::~GetProbAmpResp() noexcept {
}


void GetProbAmpResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbAmpResp::__set_amp(const double val) {
  this->amp = val;
__isset.amp = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbAmpResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbAmpResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->amp);
          this->__isset.amp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbAmpResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbAmpResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.amp) {
    xfer += oprot->writeFieldBegin("amp", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->amp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbAmpResp &a, GetProbAmpResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.amp, b.amp);
  swap(a.__isset, b.__isset);
}

GetProbAmpResp::GetProbAmpResp(const GetProbAmpResp& other67) {
  base = other67.base;
  amp = other67.amp;
  __isset = other67.__isset;
}
GetProbAmpResp& GetProbAmpResp::operator=(const GetProbAmpResp& other68) {
  base = other68.base;
  amp = other68.amp;
  __isset = other68.__isset;
  return *this;
}
void GetProbAmpResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbAmpResp(";
  out << "base=" << to_string(base);
  out << ", " << "amp="; (__isset.amp ? (out << to_string(amp)) : (out << "<null>"));
  out << ")";
}


GetProbOfOutcomeReq::~GetProbOfOutcomeReq() noexcept {
}


void GetProbOfOutcomeReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetProbOfOutcomeReq::__set_qubit(const int32_t val) {
  this->qubit = val;
}

void GetProbOfOutcomeReq::__set_outcom(const int32_t val) {
  this->outcom = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfOutcomeReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfOutcomeReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubit = false;
  bool isset_outcom = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubit);
          isset_qubit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->outcom);
          isset_outcom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_outcom)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfOutcomeReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfOutcomeReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubit", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outcom", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->outcom);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfOutcomeReq &a, GetProbOfOutcomeReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubit, b.qubit);
  swap(a.outcom, b.outcom);
}

GetProbOfOutcomeReq::GetProbOfOutcomeReq(const GetProbOfOutcomeReq& other69) {
  id = other69.id;
  qubit = other69.qubit;
  outcom = other69.outcom;
}
GetProbOfOutcomeReq& GetProbOfOutcomeReq::operator=(const GetProbOfOutcomeReq& other70) {
  id = other70.id;
  qubit = other70.qubit;
  outcom = other70.outcom;
  return *this;
}
void GetProbOfOutcomeReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfOutcomeReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubit=" << to_string(qubit);
  out << ", " << "outcom=" << to_string(outcom);
  out << ")";
}


GetProbOfOutcomeResp::~GetProbOfOutcomeResp() noexcept {
}


void GetProbOfOutcomeResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbOfOutcomeResp::__set_pro_outcome(const double val) {
  this->pro_outcome = val;
__isset.pro_outcome = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfOutcomeResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfOutcomeResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pro_outcome);
          this->__isset.pro_outcome = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfOutcomeResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfOutcomeResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pro_outcome) {
    xfer += oprot->writeFieldBegin("pro_outcome", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->pro_outcome);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfOutcomeResp &a, GetProbOfOutcomeResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.pro_outcome, b.pro_outcome);
  swap(a.__isset, b.__isset);
}

GetProbOfOutcomeResp::GetProbOfOutcomeResp(const GetProbOfOutcomeResp& other71) {
  base = other71.base;
  pro_outcome = other71.pro_outcome;
  __isset = other71.__isset;
}
GetProbOfOutcomeResp& GetProbOfOutcomeResp::operator=(const GetProbOfOutcomeResp& other72) {
  base = other72.base;
  pro_outcome = other72.pro_outcome;
  __isset = other72.__isset;
  return *this;
}
void GetProbOfOutcomeResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfOutcomeResp(";
  out << "base=" << to_string(base);
  out << ", " << "pro_outcome="; (__isset.pro_outcome ? (out << to_string(pro_outcome)) : (out << "<null>"));
  out << ")";
}


GetProbOfAllOutcomReq::~GetProbOfAllOutcomReq() noexcept {
}


void GetProbOfAllOutcomReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetProbOfAllOutcomReq::__set_targets(const std::vector<int32_t> & val) {
  this->targets = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfAllOutcomReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfAllOutcomReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_targets = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->targets.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += iprot->readI32(this->targets[_i77]);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfAllOutcomReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfAllOutcomReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targets.size()));
    std::vector<int32_t> ::const_iterator _iter78;
    for (_iter78 = this->targets.begin(); _iter78 != this->targets.end(); ++_iter78)
    {
      xfer += oprot->writeI32((*_iter78));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfAllOutcomReq &a, GetProbOfAllOutcomReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.targets, b.targets);
}

GetProbOfAllOutcomReq::GetProbOfAllOutcomReq(const GetProbOfAllOutcomReq& other79) {
  id = other79.id;
  targets = other79.targets;
}
GetProbOfAllOutcomReq& GetProbOfAllOutcomReq::operator=(const GetProbOfAllOutcomReq& other80) {
  id = other80.id;
  targets = other80.targets;
  return *this;
}
void GetProbOfAllOutcomReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfAllOutcomReq(";
  out << "id=" << to_string(id);
  out << ", " << "targets=" << to_string(targets);
  out << ")";
}


GetProbOfAllOutcomResp::~GetProbOfAllOutcomResp() noexcept {
}


void GetProbOfAllOutcomResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbOfAllOutcomResp::__set_pro_outcomes(const std::vector<double> & val) {
  this->pro_outcomes = val;
__isset.pro_outcomes = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfAllOutcomResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfAllOutcomResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pro_outcomes.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _etype84;
            xfer += iprot->readListBegin(_etype84, _size81);
            this->pro_outcomes.resize(_size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
              xfer += iprot->readDouble(this->pro_outcomes[_i85]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pro_outcomes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfAllOutcomResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfAllOutcomResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pro_outcomes) {
    xfer += oprot->writeFieldBegin("pro_outcomes", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->pro_outcomes.size()));
      std::vector<double> ::const_iterator _iter86;
      for (_iter86 = this->pro_outcomes.begin(); _iter86 != this->pro_outcomes.end(); ++_iter86)
      {
        xfer += oprot->writeDouble((*_iter86));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfAllOutcomResp &a, GetProbOfAllOutcomResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.pro_outcomes, b.pro_outcomes);
  swap(a.__isset, b.__isset);
}

GetProbOfAllOutcomResp::GetProbOfAllOutcomResp(const GetProbOfAllOutcomResp& other87) {
  base = other87.base;
  pro_outcomes = other87.pro_outcomes;
  __isset = other87.__isset;
}
GetProbOfAllOutcomResp& GetProbOfAllOutcomResp::operator=(const GetProbOfAllOutcomResp& other88) {
  base = other88.base;
  pro_outcomes = other88.pro_outcomes;
  __isset = other88.__isset;
  return *this;
}
void GetProbOfAllOutcomResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfAllOutcomResp(";
  out << "base=" << to_string(base);
  out << ", " << "pro_outcomes="; (__isset.pro_outcomes ? (out << to_string(pro_outcomes)) : (out << "<null>"));
  out << ")";
}


GetAllStateReq::~GetAllStateReq() noexcept {
}


void GetAllStateReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetAllStateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllStateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetAllStateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllStateReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllStateReq &a, GetAllStateReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetAllStateReq::GetAllStateReq(const GetAllStateReq& other89) {
  id = other89.id;
}
GetAllStateReq& GetAllStateReq::operator=(const GetAllStateReq& other90) {
  id = other90.id;
  return *this;
}
void GetAllStateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllStateReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetAllStateResp::~GetAllStateResp() noexcept {
}


void GetAllStateResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetAllStateResp::__set_all_state(const std::vector<std::string> & val) {
  this->all_state = val;
__isset.all_state = true;
}
std::ostream& operator<<(std::ostream& out, const GetAllStateResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllStateResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->all_state.clear();
            uint32_t _size91;
            ::apache::thrift::protocol::TType _etype94;
            xfer += iprot->readListBegin(_etype94, _size91);
            this->all_state.resize(_size91);
            uint32_t _i95;
            for (_i95 = 0; _i95 < _size91; ++_i95)
            {
              xfer += iprot->readString(this->all_state[_i95]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.all_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetAllStateResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllStateResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.all_state) {
    xfer += oprot->writeFieldBegin("all_state", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->all_state.size()));
      std::vector<std::string> ::const_iterator _iter96;
      for (_iter96 = this->all_state.begin(); _iter96 != this->all_state.end(); ++_iter96)
      {
        xfer += oprot->writeString((*_iter96));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllStateResp &a, GetAllStateResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.all_state, b.all_state);
  swap(a.__isset, b.__isset);
}

GetAllStateResp::GetAllStateResp(const GetAllStateResp& other97) {
  base = other97.base;
  all_state = other97.all_state;
  __isset = other97.__isset;
}
GetAllStateResp& GetAllStateResp::operator=(const GetAllStateResp& other98) {
  base = other98.base;
  all_state = other98.all_state;
  __isset = other98.__isset;
  return *this;
}
void GetAllStateResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllStateResp(";
  out << "base=" << to_string(base);
  out << ", " << "all_state="; (__isset.all_state ? (out << to_string(all_state)) : (out << "<null>"));
  out << ")";
}


ApplyQFTReq::~ApplyQFTReq() noexcept {
}


void ApplyQFTReq::__set_id(const std::string& val) {
  this->id = val;
}

void ApplyQFTReq::__set_targets(const std::vector<int32_t> & val) {
  this->targets = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyQFTReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyQFTReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_targets = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readListBegin(_etype102, _size99);
            this->targets.resize(_size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              xfer += iprot->readI32(this->targets[_i103]);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyQFTReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyQFTReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targets.size()));
    std::vector<int32_t> ::const_iterator _iter104;
    for (_iter104 = this->targets.begin(); _iter104 != this->targets.end(); ++_iter104)
    {
      xfer += oprot->writeI32((*_iter104));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyQFTReq &a, ApplyQFTReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.targets, b.targets);
}

ApplyQFTReq::ApplyQFTReq(const ApplyQFTReq& other105) {
  id = other105.id;
  targets = other105.targets;
}
ApplyQFTReq& ApplyQFTReq::operator=(const ApplyQFTReq& other106) {
  id = other106.id;
  targets = other106.targets;
  return *this;
}
void ApplyQFTReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyQFTReq(";
  out << "id=" << to_string(id);
  out << ", " << "targets=" << to_string(targets);
  out << ")";
}


ApplyQFTResp::~ApplyQFTResp() noexcept {
}


void ApplyQFTResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyQFTResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyQFTResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyQFTResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyQFTResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyQFTResp &a, ApplyQFTResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

ApplyQFTResp::ApplyQFTResp(const ApplyQFTResp& other107) {
  base = other107.base;
}
ApplyQFTResp& ApplyQFTResp::operator=(const ApplyQFTResp& other108) {
  base = other108.base;
  return *this;
}
void ApplyQFTResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyQFTResp(";
  out << "base=" << to_string(base);
  out << ")";
}


ApplyFullQFTReq::~ApplyFullQFTReq() noexcept {
}


void ApplyFullQFTReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyFullQFTReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyFullQFTReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyFullQFTReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyFullQFTReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyFullQFTReq &a, ApplyFullQFTReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

ApplyFullQFTReq::ApplyFullQFTReq(const ApplyFullQFTReq& other109) {
  id = other109.id;
}
ApplyFullQFTReq& ApplyFullQFTReq::operator=(const ApplyFullQFTReq& other110) {
  id = other110.id;
  return *this;
}
void ApplyFullQFTReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyFullQFTReq(";
  out << "id=" << to_string(id);
  out << ")";
}


ApplyFullQFTResp::~ApplyFullQFTResp() noexcept {
}


void ApplyFullQFTResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyFullQFTResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyFullQFTResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyFullQFTResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyFullQFTResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyFullQFTResp &a, ApplyFullQFTResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

ApplyFullQFTResp::ApplyFullQFTResp(const ApplyFullQFTResp& other111) {
  base = other111.base;
}
ApplyFullQFTResp& ApplyFullQFTResp::operator=(const ApplyFullQFTResp& other112) {
  base = other112.base;
  return *this;
}
void ApplyFullQFTResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyFullQFTResp(";
  out << "base=" << to_string(base);
  out << ")";
}


RunCircuitReq::~RunCircuitReq() noexcept {
}


void RunCircuitReq::__set_id(const std::string& val) {
  this->id = val;
}

void RunCircuitReq::__set_shots(const int32_t val) {
  this->shots = val;
}
std::ostream& operator<<(std::ostream& out, const RunCircuitReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RunCircuitReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_shots = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shots);
          isset_shots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_shots)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RunCircuitReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RunCircuitReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shots", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->shots);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RunCircuitReq &a, RunCircuitReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.shots, b.shots);
}

RunCircuitReq::RunCircuitReq(const RunCircuitReq& other113) {
  id = other113.id;
  shots = other113.shots;
}
RunCircuitReq& RunCircuitReq::operator=(const RunCircuitReq& other114) {
  id = other114.id;
  shots = other114.shots;
  return *this;
}
void RunCircuitReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RunCircuitReq(";
  out << "id=" << to_string(id);
  out << ", " << "shots=" << to_string(shots);
  out << ")";
}


RunCircuitResp::~RunCircuitResp() noexcept {
}


void RunCircuitResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void RunCircuitResp::__set_result(const Result& val) {
  this->result = val;
__isset.result = true;
}
std::ostream& operator<<(std::ostream& out, const RunCircuitResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RunCircuitResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RunCircuitResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RunCircuitResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.result) {
    xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->result.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RunCircuitResp &a, RunCircuitResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

RunCircuitResp::RunCircuitResp(const RunCircuitResp& other115) {
  base = other115.base;
  result = other115.result;
  __isset = other115.__isset;
}
RunCircuitResp& RunCircuitResp::operator=(const RunCircuitResp& other116) {
  base = other116.base;
  result = other116.result;
  __isset = other116.__isset;
  return *this;
}
void RunCircuitResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RunCircuitResp(";
  out << "base=" << to_string(base);
  out << ", " << "result="; (__isset.result ? (out << to_string(result)) : (out << "<null>"));
  out << ")";
}


GetExpecPauliProdReq::~GetExpecPauliProdReq() noexcept {
}


void GetExpecPauliProdReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetExpecPauliProdReq::__set_pauli_prod(const std::vector<PauliProdInfo> & val) {
  this->pauli_prod = val;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliProdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliProdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_pauli_prod = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pauli_prod.clear();
            uint32_t _size117;
            ::apache::thrift::protocol::TType _etype120;
            xfer += iprot->readListBegin(_etype120, _size117);
            this->pauli_prod.resize(_size117);
            uint32_t _i121;
            for (_i121 = 0; _i121 < _size117; ++_i121)
            {
              xfer += this->pauli_prod[_i121].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_pauli_prod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pauli_prod)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliProdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliProdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pauli_prod", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pauli_prod.size()));
    std::vector<PauliProdInfo> ::const_iterator _iter122;
    for (_iter122 = this->pauli_prod.begin(); _iter122 != this->pauli_prod.end(); ++_iter122)
    {
      xfer += (*_iter122).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliProdReq &a, GetExpecPauliProdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.pauli_prod, b.pauli_prod);
}

GetExpecPauliProdReq::GetExpecPauliProdReq(const GetExpecPauliProdReq& other123) {
  id = other123.id;
  pauli_prod = other123.pauli_prod;
}
GetExpecPauliProdReq& GetExpecPauliProdReq::operator=(const GetExpecPauliProdReq& other124) {
  id = other124.id;
  pauli_prod = other124.pauli_prod;
  return *this;
}
void GetExpecPauliProdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliProdReq(";
  out << "id=" << to_string(id);
  out << ", " << "pauli_prod=" << to_string(pauli_prod);
  out << ")";
}


GetExpecPauliProdResp::~GetExpecPauliProdResp() noexcept {
}


void GetExpecPauliProdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetExpecPauliProdResp::__set_expect(const double val) {
  this->expect = val;
__isset.expect = true;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliProdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliProdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->expect);
          this->__isset.expect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliProdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliProdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.expect) {
    xfer += oprot->writeFieldBegin("expect", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->expect);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliProdResp &a, GetExpecPauliProdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.expect, b.expect);
  swap(a.__isset, b.__isset);
}

GetExpecPauliProdResp::GetExpecPauliProdResp(const GetExpecPauliProdResp& other125) {
  base = other125.base;
  expect = other125.expect;
  __isset = other125.__isset;
}
GetExpecPauliProdResp& GetExpecPauliProdResp::operator=(const GetExpecPauliProdResp& other126) {
  base = other126.base;
  expect = other126.expect;
  __isset = other126.__isset;
  return *this;
}
void GetExpecPauliProdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliProdResp(";
  out << "base=" << to_string(base);
  out << ", " << "expect="; (__isset.expect ? (out << to_string(expect)) : (out << "<null>"));
  out << ")";
}


PauliProdInfo::~PauliProdInfo() noexcept {
}


void PauliProdInfo::__set_oper_type(const PauliOperType::type val) {
  this->oper_type = val;
}

void PauliProdInfo::__set_target(const int32_t val) {
  this->target = val;
}
std::ostream& operator<<(std::ostream& out, const PauliProdInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PauliProdInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_oper_type = false;
  bool isset_target = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast127;
          xfer += iprot->readI32(ecast127);
          this->oper_type = static_cast<PauliOperType::type>(ecast127);
          isset_oper_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->target);
          isset_target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_oper_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PauliProdInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PauliProdInfo");

  xfer += oprot->writeFieldBegin("oper_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->oper_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PauliProdInfo &a, PauliProdInfo &b) {
  using ::std::swap;
  swap(a.oper_type, b.oper_type);
  swap(a.target, b.target);
}

PauliProdInfo::PauliProdInfo(const PauliProdInfo& other128) noexcept {
  oper_type = other128.oper_type;
  target = other128.target;
}
PauliProdInfo& PauliProdInfo::operator=(const PauliProdInfo& other129) noexcept {
  oper_type = other129.oper_type;
  target = other129.target;
  return *this;
}
void PauliProdInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PauliProdInfo(";
  out << "oper_type=" << to_string(oper_type);
  out << ", " << "target=" << to_string(target);
  out << ")";
}


GetExpecPauliSumReq::~GetExpecPauliSumReq() noexcept {
}


void GetExpecPauliSumReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetExpecPauliSumReq::__set_oper_type_list(const std::vector<PauliOperType::type> & val) {
  this->oper_type_list = val;
}

void GetExpecPauliSumReq::__set_term_coeff_list(const std::vector<double> & val) {
  this->term_coeff_list = val;
__isset.term_coeff_list = true;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliSumReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliSumReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_oper_type_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->oper_type_list.clear();
            uint32_t _size130;
            ::apache::thrift::protocol::TType _etype133;
            xfer += iprot->readListBegin(_etype133, _size130);
            this->oper_type_list.resize(_size130);
            uint32_t _i134;
            for (_i134 = 0; _i134 < _size130; ++_i134)
            {
              int32_t ecast135;
              xfer += iprot->readI32(ecast135);
              this->oper_type_list[_i134] = static_cast<PauliOperType::type>(ecast135);
            }
            xfer += iprot->readListEnd();
          }
          isset_oper_type_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->term_coeff_list.clear();
            uint32_t _size136;
            ::apache::thrift::protocol::TType _etype139;
            xfer += iprot->readListBegin(_etype139, _size136);
            this->term_coeff_list.resize(_size136);
            uint32_t _i140;
            for (_i140 = 0; _i140 < _size136; ++_i140)
            {
              xfer += iprot->readDouble(this->term_coeff_list[_i140]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.term_coeff_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_oper_type_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliSumReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliSumReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oper_type_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->oper_type_list.size()));
    std::vector<PauliOperType::type> ::const_iterator _iter141;
    for (_iter141 = this->oper_type_list.begin(); _iter141 != this->oper_type_list.end(); ++_iter141)
    {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter141)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.term_coeff_list) {
    xfer += oprot->writeFieldBegin("term_coeff_list", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->term_coeff_list.size()));
      std::vector<double> ::const_iterator _iter142;
      for (_iter142 = this->term_coeff_list.begin(); _iter142 != this->term_coeff_list.end(); ++_iter142)
      {
        xfer += oprot->writeDouble((*_iter142));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliSumReq &a, GetExpecPauliSumReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.oper_type_list, b.oper_type_list);
  swap(a.term_coeff_list, b.term_coeff_list);
  swap(a.__isset, b.__isset);
}

GetExpecPauliSumReq::GetExpecPauliSumReq(const GetExpecPauliSumReq& other143) {
  id = other143.id;
  oper_type_list = other143.oper_type_list;
  term_coeff_list = other143.term_coeff_list;
  __isset = other143.__isset;
}
GetExpecPauliSumReq& GetExpecPauliSumReq::operator=(const GetExpecPauliSumReq& other144) {
  id = other144.id;
  oper_type_list = other144.oper_type_list;
  term_coeff_list = other144.term_coeff_list;
  __isset = other144.__isset;
  return *this;
}
void GetExpecPauliSumReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliSumReq(";
  out << "id=" << to_string(id);
  out << ", " << "oper_type_list=" << to_string(oper_type_list);
  out << ", " << "term_coeff_list="; (__isset.term_coeff_list ? (out << to_string(term_coeff_list)) : (out << "<null>"));
  out << ")";
}


GetExpecPauliSumResp::~GetExpecPauliSumResp() noexcept {
}


void GetExpecPauliSumResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetExpecPauliSumResp::__set_expect(const double val) {
  this->expect = val;
__isset.expect = true;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliSumResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliSumResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->expect);
          this->__isset.expect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliSumResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliSumResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.expect) {
    xfer += oprot->writeFieldBegin("expect", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->expect);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliSumResp &a, GetExpecPauliSumResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.expect, b.expect);
  swap(a.__isset, b.__isset);
}

GetExpecPauliSumResp::GetExpecPauliSumResp(const GetExpecPauliSumResp& other145) {
  base = other145.base;
  expect = other145.expect;
  __isset = other145.__isset;
}
GetExpecPauliSumResp& GetExpecPauliSumResp::operator=(const GetExpecPauliSumResp& other146) {
  base = other146.base;
  expect = other146.expect;
  __isset = other146.__isset;
  return *this;
}
void GetExpecPauliSumResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliSumResp(";
  out << "base=" << to_string(base);
  out << ", " << "expect="; (__isset.expect ? (out << to_string(expect)) : (out << "<null>"));
  out << ")";
}


MeasureQubitsReq::~MeasureQubitsReq() noexcept {
}


void MeasureQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void MeasureQubitsReq::__set_qubits(const std::vector<int32_t> & val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->qubits.clear();
            uint32_t _size147;
            ::apache::thrift::protocol::TType _etype150;
            xfer += iprot->readListBegin(_etype150, _size147);
            this->qubits.resize(_size147);
            uint32_t _i151;
            for (_i151 = 0; _i151 < _size147; ++_i151)
            {
              xfer += iprot->readI32(this->qubits[_i151]);
            }
            xfer += iprot->readListEnd();
          }
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->qubits.size()));
    std::vector<int32_t> ::const_iterator _iter152;
    for (_iter152 = this->qubits.begin(); _iter152 != this->qubits.end(); ++_iter152)
    {
      xfer += oprot->writeI32((*_iter152));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureQubitsReq &a, MeasureQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

MeasureQubitsReq::MeasureQubitsReq(const MeasureQubitsReq& other153) {
  id = other153.id;
  qubits = other153.qubits;
}
MeasureQubitsReq& MeasureQubitsReq::operator=(const MeasureQubitsReq& other154) {
  id = other154.id;
  qubits = other154.qubits;
  return *this;
}
void MeasureQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


MeasureQubitsResp::~MeasureQubitsResp() noexcept {
}


void MeasureQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void MeasureQubitsResp::__set_results(const std::vector<MeasureResult> & val) {
  this->results = val;
__isset.results = true;
}

void MeasureQubitsResp::__set_outcomes(const std::vector<Outcome> & val) {
  this->outcomes = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;
  bool isset_outcomes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size155;
            ::apache::thrift::protocol::TType _etype158;
            xfer += iprot->readListBegin(_etype158, _size155);
            this->results.resize(_size155);
            uint32_t _i159;
            for (_i159 = 0; _i159 < _size155; ++_i159)
            {
              xfer += this->results[_i159].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outcomes.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readListBegin(_etype163, _size160);
            this->outcomes.resize(_size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              xfer += this->outcomes[_i164].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_outcomes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_outcomes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.results) {
    xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
      std::vector<MeasureResult> ::const_iterator _iter165;
      for (_iter165 = this->results.begin(); _iter165 != this->results.end(); ++_iter165)
      {
        xfer += (*_iter165).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("outcomes", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outcomes.size()));
    std::vector<Outcome> ::const_iterator _iter166;
    for (_iter166 = this->outcomes.begin(); _iter166 != this->outcomes.end(); ++_iter166)
    {
      xfer += (*_iter166).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureQubitsResp &a, MeasureQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.results, b.results);
  swap(a.outcomes, b.outcomes);
  swap(a.__isset, b.__isset);
}

MeasureQubitsResp::MeasureQubitsResp(const MeasureQubitsResp& other167) {
  base = other167.base;
  results = other167.results;
  outcomes = other167.outcomes;
  __isset = other167.__isset;
}
MeasureQubitsResp& MeasureQubitsResp::operator=(const MeasureQubitsResp& other168) {
  base = other168.base;
  results = other168.results;
  outcomes = other168.outcomes;
  __isset = other168.__isset;
  return *this;
}
void MeasureQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureQubitsResp(";
  out << "base=" << to_string(base);
  out << ", " << "results="; (__isset.results ? (out << to_string(results)) : (out << "<null>"));
  out << ", " << "outcomes=" << to_string(outcomes);
  out << ")";
}


GateMatrix::~GateMatrix() noexcept {
}


void GateMatrix::__set_name(const std::string& val) {
  this->name = val;
}

void GateMatrix::__set_qubits(const int32_t val) {
  this->qubits = val;
}

void GateMatrix::__set_matrix(const std::vector<double> & val) {
  this->matrix = val;
}
std::ostream& operator<<(std::ostream& out, const GateMatrix& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GateMatrix::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_qubits = false;
  bool isset_matrix = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->matrix.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->matrix.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += iprot->readDouble(this->matrix[_i173]);
            }
            xfer += iprot->readListEnd();
          }
          isset_matrix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_matrix)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GateMatrix::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GateMatrix");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matrix", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->matrix.size()));
    std::vector<double> ::const_iterator _iter174;
    for (_iter174 = this->matrix.begin(); _iter174 != this->matrix.end(); ++_iter174)
    {
      xfer += oprot->writeDouble((*_iter174));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GateMatrix &a, GateMatrix &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.qubits, b.qubits);
  swap(a.matrix, b.matrix);
}

GateMatrix::GateMatrix(const GateMatrix& other175) {
  name = other175.name;
  qubits = other175.qubits;
  matrix = other175.matrix;
}
GateMatrix& GateMatrix::operator=(const GateMatrix& other176) {
  name = other176.name;
  qubits = other176.qubits;
  matrix = other176.matrix;
  return *this;
}
void GateMatrix::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GateMatrix(";
  out << "name=" << to_string(name);
  out << ", " << "qubits=" << to_string(qubits);
  out << ", " << "matrix=" << to_string(matrix);
  out << ")";
}


AddCustomGateByMatrixReq::~AddCustomGateByMatrixReq() noexcept {
}


void AddCustomGateByMatrixReq::__set_id(const std::string& val) {
  this->id = val;
}

void AddCustomGateByMatrixReq::__set_gate(const GateMatrix& val) {
  this->gate = val;
}
std::ostream& operator<<(std::ostream& out, const AddCustomGateByMatrixReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddCustomGateByMatrixReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_gate = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gate.read(iprot);
          isset_gate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddCustomGateByMatrixReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddCustomGateByMatrixReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gate", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->gate.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddCustomGateByMatrixReq &a, AddCustomGateByMatrixReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.gate, b.gate);
}

AddCustomGateByMatrixReq::AddCustomGateByMatrixReq(const AddCustomGateByMatrixReq& other177) {
  id = other177.id;
  gate = other177.gate;
}
AddCustomGateByMatrixReq& AddCustomGateByMatrixReq::operator=(const AddCustomGateByMatrixReq& other178) {
  id = other178.id;
  gate = other178.gate;
  return *this;
}
void AddCustomGateByMatrixReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddCustomGateByMatrixReq(";
  out << "id=" << to_string(id);
  out << ", " << "gate=" << to_string(gate);
  out << ")";
}


AddCustomGateByMatrixResp::~AddCustomGateByMatrixResp() noexcept {
}


void AddCustomGateByMatrixResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AddCustomGateByMatrixResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddCustomGateByMatrixResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddCustomGateByMatrixResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddCustomGateByMatrixResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddCustomGateByMatrixResp &a, AddCustomGateByMatrixResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AddCustomGateByMatrixResp::AddCustomGateByMatrixResp(const AddCustomGateByMatrixResp& other179) {
  base = other179.base;
}
AddCustomGateByMatrixResp& AddCustomGateByMatrixResp::operator=(const AddCustomGateByMatrixResp& other180) {
  base = other180.base;
  return *this;
}
void AddCustomGateByMatrixResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddCustomGateByMatrixResp(";
  out << "base=" << to_string(base);
  out << ")";
}


SubCircuit::~SubCircuit() noexcept {
}


void SubCircuit::__set_name(const std::string& val) {
  this->name = val;
}

void SubCircuit::__set_circuit(const Circuit& val) {
  this->circuit = val;
}
std::ostream& operator<<(std::ostream& out, const SubCircuit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SubCircuit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_circuit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->circuit.read(iprot);
          isset_circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_circuit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SubCircuit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SubCircuit");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("circuit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->circuit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SubCircuit &a, SubCircuit &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.circuit, b.circuit);
}

SubCircuit::SubCircuit(const SubCircuit& other181) {
  name = other181.name;
  circuit = other181.circuit;
}
SubCircuit& SubCircuit::operator=(const SubCircuit& other182) {
  name = other182.name;
  circuit = other182.circuit;
  return *this;
}
void SubCircuit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SubCircuit(";
  out << "name=" << to_string(name);
  out << ", " << "circuit=" << to_string(circuit);
  out << ")";
}


AddSubCircuitReq::~AddSubCircuitReq() noexcept {
}


void AddSubCircuitReq::__set_id(const std::string& val) {
  this->id = val;
}

void AddSubCircuitReq::__set_sub_circuit(const SubCircuit& val) {
  this->sub_circuit = val;
}
std::ostream& operator<<(std::ostream& out, const AddSubCircuitReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddSubCircuitReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_sub_circuit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sub_circuit.read(iprot);
          isset_sub_circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sub_circuit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddSubCircuitReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddSubCircuitReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sub_circuit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->sub_circuit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddSubCircuitReq &a, AddSubCircuitReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.sub_circuit, b.sub_circuit);
}

AddSubCircuitReq::AddSubCircuitReq(const AddSubCircuitReq& other183) {
  id = other183.id;
  sub_circuit = other183.sub_circuit;
}
AddSubCircuitReq& AddSubCircuitReq::operator=(const AddSubCircuitReq& other184) {
  id = other184.id;
  sub_circuit = other184.sub_circuit;
  return *this;
}
void AddSubCircuitReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddSubCircuitReq(";
  out << "id=" << to_string(id);
  out << ", " << "sub_circuit=" << to_string(sub_circuit);
  out << ")";
}


AddSubCircuitResp::~AddSubCircuitResp() noexcept {
}


void AddSubCircuitResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AddSubCircuitResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddSubCircuitResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddSubCircuitResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddSubCircuitResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddSubCircuitResp &a, AddSubCircuitResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AddSubCircuitResp::AddSubCircuitResp(const AddSubCircuitResp& other185) {
  base = other185.base;
}
AddSubCircuitResp& AddSubCircuitResp::operator=(const AddSubCircuitResp& other186) {
  base = other186.base;
  return *this;
}
void AddSubCircuitResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddSubCircuitResp(";
  out << "base=" << to_string(base);
  out << ")";
}


AppendQubitsReq::~AppendQubitsReq() noexcept {
}


void AppendQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void AppendQubitsReq::__set_qubits(const int32_t val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const AppendQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppendQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppendQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppendQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppendQubitsReq &a, AppendQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

AppendQubitsReq::AppendQubitsReq(const AppendQubitsReq& other187) {
  id = other187.id;
  qubits = other187.qubits;
}
AppendQubitsReq& AppendQubitsReq::operator=(const AppendQubitsReq& other188) {
  id = other188.id;
  qubits = other188.qubits;
  return *this;
}
void AppendQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppendQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


AppendQubitsResp::~AppendQubitsResp() noexcept {
}


void AppendQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AppendQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppendQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppendQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppendQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppendQubitsResp &a, AppendQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AppendQubitsResp::AppendQubitsResp(const AppendQubitsResp& other189) {
  base = other189.base;
}
AppendQubitsResp& AppendQubitsResp::operator=(const AppendQubitsResp& other190) {
  base = other190.base;
  return *this;
}
void AppendQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppendQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


ResetQubitsReq::~ResetQubitsReq() noexcept {
}


void ResetQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void ResetQubitsReq::__set_qubits(const std::vector<int32_t> & val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const ResetQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResetQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->qubits.clear();
            uint32_t _size191;
            ::apache::thrift::protocol::TType _etype194;
            xfer += iprot->readListBegin(_etype194, _size191);
            this->qubits.resize(_size191);
            uint32_t _i195;
            for (_i195 = 0; _i195 < _size191; ++_i195)
            {
              xfer += iprot->readI32(this->qubits[_i195]);
            }
            xfer += iprot->readListEnd();
          }
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResetQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResetQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->qubits.size()));
    std::vector<int32_t> ::const_iterator _iter196;
    for (_iter196 = this->qubits.begin(); _iter196 != this->qubits.end(); ++_iter196)
    {
      xfer += oprot->writeI32((*_iter196));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResetQubitsReq &a, ResetQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

ResetQubitsReq::ResetQubitsReq(const ResetQubitsReq& other197) {
  id = other197.id;
  qubits = other197.qubits;
}
ResetQubitsReq& ResetQubitsReq::operator=(const ResetQubitsReq& other198) {
  id = other198.id;
  qubits = other198.qubits;
  return *this;
}
void ResetQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResetQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


ResetQubitsResp::~ResetQubitsResp() noexcept {
}


void ResetQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const ResetQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResetQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResetQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResetQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResetQubitsResp &a, ResetQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

ResetQubitsResp::ResetQubitsResp(const ResetQubitsResp& other199) {
  base = other199.base;
}
ResetQubitsResp& ResetQubitsResp::operator=(const ResetQubitsResp& other200) {
  base = other200.base;
  return *this;
}
void ResetQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResetQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


GetStateOfAllQubitsReq::~GetStateOfAllQubitsReq() noexcept {
}


void GetStateOfAllQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetStateOfAllQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetStateOfAllQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetStateOfAllQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetStateOfAllQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetStateOfAllQubitsReq &a, GetStateOfAllQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetStateOfAllQubitsReq::GetStateOfAllQubitsReq(const GetStateOfAllQubitsReq& other201) {
  id = other201.id;
}
GetStateOfAllQubitsReq& GetStateOfAllQubitsReq::operator=(const GetStateOfAllQubitsReq& other202) {
  id = other202.id;
  return *this;
}
void GetStateOfAllQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetStateOfAllQubitsReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetStateOfAllQubitsResp::~GetStateOfAllQubitsResp() noexcept {
}


void GetStateOfAllQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetStateOfAllQubitsResp::__set_state_vector(const std::vector<double> & val) {
  this->state_vector = val;
}
std::ostream& operator<<(std::ostream& out, const GetStateOfAllQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetStateOfAllQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->state_vector.clear();
            uint32_t _size203;
            ::apache::thrift::protocol::TType _etype206;
            xfer += iprot->readListBegin(_etype206, _size203);
            this->state_vector.resize(_size203);
            uint32_t _i207;
            for (_i207 = 0; _i207 < _size203; ++_i207)
            {
              xfer += iprot->readDouble(this->state_vector[_i207]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.state_vector = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetStateOfAllQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetStateOfAllQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state_vector", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->state_vector.size()));
    std::vector<double> ::const_iterator _iter208;
    for (_iter208 = this->state_vector.begin(); _iter208 != this->state_vector.end(); ++_iter208)
    {
      xfer += oprot->writeDouble((*_iter208));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetStateOfAllQubitsResp &a, GetStateOfAllQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.state_vector, b.state_vector);
  swap(a.__isset, b.__isset);
}

GetStateOfAllQubitsResp::GetStateOfAllQubitsResp(const GetStateOfAllQubitsResp& other209) {
  base = other209.base;
  state_vector = other209.state_vector;
  __isset = other209.__isset;
}
GetStateOfAllQubitsResp& GetStateOfAllQubitsResp::operator=(const GetStateOfAllQubitsResp& other210) {
  base = other210.base;
  state_vector = other210.state_vector;
  __isset = other210.__isset;
  return *this;
}
void GetStateOfAllQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetStateOfAllQubitsResp(";
  out << "base=" << to_string(base);
  out << ", " << "state_vector=" << to_string(state_vector);
  out << ")";
}


GetProbabilitiesReq::~GetProbabilitiesReq() noexcept {
}


void GetProbabilitiesReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbabilitiesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbabilitiesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbabilitiesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbabilitiesReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbabilitiesReq &a, GetProbabilitiesReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetProbabilitiesReq::GetProbabilitiesReq(const GetProbabilitiesReq& other211) {
  id = other211.id;
}
GetProbabilitiesReq& GetProbabilitiesReq::operator=(const GetProbabilitiesReq& other212) {
  id = other212.id;
  return *this;
}
void GetProbabilitiesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbabilitiesReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetProbabilitiesResp::~GetProbabilitiesResp() noexcept {
}


void GetProbabilitiesResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbabilitiesResp::__set_probabilities(const std::vector<double> & val) {
  this->probabilities = val;
__isset.probabilities = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbabilitiesResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbabilitiesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->probabilities.clear();
            uint32_t _size213;
            ::apache::thrift::protocol::TType _etype216;
            xfer += iprot->readListBegin(_etype216, _size213);
            this->probabilities.resize(_size213);
            uint32_t _i217;
            for (_i217 = 0; _i217 < _size213; ++_i217)
            {
              xfer += iprot->readDouble(this->probabilities[_i217]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.probabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbabilitiesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbabilitiesResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.probabilities) {
    xfer += oprot->writeFieldBegin("probabilities", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->probabilities.size()));
      std::vector<double> ::const_iterator _iter218;
      for (_iter218 = this->probabilities.begin(); _iter218 != this->probabilities.end(); ++_iter218)
      {
        xfer += oprot->writeDouble((*_iter218));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbabilitiesResp &a, GetProbabilitiesResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.probabilities, b.probabilities);
  swap(a.__isset, b.__isset);
}

GetProbabilitiesResp::GetProbabilitiesResp(const GetProbabilitiesResp& other219) {
  base = other219.base;
  probabilities = other219.probabilities;
  __isset = other219.__isset;
}
GetProbabilitiesResp& GetProbabilitiesResp::operator=(const GetProbabilitiesResp& other220) {
  base = other220.base;
  probabilities = other220.probabilities;
  __isset = other220.__isset;
  return *this;
}
void GetProbabilitiesResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbabilitiesResp(";
  out << "base=" << to_string(base);
  out << ", " << "probabilities="; (__isset.probabilities ? (out << to_string(probabilities)) : (out << "<null>"));
  out << ")";
}


GetTaskInfoReq::~GetTaskInfoReq() noexcept {
}


void GetTaskInfoReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetTaskInfoReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTaskInfoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTaskInfoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTaskInfoReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTaskInfoReq &a, GetTaskInfoReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetTaskInfoReq::GetTaskInfoReq(const GetTaskInfoReq& other221) {
  id = other221.id;
}
GetTaskInfoReq& GetTaskInfoReq::operator=(const GetTaskInfoReq& other222) {
  id = other222.id;
  return *this;
}
void GetTaskInfoReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTaskInfoReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetTaskInfoResp::~GetTaskInfoResp() noexcept {
}


void GetTaskInfoResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetTaskInfoResp::__set_state(const int32_t val) {
  this->state = val;
}
std::ostream& operator<<(std::ostream& out, const GetTaskInfoResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTaskInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->state);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTaskInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTaskInfoResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTaskInfoResp &a, GetTaskInfoResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.state, b.state);
}

GetTaskInfoResp::GetTaskInfoResp(const GetTaskInfoResp& other223) {
  base = other223.base;
  state = other223.state;
}
GetTaskInfoResp& GetTaskInfoResp::operator=(const GetTaskInfoResp& other224) {
  base = other224.base;
  state = other224.state;
  return *this;
}
void GetTaskInfoResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTaskInfoResp(";
  out << "base=" << to_string(base);
  out << ", " << "state=" << to_string(state);
  out << ")";
}


