/**
 * Autogenerated by Thrift Compiler (0.15.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "qusproutdata_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kExecCmdTypeValues[] = {
  ExecCmdType::ExecTypeDefault,
  ExecCmdType::ExecTypeCpuSingle,
  ExecCmdType::ExecTypeCpuMpi,
  ExecCmdType::ExecTypeGpuSingle
};
const char* _kExecCmdTypeNames[] = {
  "ExecTypeDefault",
  "ExecTypeCpuSingle",
  "ExecTypeCpuMpi",
  "ExecTypeGpuSingle"
};
const std::map<int, const char*> _ExecCmdType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kExecCmdTypeValues, _kExecCmdTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ExecCmdType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExecCmdType_VALUES_TO_NAMES.find(val);
  if (it != _ExecCmdType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ExecCmdType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExecCmdType_VALUES_TO_NAMES.find(val);
  if (it != _ExecCmdType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPauliOperTypeValues[] = {
  PauliOperType::POT_PAULI_I,
  PauliOperType::POT_PAULI_X,
  PauliOperType::POT_PAULI_Y,
  PauliOperType::POT_PAULI_Z
};
const char* _kPauliOperTypeNames[] = {
  "POT_PAULI_I",
  "POT_PAULI_X",
  "POT_PAULI_Y",
  "POT_PAULI_Z"
};
const std::map<int, const char*> _PauliOperType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kPauliOperTypeValues, _kPauliOperTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PauliOperType::type& val) {
  std::map<int, const char*>::const_iterator it = _PauliOperType_VALUES_TO_NAMES.find(val);
  if (it != _PauliOperType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PauliOperType::type& val) {
  std::map<int, const char*>::const_iterator it = _PauliOperType_VALUES_TO_NAMES.find(val);
  if (it != _PauliOperType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Cmd::~Cmd() noexcept {
}


void Cmd::__set_gate(const std::string& val) {
  this->gate = val;
}

void Cmd::__set_targets(const std::vector<int32_t> & val) {
  this->targets = val;
}

void Cmd::__set_controls(const std::vector<int32_t> & val) {
  this->controls = val;
}

void Cmd::__set_rotation(const std::vector<double> & val) {
  this->rotation = val;
}

void Cmd::__set_desc(const std::string& val) {
  this->desc = val;
}

void Cmd::__set_inverse(const bool val) {
  this->inverse = val;
}
std::ostream& operator<<(std::ostream& out, const Cmd& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cmd::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_gate = false;
  bool isset_targets = false;
  bool isset_controls = false;
  bool isset_rotation = false;
  bool isset_desc = false;
  bool isset_inverse = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gate);
          isset_gate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->targets.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI32(this->targets[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->controls.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->controls.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readI32(this->controls[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          isset_controls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rotation.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->rotation.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readDouble(this->rotation[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          isset_rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->desc);
          isset_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inverse);
          isset_inverse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_gate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_controls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rotation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_desc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inverse)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Cmd::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cmd");

  xfer += oprot->writeFieldBegin("gate", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->gate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targets.size()));
    std::vector<int32_t> ::const_iterator _iter15;
    for (_iter15 = this->targets.begin(); _iter15 != this->targets.end(); ++_iter15)
    {
      xfer += oprot->writeI32((*_iter15));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("controls", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->controls.size()));
    std::vector<int32_t> ::const_iterator _iter16;
    for (_iter16 = this->controls.begin(); _iter16 != this->controls.end(); ++_iter16)
    {
      xfer += oprot->writeI32((*_iter16));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotation", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->rotation.size()));
    std::vector<double> ::const_iterator _iter17;
    for (_iter17 = this->rotation.begin(); _iter17 != this->rotation.end(); ++_iter17)
    {
      xfer += oprot->writeDouble((*_iter17));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("desc", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->desc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inverse", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->inverse);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cmd &a, Cmd &b) {
  using ::std::swap;
  swap(a.gate, b.gate);
  swap(a.targets, b.targets);
  swap(a.controls, b.controls);
  swap(a.rotation, b.rotation);
  swap(a.desc, b.desc);
  swap(a.inverse, b.inverse);
}

Cmd::Cmd(const Cmd& other18) {
  gate = other18.gate;
  targets = other18.targets;
  controls = other18.controls;
  rotation = other18.rotation;
  desc = other18.desc;
  inverse = other18.inverse;
}
Cmd& Cmd::operator=(const Cmd& other19) {
  gate = other19.gate;
  targets = other19.targets;
  controls = other19.controls;
  rotation = other19.rotation;
  desc = other19.desc;
  inverse = other19.inverse;
  return *this;
}
void Cmd::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cmd(";
  out << "gate=" << to_string(gate);
  out << ", " << "targets=" << to_string(targets);
  out << ", " << "controls=" << to_string(controls);
  out << ", " << "rotation=" << to_string(rotation);
  out << ", " << "desc=" << to_string(desc);
  out << ", " << "inverse=" << to_string(inverse);
  out << ")";
}


Circuit::~Circuit() noexcept {
}


void Circuit::__set_cmds(const std::vector<Cmd> & val) {
  this->cmds = val;
}
std::ostream& operator<<(std::ostream& out, const Circuit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Circuit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cmds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cmds.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->cmds.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->cmds[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_cmds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cmds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Circuit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Circuit");

  xfer += oprot->writeFieldBegin("cmds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cmds.size()));
    std::vector<Cmd> ::const_iterator _iter25;
    for (_iter25 = this->cmds.begin(); _iter25 != this->cmds.end(); ++_iter25)
    {
      xfer += (*_iter25).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Circuit &a, Circuit &b) {
  using ::std::swap;
  swap(a.cmds, b.cmds);
}

Circuit::Circuit(const Circuit& other26) {
  cmds = other26.cmds;
}
Circuit& Circuit::operator=(const Circuit& other27) {
  cmds = other27.cmds;
  return *this;
}
void Circuit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Circuit(";
  out << "cmds=" << to_string(cmds);
  out << ")";
}


MeasureResult::~MeasureResult() noexcept {
}


void MeasureResult::__set_id(const int32_t val) {
  this->id = val;
}

void MeasureResult::__set_value(const int32_t val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureResult");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureResult &a, MeasureResult &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.value, b.value);
}

MeasureResult::MeasureResult(const MeasureResult& other28) noexcept {
  id = other28.id;
  value = other28.value;
}
MeasureResult& MeasureResult::operator=(const MeasureResult& other29) noexcept {
  id = other29.id;
  value = other29.value;
  return *this;
}
void MeasureResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureResult(";
  out << "id=" << to_string(id);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


Outcome::~Outcome() noexcept {
}


void Outcome::__set_bitstr(const std::string& val) {
  this->bitstr = val;
}

void Outcome::__set_count(const int32_t val) {
  this->count = val;
}
std::ostream& operator<<(std::ostream& out, const Outcome& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Outcome::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_bitstr = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bitstr);
          isset_bitstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_bitstr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Outcome::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Outcome");

  xfer += oprot->writeFieldBegin("bitstr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bitstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Outcome &a, Outcome &b) {
  using ::std::swap;
  swap(a.bitstr, b.bitstr);
  swap(a.count, b.count);
}

Outcome::Outcome(const Outcome& other30) {
  bitstr = other30.bitstr;
  count = other30.count;
}
Outcome& Outcome::operator=(const Outcome& other31) {
  bitstr = other31.bitstr;
  count = other31.count;
  return *this;
}
void Outcome::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Outcome(";
  out << "bitstr=" << to_string(bitstr);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


Result::~Result() noexcept {
}


void Result::__set_measureSet(const std::vector<MeasureResult> & val) {
  this->measureSet = val;
}

void Result::__set_outcomeSet(const std::vector<Outcome> & val) {
  this->outcomeSet = val;
}
std::ostream& operator<<(std::ostream& out, const Result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_measureSet = false;
  bool isset_outcomeSet = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measureSet.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->measureSet.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->measureSet[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_measureSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outcomeSet.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->outcomeSet.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->outcomeSet[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_outcomeSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_measureSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_outcomeSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("measureSet", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->measureSet.size()));
    std::vector<MeasureResult> ::const_iterator _iter42;
    for (_iter42 = this->measureSet.begin(); _iter42 != this->measureSet.end(); ++_iter42)
    {
      xfer += (*_iter42).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outcomeSet", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outcomeSet.size()));
    std::vector<Outcome> ::const_iterator _iter43;
    for (_iter43 = this->outcomeSet.begin(); _iter43 != this->outcomeSet.end(); ++_iter43)
    {
      xfer += (*_iter43).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.measureSet, b.measureSet);
  swap(a.outcomeSet, b.outcomeSet);
}

Result::Result(const Result& other44) {
  measureSet = other44.measureSet;
  outcomeSet = other44.outcomeSet;
}
Result& Result::operator=(const Result& other45) {
  measureSet = other45.measureSet;
  outcomeSet = other45.outcomeSet;
  return *this;
}
void Result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Result(";
  out << "measureSet=" << to_string(measureSet);
  out << ", " << "outcomeSet=" << to_string(outcomeSet);
  out << ")";
}


InitQubitsReq::~InitQubitsReq() noexcept {
}


void InitQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void InitQubitsReq::__set_qubits(const int32_t val) {
  this->qubits = val;
}

void InitQubitsReq::__set_density(const bool val) {
  this->density = val;
__isset.density = true;
}

void InitQubitsReq::__set_exec_type(const ExecCmdType::type val) {
  this->exec_type = val;
__isset.exec_type = true;
}

void InitQubitsReq::__set_hosts(const std::vector<std::string> & val) {
  this->hosts = val;
__isset.hosts = true;
}
std::ostream& operator<<(std::ostream& out, const InitQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->density);
          this->__isset.density = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast46;
          xfer += iprot->readI32(ecast46);
          this->exec_type = static_cast<ExecCmdType::type>(ecast46);
          this->__isset.exec_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hosts.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->hosts.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readString(this->hosts[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InitQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.density) {
    xfer += oprot->writeFieldBegin("density", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->density);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exec_type) {
    xfer += oprot->writeFieldBegin("exec_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->exec_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hosts) {
    xfer += oprot->writeFieldBegin("hosts", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hosts.size()));
      std::vector<std::string> ::const_iterator _iter52;
      for (_iter52 = this->hosts.begin(); _iter52 != this->hosts.end(); ++_iter52)
      {
        xfer += oprot->writeString((*_iter52));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitQubitsReq &a, InitQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
  swap(a.density, b.density);
  swap(a.exec_type, b.exec_type);
  swap(a.hosts, b.hosts);
  swap(a.__isset, b.__isset);
}

InitQubitsReq::InitQubitsReq(const InitQubitsReq& other53) {
  id = other53.id;
  qubits = other53.qubits;
  density = other53.density;
  exec_type = other53.exec_type;
  hosts = other53.hosts;
  __isset = other53.__isset;
}
InitQubitsReq& InitQubitsReq::operator=(const InitQubitsReq& other54) {
  id = other54.id;
  qubits = other54.qubits;
  density = other54.density;
  exec_type = other54.exec_type;
  hosts = other54.hosts;
  __isset = other54.__isset;
  return *this;
}
void InitQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ", " << "density="; (__isset.density ? (out << to_string(density)) : (out << "<null>"));
  out << ", " << "exec_type="; (__isset.exec_type ? (out << to_string(exec_type)) : (out << "<null>"));
  out << ", " << "hosts="; (__isset.hosts ? (out << to_string(hosts)) : (out << "<null>"));
  out << ")";
}


InitQubitsResp::~InitQubitsResp() noexcept {
}


void InitQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const InitQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InitQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitQubitsResp &a, InitQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

InitQubitsResp::InitQubitsResp(const InitQubitsResp& other55) {
  base = other55.base;
}
InitQubitsResp& InitQubitsResp::operator=(const InitQubitsResp& other56) {
  base = other56.base;
  return *this;
}
void InitQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


SetAmplitudesReq::~SetAmplitudesReq() noexcept {
}


void SetAmplitudesReq::__set_id(const std::string& val) {
  this->id = val;
}

void SetAmplitudesReq::__set_reals(const std::vector<double> & val) {
  this->reals = val;
}

void SetAmplitudesReq::__set_imags(const std::vector<double> & val) {
  this->imags = val;
}
std::ostream& operator<<(std::ostream& out, const SetAmplitudesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetAmplitudesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_reals = false;
  bool isset_imags = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->reals.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->reals.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += iprot->readDouble(this->reals[_i61]);
            }
            xfer += iprot->readListEnd();
          }
          isset_reals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->imags.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->imags.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += iprot->readDouble(this->imags[_i66]);
            }
            xfer += iprot->readListEnd();
          }
          isset_imags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_reals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_imags)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SetAmplitudesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetAmplitudesReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->reals.size()));
    std::vector<double> ::const_iterator _iter67;
    for (_iter67 = this->reals.begin(); _iter67 != this->reals.end(); ++_iter67)
    {
      xfer += oprot->writeDouble((*_iter67));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("imags", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->imags.size()));
    std::vector<double> ::const_iterator _iter68;
    for (_iter68 = this->imags.begin(); _iter68 != this->imags.end(); ++_iter68)
    {
      xfer += oprot->writeDouble((*_iter68));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetAmplitudesReq &a, SetAmplitudesReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.reals, b.reals);
  swap(a.imags, b.imags);
}

SetAmplitudesReq::SetAmplitudesReq(const SetAmplitudesReq& other69) {
  id = other69.id;
  reals = other69.reals;
  imags = other69.imags;
}
SetAmplitudesReq& SetAmplitudesReq::operator=(const SetAmplitudesReq& other70) {
  id = other70.id;
  reals = other70.reals;
  imags = other70.imags;
  return *this;
}
void SetAmplitudesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetAmplitudesReq(";
  out << "id=" << to_string(id);
  out << ", " << "reals=" << to_string(reals);
  out << ", " << "imags=" << to_string(imags);
  out << ")";
}


SetAmplitudesResp::~SetAmplitudesResp() noexcept {
}


void SetAmplitudesResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const SetAmplitudesResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetAmplitudesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SetAmplitudesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetAmplitudesResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetAmplitudesResp &a, SetAmplitudesResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

SetAmplitudesResp::SetAmplitudesResp(const SetAmplitudesResp& other71) {
  base = other71.base;
}
SetAmplitudesResp& SetAmplitudesResp::operator=(const SetAmplitudesResp& other72) {
  base = other72.base;
  return *this;
}
void SetAmplitudesResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetAmplitudesResp(";
  out << "base=" << to_string(base);
  out << ")";
}


SendCircuitCmdReq::~SendCircuitCmdReq() noexcept {
}


void SendCircuitCmdReq::__set_id(const std::string& val) {
  this->id = val;
}

void SendCircuitCmdReq::__set_circuit(const Circuit& val) {
  this->circuit = val;
__isset.circuit = true;
}

void SendCircuitCmdReq::__set_final(const bool val) {
  this->final = val;
__isset.final = true;
}
std::ostream& operator<<(std::ostream& out, const SendCircuitCmdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SendCircuitCmdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->circuit.read(iprot);
          this->__isset.circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->final);
          this->__isset.final = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SendCircuitCmdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SendCircuitCmdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.circuit) {
    xfer += oprot->writeFieldBegin("circuit", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->circuit.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.final) {
    xfer += oprot->writeFieldBegin("final", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->final);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SendCircuitCmdReq &a, SendCircuitCmdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.circuit, b.circuit);
  swap(a.final, b.final);
  swap(a.__isset, b.__isset);
}

SendCircuitCmdReq::SendCircuitCmdReq(const SendCircuitCmdReq& other73) {
  id = other73.id;
  circuit = other73.circuit;
  final = other73.final;
  __isset = other73.__isset;
}
SendCircuitCmdReq& SendCircuitCmdReq::operator=(const SendCircuitCmdReq& other74) {
  id = other74.id;
  circuit = other74.circuit;
  final = other74.final;
  __isset = other74.__isset;
  return *this;
}
void SendCircuitCmdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SendCircuitCmdReq(";
  out << "id=" << to_string(id);
  out << ", " << "circuit="; (__isset.circuit ? (out << to_string(circuit)) : (out << "<null>"));
  out << ", " << "final="; (__isset.final ? (out << to_string(final)) : (out << "<null>"));
  out << ")";
}


SendCircuitCmdResp::~SendCircuitCmdResp() noexcept {
}


void SendCircuitCmdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const SendCircuitCmdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SendCircuitCmdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SendCircuitCmdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SendCircuitCmdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SendCircuitCmdResp &a, SendCircuitCmdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

SendCircuitCmdResp::SendCircuitCmdResp(const SendCircuitCmdResp& other75) {
  base = other75.base;
}
SendCircuitCmdResp& SendCircuitCmdResp::operator=(const SendCircuitCmdResp& other76) {
  base = other76.base;
  return *this;
}
void SendCircuitCmdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SendCircuitCmdResp(";
  out << "base=" << to_string(base);
  out << ")";
}


CancelCmdReq::~CancelCmdReq() noexcept {
}


void CancelCmdReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const CancelCmdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CancelCmdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CancelCmdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CancelCmdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CancelCmdReq &a, CancelCmdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

CancelCmdReq::CancelCmdReq(const CancelCmdReq& other77) {
  id = other77.id;
}
CancelCmdReq& CancelCmdReq::operator=(const CancelCmdReq& other78) {
  id = other78.id;
  return *this;
}
void CancelCmdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CancelCmdReq(";
  out << "id=" << to_string(id);
  out << ")";
}


CancelCmdResp::~CancelCmdResp() noexcept {
}


void CancelCmdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const CancelCmdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CancelCmdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CancelCmdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CancelCmdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CancelCmdResp &a, CancelCmdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

CancelCmdResp::CancelCmdResp(const CancelCmdResp& other79) {
  base = other79.base;
}
CancelCmdResp& CancelCmdResp::operator=(const CancelCmdResp& other80) {
  base = other80.base;
  return *this;
}
void CancelCmdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CancelCmdResp(";
  out << "base=" << to_string(base);
  out << ")";
}


GetProbAmpReq::~GetProbAmpReq() noexcept {
}


void GetProbAmpReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetProbAmpReq::__set_index(const int64_t val) {
  this->index = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbAmpReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbAmpReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_index = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->index);
          isset_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbAmpReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbAmpReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbAmpReq &a, GetProbAmpReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.index, b.index);
}

GetProbAmpReq::GetProbAmpReq(const GetProbAmpReq& other81) {
  id = other81.id;
  index = other81.index;
}
GetProbAmpReq& GetProbAmpReq::operator=(const GetProbAmpReq& other82) {
  id = other82.id;
  index = other82.index;
  return *this;
}
void GetProbAmpReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbAmpReq(";
  out << "id=" << to_string(id);
  out << ", " << "index=" << to_string(index);
  out << ")";
}


GetProbAmpResp::~GetProbAmpResp() noexcept {
}


void GetProbAmpResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbAmpResp::__set_amp(const double val) {
  this->amp = val;
__isset.amp = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbAmpResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbAmpResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->amp);
          this->__isset.amp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbAmpResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbAmpResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.amp) {
    xfer += oprot->writeFieldBegin("amp", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->amp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbAmpResp &a, GetProbAmpResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.amp, b.amp);
  swap(a.__isset, b.__isset);
}

GetProbAmpResp::GetProbAmpResp(const GetProbAmpResp& other83) {
  base = other83.base;
  amp = other83.amp;
  __isset = other83.__isset;
}
GetProbAmpResp& GetProbAmpResp::operator=(const GetProbAmpResp& other84) {
  base = other84.base;
  amp = other84.amp;
  __isset = other84.__isset;
  return *this;
}
void GetProbAmpResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbAmpResp(";
  out << "base=" << to_string(base);
  out << ", " << "amp="; (__isset.amp ? (out << to_string(amp)) : (out << "<null>"));
  out << ")";
}


GetProbOfOutcomeReq::~GetProbOfOutcomeReq() noexcept {
}


void GetProbOfOutcomeReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetProbOfOutcomeReq::__set_qubit(const int32_t val) {
  this->qubit = val;
}

void GetProbOfOutcomeReq::__set_outcom(const int32_t val) {
  this->outcom = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfOutcomeReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfOutcomeReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubit = false;
  bool isset_outcom = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubit);
          isset_qubit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->outcom);
          isset_outcom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_outcom)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfOutcomeReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfOutcomeReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubit", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outcom", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->outcom);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfOutcomeReq &a, GetProbOfOutcomeReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubit, b.qubit);
  swap(a.outcom, b.outcom);
}

GetProbOfOutcomeReq::GetProbOfOutcomeReq(const GetProbOfOutcomeReq& other85) {
  id = other85.id;
  qubit = other85.qubit;
  outcom = other85.outcom;
}
GetProbOfOutcomeReq& GetProbOfOutcomeReq::operator=(const GetProbOfOutcomeReq& other86) {
  id = other86.id;
  qubit = other86.qubit;
  outcom = other86.outcom;
  return *this;
}
void GetProbOfOutcomeReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfOutcomeReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubit=" << to_string(qubit);
  out << ", " << "outcom=" << to_string(outcom);
  out << ")";
}


GetProbOfOutcomeResp::~GetProbOfOutcomeResp() noexcept {
}


void GetProbOfOutcomeResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbOfOutcomeResp::__set_pro_outcome(const double val) {
  this->pro_outcome = val;
__isset.pro_outcome = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfOutcomeResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfOutcomeResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pro_outcome);
          this->__isset.pro_outcome = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfOutcomeResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfOutcomeResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pro_outcome) {
    xfer += oprot->writeFieldBegin("pro_outcome", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->pro_outcome);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfOutcomeResp &a, GetProbOfOutcomeResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.pro_outcome, b.pro_outcome);
  swap(a.__isset, b.__isset);
}

GetProbOfOutcomeResp::GetProbOfOutcomeResp(const GetProbOfOutcomeResp& other87) {
  base = other87.base;
  pro_outcome = other87.pro_outcome;
  __isset = other87.__isset;
}
GetProbOfOutcomeResp& GetProbOfOutcomeResp::operator=(const GetProbOfOutcomeResp& other88) {
  base = other88.base;
  pro_outcome = other88.pro_outcome;
  __isset = other88.__isset;
  return *this;
}
void GetProbOfOutcomeResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfOutcomeResp(";
  out << "base=" << to_string(base);
  out << ", " << "pro_outcome="; (__isset.pro_outcome ? (out << to_string(pro_outcome)) : (out << "<null>"));
  out << ")";
}


GetProbOfAllOutcomReq::~GetProbOfAllOutcomReq() noexcept {
}


void GetProbOfAllOutcomReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetProbOfAllOutcomReq::__set_targets(const std::vector<int32_t> & val) {
  this->targets = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfAllOutcomReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfAllOutcomReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_targets = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            xfer += iprot->readListBegin(_etype92, _size89);
            this->targets.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += iprot->readI32(this->targets[_i93]);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfAllOutcomReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfAllOutcomReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targets.size()));
    std::vector<int32_t> ::const_iterator _iter94;
    for (_iter94 = this->targets.begin(); _iter94 != this->targets.end(); ++_iter94)
    {
      xfer += oprot->writeI32((*_iter94));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfAllOutcomReq &a, GetProbOfAllOutcomReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.targets, b.targets);
}

GetProbOfAllOutcomReq::GetProbOfAllOutcomReq(const GetProbOfAllOutcomReq& other95) {
  id = other95.id;
  targets = other95.targets;
}
GetProbOfAllOutcomReq& GetProbOfAllOutcomReq::operator=(const GetProbOfAllOutcomReq& other96) {
  id = other96.id;
  targets = other96.targets;
  return *this;
}
void GetProbOfAllOutcomReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfAllOutcomReq(";
  out << "id=" << to_string(id);
  out << ", " << "targets=" << to_string(targets);
  out << ")";
}


GetProbOfAllOutcomResp::~GetProbOfAllOutcomResp() noexcept {
}


void GetProbOfAllOutcomResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbOfAllOutcomResp::__set_pro_outcomes(const std::vector<double> & val) {
  this->pro_outcomes = val;
__isset.pro_outcomes = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfAllOutcomResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfAllOutcomResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pro_outcomes.clear();
            uint32_t _size97;
            ::apache::thrift::protocol::TType _etype100;
            xfer += iprot->readListBegin(_etype100, _size97);
            this->pro_outcomes.resize(_size97);
            uint32_t _i101;
            for (_i101 = 0; _i101 < _size97; ++_i101)
            {
              xfer += iprot->readDouble(this->pro_outcomes[_i101]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pro_outcomes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfAllOutcomResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfAllOutcomResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pro_outcomes) {
    xfer += oprot->writeFieldBegin("pro_outcomes", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->pro_outcomes.size()));
      std::vector<double> ::const_iterator _iter102;
      for (_iter102 = this->pro_outcomes.begin(); _iter102 != this->pro_outcomes.end(); ++_iter102)
      {
        xfer += oprot->writeDouble((*_iter102));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfAllOutcomResp &a, GetProbOfAllOutcomResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.pro_outcomes, b.pro_outcomes);
  swap(a.__isset, b.__isset);
}

GetProbOfAllOutcomResp::GetProbOfAllOutcomResp(const GetProbOfAllOutcomResp& other103) {
  base = other103.base;
  pro_outcomes = other103.pro_outcomes;
  __isset = other103.__isset;
}
GetProbOfAllOutcomResp& GetProbOfAllOutcomResp::operator=(const GetProbOfAllOutcomResp& other104) {
  base = other104.base;
  pro_outcomes = other104.pro_outcomes;
  __isset = other104.__isset;
  return *this;
}
void GetProbOfAllOutcomResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfAllOutcomResp(";
  out << "base=" << to_string(base);
  out << ", " << "pro_outcomes="; (__isset.pro_outcomes ? (out << to_string(pro_outcomes)) : (out << "<null>"));
  out << ")";
}


GetAllStateReq::~GetAllStateReq() noexcept {
}


void GetAllStateReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetAllStateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllStateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetAllStateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllStateReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllStateReq &a, GetAllStateReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetAllStateReq::GetAllStateReq(const GetAllStateReq& other105) {
  id = other105.id;
}
GetAllStateReq& GetAllStateReq::operator=(const GetAllStateReq& other106) {
  id = other106.id;
  return *this;
}
void GetAllStateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllStateReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetAllStateResp::~GetAllStateResp() noexcept {
}


void GetAllStateResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetAllStateResp::__set_all_state(const std::vector<std::string> & val) {
  this->all_state = val;
__isset.all_state = true;
}
std::ostream& operator<<(std::ostream& out, const GetAllStateResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllStateResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->all_state.clear();
            uint32_t _size107;
            ::apache::thrift::protocol::TType _etype110;
            xfer += iprot->readListBegin(_etype110, _size107);
            this->all_state.resize(_size107);
            uint32_t _i111;
            for (_i111 = 0; _i111 < _size107; ++_i111)
            {
              xfer += iprot->readString(this->all_state[_i111]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.all_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetAllStateResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllStateResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.all_state) {
    xfer += oprot->writeFieldBegin("all_state", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->all_state.size()));
      std::vector<std::string> ::const_iterator _iter112;
      for (_iter112 = this->all_state.begin(); _iter112 != this->all_state.end(); ++_iter112)
      {
        xfer += oprot->writeString((*_iter112));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllStateResp &a, GetAllStateResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.all_state, b.all_state);
  swap(a.__isset, b.__isset);
}

GetAllStateResp::GetAllStateResp(const GetAllStateResp& other113) {
  base = other113.base;
  all_state = other113.all_state;
  __isset = other113.__isset;
}
GetAllStateResp& GetAllStateResp::operator=(const GetAllStateResp& other114) {
  base = other114.base;
  all_state = other114.all_state;
  __isset = other114.__isset;
  return *this;
}
void GetAllStateResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllStateResp(";
  out << "base=" << to_string(base);
  out << ", " << "all_state="; (__isset.all_state ? (out << to_string(all_state)) : (out << "<null>"));
  out << ")";
}


ApplyQFTReq::~ApplyQFTReq() noexcept {
}


void ApplyQFTReq::__set_id(const std::string& val) {
  this->id = val;
}

void ApplyQFTReq::__set_targets(const std::vector<int32_t> & val) {
  this->targets = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyQFTReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyQFTReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_targets = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size115;
            ::apache::thrift::protocol::TType _etype118;
            xfer += iprot->readListBegin(_etype118, _size115);
            this->targets.resize(_size115);
            uint32_t _i119;
            for (_i119 = 0; _i119 < _size115; ++_i119)
            {
              xfer += iprot->readI32(this->targets[_i119]);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyQFTReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyQFTReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targets.size()));
    std::vector<int32_t> ::const_iterator _iter120;
    for (_iter120 = this->targets.begin(); _iter120 != this->targets.end(); ++_iter120)
    {
      xfer += oprot->writeI32((*_iter120));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyQFTReq &a, ApplyQFTReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.targets, b.targets);
}

ApplyQFTReq::ApplyQFTReq(const ApplyQFTReq& other121) {
  id = other121.id;
  targets = other121.targets;
}
ApplyQFTReq& ApplyQFTReq::operator=(const ApplyQFTReq& other122) {
  id = other122.id;
  targets = other122.targets;
  return *this;
}
void ApplyQFTReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyQFTReq(";
  out << "id=" << to_string(id);
  out << ", " << "targets=" << to_string(targets);
  out << ")";
}


ApplyQFTResp::~ApplyQFTResp() noexcept {
}


void ApplyQFTResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyQFTResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyQFTResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyQFTResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyQFTResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyQFTResp &a, ApplyQFTResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

ApplyQFTResp::ApplyQFTResp(const ApplyQFTResp& other123) {
  base = other123.base;
}
ApplyQFTResp& ApplyQFTResp::operator=(const ApplyQFTResp& other124) {
  base = other124.base;
  return *this;
}
void ApplyQFTResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyQFTResp(";
  out << "base=" << to_string(base);
  out << ")";
}


ApplyFullQFTReq::~ApplyFullQFTReq() noexcept {
}


void ApplyFullQFTReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyFullQFTReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyFullQFTReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyFullQFTReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyFullQFTReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyFullQFTReq &a, ApplyFullQFTReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

ApplyFullQFTReq::ApplyFullQFTReq(const ApplyFullQFTReq& other125) {
  id = other125.id;
}
ApplyFullQFTReq& ApplyFullQFTReq::operator=(const ApplyFullQFTReq& other126) {
  id = other126.id;
  return *this;
}
void ApplyFullQFTReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyFullQFTReq(";
  out << "id=" << to_string(id);
  out << ")";
}


ApplyFullQFTResp::~ApplyFullQFTResp() noexcept {
}


void ApplyFullQFTResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyFullQFTResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyFullQFTResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyFullQFTResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyFullQFTResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyFullQFTResp &a, ApplyFullQFTResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

ApplyFullQFTResp::ApplyFullQFTResp(const ApplyFullQFTResp& other127) {
  base = other127.base;
}
ApplyFullQFTResp& ApplyFullQFTResp::operator=(const ApplyFullQFTResp& other128) {
  base = other128.base;
  return *this;
}
void ApplyFullQFTResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyFullQFTResp(";
  out << "base=" << to_string(base);
  out << ")";
}


RunCircuitReq::~RunCircuitReq() noexcept {
}


void RunCircuitReq::__set_id(const std::string& val) {
  this->id = val;
}

void RunCircuitReq::__set_shots(const int32_t val) {
  this->shots = val;
}
std::ostream& operator<<(std::ostream& out, const RunCircuitReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RunCircuitReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_shots = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shots);
          isset_shots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_shots)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RunCircuitReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RunCircuitReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shots", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->shots);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RunCircuitReq &a, RunCircuitReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.shots, b.shots);
}

RunCircuitReq::RunCircuitReq(const RunCircuitReq& other129) {
  id = other129.id;
  shots = other129.shots;
}
RunCircuitReq& RunCircuitReq::operator=(const RunCircuitReq& other130) {
  id = other130.id;
  shots = other130.shots;
  return *this;
}
void RunCircuitReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RunCircuitReq(";
  out << "id=" << to_string(id);
  out << ", " << "shots=" << to_string(shots);
  out << ")";
}


RunCircuitResp::~RunCircuitResp() noexcept {
}


void RunCircuitResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void RunCircuitResp::__set_result(const Result& val) {
  this->result = val;
__isset.result = true;
}
std::ostream& operator<<(std::ostream& out, const RunCircuitResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RunCircuitResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RunCircuitResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RunCircuitResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.result) {
    xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->result.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RunCircuitResp &a, RunCircuitResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

RunCircuitResp::RunCircuitResp(const RunCircuitResp& other131) {
  base = other131.base;
  result = other131.result;
  __isset = other131.__isset;
}
RunCircuitResp& RunCircuitResp::operator=(const RunCircuitResp& other132) {
  base = other132.base;
  result = other132.result;
  __isset = other132.__isset;
  return *this;
}
void RunCircuitResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RunCircuitResp(";
  out << "base=" << to_string(base);
  out << ", " << "result="; (__isset.result ? (out << to_string(result)) : (out << "<null>"));
  out << ")";
}


GetExpecPauliProdReq::~GetExpecPauliProdReq() noexcept {
}


void GetExpecPauliProdReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetExpecPauliProdReq::__set_pauli_prod(const std::vector<PauliProdInfo> & val) {
  this->pauli_prod = val;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliProdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliProdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_pauli_prod = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pauli_prod.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _etype136;
            xfer += iprot->readListBegin(_etype136, _size133);
            this->pauli_prod.resize(_size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              xfer += this->pauli_prod[_i137].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_pauli_prod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pauli_prod)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliProdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliProdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pauli_prod", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pauli_prod.size()));
    std::vector<PauliProdInfo> ::const_iterator _iter138;
    for (_iter138 = this->pauli_prod.begin(); _iter138 != this->pauli_prod.end(); ++_iter138)
    {
      xfer += (*_iter138).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliProdReq &a, GetExpecPauliProdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.pauli_prod, b.pauli_prod);
}

GetExpecPauliProdReq::GetExpecPauliProdReq(const GetExpecPauliProdReq& other139) {
  id = other139.id;
  pauli_prod = other139.pauli_prod;
}
GetExpecPauliProdReq& GetExpecPauliProdReq::operator=(const GetExpecPauliProdReq& other140) {
  id = other140.id;
  pauli_prod = other140.pauli_prod;
  return *this;
}
void GetExpecPauliProdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliProdReq(";
  out << "id=" << to_string(id);
  out << ", " << "pauli_prod=" << to_string(pauli_prod);
  out << ")";
}


GetExpecPauliProdResp::~GetExpecPauliProdResp() noexcept {
}


void GetExpecPauliProdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetExpecPauliProdResp::__set_expect(const double val) {
  this->expect = val;
__isset.expect = true;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliProdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliProdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->expect);
          this->__isset.expect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliProdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliProdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.expect) {
    xfer += oprot->writeFieldBegin("expect", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->expect);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliProdResp &a, GetExpecPauliProdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.expect, b.expect);
  swap(a.__isset, b.__isset);
}

GetExpecPauliProdResp::GetExpecPauliProdResp(const GetExpecPauliProdResp& other141) {
  base = other141.base;
  expect = other141.expect;
  __isset = other141.__isset;
}
GetExpecPauliProdResp& GetExpecPauliProdResp::operator=(const GetExpecPauliProdResp& other142) {
  base = other142.base;
  expect = other142.expect;
  __isset = other142.__isset;
  return *this;
}
void GetExpecPauliProdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliProdResp(";
  out << "base=" << to_string(base);
  out << ", " << "expect="; (__isset.expect ? (out << to_string(expect)) : (out << "<null>"));
  out << ")";
}


PauliProdInfo::~PauliProdInfo() noexcept {
}


void PauliProdInfo::__set_oper_type(const PauliOperType::type val) {
  this->oper_type = val;
}

void PauliProdInfo::__set_target(const int32_t val) {
  this->target = val;
}
std::ostream& operator<<(std::ostream& out, const PauliProdInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PauliProdInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_oper_type = false;
  bool isset_target = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast143;
          xfer += iprot->readI32(ecast143);
          this->oper_type = static_cast<PauliOperType::type>(ecast143);
          isset_oper_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->target);
          isset_target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_oper_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PauliProdInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PauliProdInfo");

  xfer += oprot->writeFieldBegin("oper_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->oper_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PauliProdInfo &a, PauliProdInfo &b) {
  using ::std::swap;
  swap(a.oper_type, b.oper_type);
  swap(a.target, b.target);
}

PauliProdInfo::PauliProdInfo(const PauliProdInfo& other144) noexcept {
  oper_type = other144.oper_type;
  target = other144.target;
}
PauliProdInfo& PauliProdInfo::operator=(const PauliProdInfo& other145) noexcept {
  oper_type = other145.oper_type;
  target = other145.target;
  return *this;
}
void PauliProdInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PauliProdInfo(";
  out << "oper_type=" << to_string(oper_type);
  out << ", " << "target=" << to_string(target);
  out << ")";
}


GetExpecPauliSumReq::~GetExpecPauliSumReq() noexcept {
}


void GetExpecPauliSumReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetExpecPauliSumReq::__set_oper_type_list(const std::vector<PauliOperType::type> & val) {
  this->oper_type_list = val;
}

void GetExpecPauliSumReq::__set_term_coeff_list(const std::vector<double> & val) {
  this->term_coeff_list = val;
__isset.term_coeff_list = true;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliSumReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliSumReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_oper_type_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->oper_type_list.clear();
            uint32_t _size146;
            ::apache::thrift::protocol::TType _etype149;
            xfer += iprot->readListBegin(_etype149, _size146);
            this->oper_type_list.resize(_size146);
            uint32_t _i150;
            for (_i150 = 0; _i150 < _size146; ++_i150)
            {
              int32_t ecast151;
              xfer += iprot->readI32(ecast151);
              this->oper_type_list[_i150] = static_cast<PauliOperType::type>(ecast151);
            }
            xfer += iprot->readListEnd();
          }
          isset_oper_type_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->term_coeff_list.clear();
            uint32_t _size152;
            ::apache::thrift::protocol::TType _etype155;
            xfer += iprot->readListBegin(_etype155, _size152);
            this->term_coeff_list.resize(_size152);
            uint32_t _i156;
            for (_i156 = 0; _i156 < _size152; ++_i156)
            {
              xfer += iprot->readDouble(this->term_coeff_list[_i156]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.term_coeff_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_oper_type_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliSumReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliSumReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oper_type_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->oper_type_list.size()));
    std::vector<PauliOperType::type> ::const_iterator _iter157;
    for (_iter157 = this->oper_type_list.begin(); _iter157 != this->oper_type_list.end(); ++_iter157)
    {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter157)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.term_coeff_list) {
    xfer += oprot->writeFieldBegin("term_coeff_list", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->term_coeff_list.size()));
      std::vector<double> ::const_iterator _iter158;
      for (_iter158 = this->term_coeff_list.begin(); _iter158 != this->term_coeff_list.end(); ++_iter158)
      {
        xfer += oprot->writeDouble((*_iter158));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliSumReq &a, GetExpecPauliSumReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.oper_type_list, b.oper_type_list);
  swap(a.term_coeff_list, b.term_coeff_list);
  swap(a.__isset, b.__isset);
}

GetExpecPauliSumReq::GetExpecPauliSumReq(const GetExpecPauliSumReq& other159) {
  id = other159.id;
  oper_type_list = other159.oper_type_list;
  term_coeff_list = other159.term_coeff_list;
  __isset = other159.__isset;
}
GetExpecPauliSumReq& GetExpecPauliSumReq::operator=(const GetExpecPauliSumReq& other160) {
  id = other160.id;
  oper_type_list = other160.oper_type_list;
  term_coeff_list = other160.term_coeff_list;
  __isset = other160.__isset;
  return *this;
}
void GetExpecPauliSumReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliSumReq(";
  out << "id=" << to_string(id);
  out << ", " << "oper_type_list=" << to_string(oper_type_list);
  out << ", " << "term_coeff_list="; (__isset.term_coeff_list ? (out << to_string(term_coeff_list)) : (out << "<null>"));
  out << ")";
}


GetExpecPauliSumResp::~GetExpecPauliSumResp() noexcept {
}


void GetExpecPauliSumResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetExpecPauliSumResp::__set_expect(const double val) {
  this->expect = val;
__isset.expect = true;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliSumResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliSumResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->expect);
          this->__isset.expect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliSumResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliSumResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.expect) {
    xfer += oprot->writeFieldBegin("expect", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->expect);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliSumResp &a, GetExpecPauliSumResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.expect, b.expect);
  swap(a.__isset, b.__isset);
}

GetExpecPauliSumResp::GetExpecPauliSumResp(const GetExpecPauliSumResp& other161) {
  base = other161.base;
  expect = other161.expect;
  __isset = other161.__isset;
}
GetExpecPauliSumResp& GetExpecPauliSumResp::operator=(const GetExpecPauliSumResp& other162) {
  base = other162.base;
  expect = other162.expect;
  __isset = other162.__isset;
  return *this;
}
void GetExpecPauliSumResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliSumResp(";
  out << "base=" << to_string(base);
  out << ", " << "expect="; (__isset.expect ? (out << to_string(expect)) : (out << "<null>"));
  out << ")";
}


MeasureQubitsReq::~MeasureQubitsReq() noexcept {
}


void MeasureQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void MeasureQubitsReq::__set_qubits(const std::vector<int32_t> & val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->qubits.clear();
            uint32_t _size163;
            ::apache::thrift::protocol::TType _etype166;
            xfer += iprot->readListBegin(_etype166, _size163);
            this->qubits.resize(_size163);
            uint32_t _i167;
            for (_i167 = 0; _i167 < _size163; ++_i167)
            {
              xfer += iprot->readI32(this->qubits[_i167]);
            }
            xfer += iprot->readListEnd();
          }
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->qubits.size()));
    std::vector<int32_t> ::const_iterator _iter168;
    for (_iter168 = this->qubits.begin(); _iter168 != this->qubits.end(); ++_iter168)
    {
      xfer += oprot->writeI32((*_iter168));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureQubitsReq &a, MeasureQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

MeasureQubitsReq::MeasureQubitsReq(const MeasureQubitsReq& other169) {
  id = other169.id;
  qubits = other169.qubits;
}
MeasureQubitsReq& MeasureQubitsReq::operator=(const MeasureQubitsReq& other170) {
  id = other170.id;
  qubits = other170.qubits;
  return *this;
}
void MeasureQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


MeasureQubitsResp::~MeasureQubitsResp() noexcept {
}


void MeasureQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void MeasureQubitsResp::__set_results(const std::vector<MeasureResult> & val) {
  this->results = val;
__isset.results = true;
}

void MeasureQubitsResp::__set_outcomes(const std::vector<Outcome> & val) {
  this->outcomes = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;
  bool isset_outcomes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size171;
            ::apache::thrift::protocol::TType _etype174;
            xfer += iprot->readListBegin(_etype174, _size171);
            this->results.resize(_size171);
            uint32_t _i175;
            for (_i175 = 0; _i175 < _size171; ++_i175)
            {
              xfer += this->results[_i175].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outcomes.clear();
            uint32_t _size176;
            ::apache::thrift::protocol::TType _etype179;
            xfer += iprot->readListBegin(_etype179, _size176);
            this->outcomes.resize(_size176);
            uint32_t _i180;
            for (_i180 = 0; _i180 < _size176; ++_i180)
            {
              xfer += this->outcomes[_i180].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_outcomes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_outcomes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.results) {
    xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
      std::vector<MeasureResult> ::const_iterator _iter181;
      for (_iter181 = this->results.begin(); _iter181 != this->results.end(); ++_iter181)
      {
        xfer += (*_iter181).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("outcomes", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outcomes.size()));
    std::vector<Outcome> ::const_iterator _iter182;
    for (_iter182 = this->outcomes.begin(); _iter182 != this->outcomes.end(); ++_iter182)
    {
      xfer += (*_iter182).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureQubitsResp &a, MeasureQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.results, b.results);
  swap(a.outcomes, b.outcomes);
  swap(a.__isset, b.__isset);
}

MeasureQubitsResp::MeasureQubitsResp(const MeasureQubitsResp& other183) {
  base = other183.base;
  results = other183.results;
  outcomes = other183.outcomes;
  __isset = other183.__isset;
}
MeasureQubitsResp& MeasureQubitsResp::operator=(const MeasureQubitsResp& other184) {
  base = other184.base;
  results = other184.results;
  outcomes = other184.outcomes;
  __isset = other184.__isset;
  return *this;
}
void MeasureQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureQubitsResp(";
  out << "base=" << to_string(base);
  out << ", " << "results="; (__isset.results ? (out << to_string(results)) : (out << "<null>"));
  out << ", " << "outcomes=" << to_string(outcomes);
  out << ")";
}


GateMatrix::~GateMatrix() noexcept {
}


void GateMatrix::__set_name(const std::string& val) {
  this->name = val;
}

void GateMatrix::__set_qubits(const int32_t val) {
  this->qubits = val;
}

void GateMatrix::__set_matrix(const std::vector<double> & val) {
  this->matrix = val;
}
std::ostream& operator<<(std::ostream& out, const GateMatrix& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GateMatrix::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_qubits = false;
  bool isset_matrix = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->matrix.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            this->matrix.resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              xfer += iprot->readDouble(this->matrix[_i189]);
            }
            xfer += iprot->readListEnd();
          }
          isset_matrix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_matrix)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GateMatrix::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GateMatrix");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matrix", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->matrix.size()));
    std::vector<double> ::const_iterator _iter190;
    for (_iter190 = this->matrix.begin(); _iter190 != this->matrix.end(); ++_iter190)
    {
      xfer += oprot->writeDouble((*_iter190));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GateMatrix &a, GateMatrix &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.qubits, b.qubits);
  swap(a.matrix, b.matrix);
}

GateMatrix::GateMatrix(const GateMatrix& other191) {
  name = other191.name;
  qubits = other191.qubits;
  matrix = other191.matrix;
}
GateMatrix& GateMatrix::operator=(const GateMatrix& other192) {
  name = other192.name;
  qubits = other192.qubits;
  matrix = other192.matrix;
  return *this;
}
void GateMatrix::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GateMatrix(";
  out << "name=" << to_string(name);
  out << ", " << "qubits=" << to_string(qubits);
  out << ", " << "matrix=" << to_string(matrix);
  out << ")";
}


AddCustomGateByMatrixReq::~AddCustomGateByMatrixReq() noexcept {
}


void AddCustomGateByMatrixReq::__set_id(const std::string& val) {
  this->id = val;
}

void AddCustomGateByMatrixReq::__set_gate(const GateMatrix& val) {
  this->gate = val;
}
std::ostream& operator<<(std::ostream& out, const AddCustomGateByMatrixReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddCustomGateByMatrixReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_gate = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gate.read(iprot);
          isset_gate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddCustomGateByMatrixReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddCustomGateByMatrixReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gate", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->gate.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddCustomGateByMatrixReq &a, AddCustomGateByMatrixReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.gate, b.gate);
}

AddCustomGateByMatrixReq::AddCustomGateByMatrixReq(const AddCustomGateByMatrixReq& other193) {
  id = other193.id;
  gate = other193.gate;
}
AddCustomGateByMatrixReq& AddCustomGateByMatrixReq::operator=(const AddCustomGateByMatrixReq& other194) {
  id = other194.id;
  gate = other194.gate;
  return *this;
}
void AddCustomGateByMatrixReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddCustomGateByMatrixReq(";
  out << "id=" << to_string(id);
  out << ", " << "gate=" << to_string(gate);
  out << ")";
}


AddCustomGateByMatrixResp::~AddCustomGateByMatrixResp() noexcept {
}


void AddCustomGateByMatrixResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AddCustomGateByMatrixResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddCustomGateByMatrixResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddCustomGateByMatrixResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddCustomGateByMatrixResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddCustomGateByMatrixResp &a, AddCustomGateByMatrixResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AddCustomGateByMatrixResp::AddCustomGateByMatrixResp(const AddCustomGateByMatrixResp& other195) {
  base = other195.base;
}
AddCustomGateByMatrixResp& AddCustomGateByMatrixResp::operator=(const AddCustomGateByMatrixResp& other196) {
  base = other196.base;
  return *this;
}
void AddCustomGateByMatrixResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddCustomGateByMatrixResp(";
  out << "base=" << to_string(base);
  out << ")";
}


SubCircuit::~SubCircuit() noexcept {
}


void SubCircuit::__set_name(const std::string& val) {
  this->name = val;
}

void SubCircuit::__set_circuit(const Circuit& val) {
  this->circuit = val;
}
std::ostream& operator<<(std::ostream& out, const SubCircuit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SubCircuit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_circuit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->circuit.read(iprot);
          isset_circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_circuit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SubCircuit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SubCircuit");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("circuit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->circuit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SubCircuit &a, SubCircuit &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.circuit, b.circuit);
}

SubCircuit::SubCircuit(const SubCircuit& other197) {
  name = other197.name;
  circuit = other197.circuit;
}
SubCircuit& SubCircuit::operator=(const SubCircuit& other198) {
  name = other198.name;
  circuit = other198.circuit;
  return *this;
}
void SubCircuit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SubCircuit(";
  out << "name=" << to_string(name);
  out << ", " << "circuit=" << to_string(circuit);
  out << ")";
}


AddSubCircuitReq::~AddSubCircuitReq() noexcept {
}


void AddSubCircuitReq::__set_id(const std::string& val) {
  this->id = val;
}

void AddSubCircuitReq::__set_sub_circuit(const SubCircuit& val) {
  this->sub_circuit = val;
}
std::ostream& operator<<(std::ostream& out, const AddSubCircuitReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddSubCircuitReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_sub_circuit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sub_circuit.read(iprot);
          isset_sub_circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sub_circuit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddSubCircuitReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddSubCircuitReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sub_circuit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->sub_circuit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddSubCircuitReq &a, AddSubCircuitReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.sub_circuit, b.sub_circuit);
}

AddSubCircuitReq::AddSubCircuitReq(const AddSubCircuitReq& other199) {
  id = other199.id;
  sub_circuit = other199.sub_circuit;
}
AddSubCircuitReq& AddSubCircuitReq::operator=(const AddSubCircuitReq& other200) {
  id = other200.id;
  sub_circuit = other200.sub_circuit;
  return *this;
}
void AddSubCircuitReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddSubCircuitReq(";
  out << "id=" << to_string(id);
  out << ", " << "sub_circuit=" << to_string(sub_circuit);
  out << ")";
}


AddSubCircuitResp::~AddSubCircuitResp() noexcept {
}


void AddSubCircuitResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AddSubCircuitResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddSubCircuitResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddSubCircuitResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddSubCircuitResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddSubCircuitResp &a, AddSubCircuitResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AddSubCircuitResp::AddSubCircuitResp(const AddSubCircuitResp& other201) {
  base = other201.base;
}
AddSubCircuitResp& AddSubCircuitResp::operator=(const AddSubCircuitResp& other202) {
  base = other202.base;
  return *this;
}
void AddSubCircuitResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddSubCircuitResp(";
  out << "base=" << to_string(base);
  out << ")";
}


AppendQubitsReq::~AppendQubitsReq() noexcept {
}


void AppendQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void AppendQubitsReq::__set_qubits(const int32_t val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const AppendQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppendQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppendQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppendQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppendQubitsReq &a, AppendQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

AppendQubitsReq::AppendQubitsReq(const AppendQubitsReq& other203) {
  id = other203.id;
  qubits = other203.qubits;
}
AppendQubitsReq& AppendQubitsReq::operator=(const AppendQubitsReq& other204) {
  id = other204.id;
  qubits = other204.qubits;
  return *this;
}
void AppendQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppendQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


AppendQubitsResp::~AppendQubitsResp() noexcept {
}


void AppendQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AppendQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppendQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppendQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppendQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppendQubitsResp &a, AppendQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AppendQubitsResp::AppendQubitsResp(const AppendQubitsResp& other205) {
  base = other205.base;
}
AppendQubitsResp& AppendQubitsResp::operator=(const AppendQubitsResp& other206) {
  base = other206.base;
  return *this;
}
void AppendQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppendQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


ResetQubitsReq::~ResetQubitsReq() noexcept {
}


void ResetQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void ResetQubitsReq::__set_qubits(const std::vector<int32_t> & val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const ResetQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResetQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->qubits.clear();
            uint32_t _size207;
            ::apache::thrift::protocol::TType _etype210;
            xfer += iprot->readListBegin(_etype210, _size207);
            this->qubits.resize(_size207);
            uint32_t _i211;
            for (_i211 = 0; _i211 < _size207; ++_i211)
            {
              xfer += iprot->readI32(this->qubits[_i211]);
            }
            xfer += iprot->readListEnd();
          }
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResetQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResetQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->qubits.size()));
    std::vector<int32_t> ::const_iterator _iter212;
    for (_iter212 = this->qubits.begin(); _iter212 != this->qubits.end(); ++_iter212)
    {
      xfer += oprot->writeI32((*_iter212));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResetQubitsReq &a, ResetQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

ResetQubitsReq::ResetQubitsReq(const ResetQubitsReq& other213) {
  id = other213.id;
  qubits = other213.qubits;
}
ResetQubitsReq& ResetQubitsReq::operator=(const ResetQubitsReq& other214) {
  id = other214.id;
  qubits = other214.qubits;
  return *this;
}
void ResetQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResetQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


ResetQubitsResp::~ResetQubitsResp() noexcept {
}


void ResetQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const ResetQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResetQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResetQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResetQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResetQubitsResp &a, ResetQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

ResetQubitsResp::ResetQubitsResp(const ResetQubitsResp& other215) {
  base = other215.base;
}
ResetQubitsResp& ResetQubitsResp::operator=(const ResetQubitsResp& other216) {
  base = other216.base;
  return *this;
}
void ResetQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResetQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


GetStateOfAllQubitsReq::~GetStateOfAllQubitsReq() noexcept {
}


void GetStateOfAllQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetStateOfAllQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetStateOfAllQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetStateOfAllQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetStateOfAllQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetStateOfAllQubitsReq &a, GetStateOfAllQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetStateOfAllQubitsReq::GetStateOfAllQubitsReq(const GetStateOfAllQubitsReq& other217) {
  id = other217.id;
}
GetStateOfAllQubitsReq& GetStateOfAllQubitsReq::operator=(const GetStateOfAllQubitsReq& other218) {
  id = other218.id;
  return *this;
}
void GetStateOfAllQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetStateOfAllQubitsReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetStateOfAllQubitsResp::~GetStateOfAllQubitsResp() noexcept {
}


void GetStateOfAllQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetStateOfAllQubitsResp::__set_state_vector(const std::vector<double> & val) {
  this->state_vector = val;
}
std::ostream& operator<<(std::ostream& out, const GetStateOfAllQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetStateOfAllQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->state_vector.clear();
            uint32_t _size219;
            ::apache::thrift::protocol::TType _etype222;
            xfer += iprot->readListBegin(_etype222, _size219);
            this->state_vector.resize(_size219);
            uint32_t _i223;
            for (_i223 = 0; _i223 < _size219; ++_i223)
            {
              xfer += iprot->readDouble(this->state_vector[_i223]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.state_vector = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetStateOfAllQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetStateOfAllQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state_vector", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->state_vector.size()));
    std::vector<double> ::const_iterator _iter224;
    for (_iter224 = this->state_vector.begin(); _iter224 != this->state_vector.end(); ++_iter224)
    {
      xfer += oprot->writeDouble((*_iter224));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetStateOfAllQubitsResp &a, GetStateOfAllQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.state_vector, b.state_vector);
  swap(a.__isset, b.__isset);
}

GetStateOfAllQubitsResp::GetStateOfAllQubitsResp(const GetStateOfAllQubitsResp& other225) {
  base = other225.base;
  state_vector = other225.state_vector;
  __isset = other225.__isset;
}
GetStateOfAllQubitsResp& GetStateOfAllQubitsResp::operator=(const GetStateOfAllQubitsResp& other226) {
  base = other226.base;
  state_vector = other226.state_vector;
  __isset = other226.__isset;
  return *this;
}
void GetStateOfAllQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetStateOfAllQubitsResp(";
  out << "base=" << to_string(base);
  out << ", " << "state_vector=" << to_string(state_vector);
  out << ")";
}


GetProbabilitiesReq::~GetProbabilitiesReq() noexcept {
}


void GetProbabilitiesReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbabilitiesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbabilitiesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbabilitiesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbabilitiesReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbabilitiesReq &a, GetProbabilitiesReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetProbabilitiesReq::GetProbabilitiesReq(const GetProbabilitiesReq& other227) {
  id = other227.id;
}
GetProbabilitiesReq& GetProbabilitiesReq::operator=(const GetProbabilitiesReq& other228) {
  id = other228.id;
  return *this;
}
void GetProbabilitiesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbabilitiesReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetProbabilitiesResp::~GetProbabilitiesResp() noexcept {
}


void GetProbabilitiesResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbabilitiesResp::__set_probabilities(const std::vector<double> & val) {
  this->probabilities = val;
__isset.probabilities = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbabilitiesResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbabilitiesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->probabilities.clear();
            uint32_t _size229;
            ::apache::thrift::protocol::TType _etype232;
            xfer += iprot->readListBegin(_etype232, _size229);
            this->probabilities.resize(_size229);
            uint32_t _i233;
            for (_i233 = 0; _i233 < _size229; ++_i233)
            {
              xfer += iprot->readDouble(this->probabilities[_i233]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.probabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbabilitiesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbabilitiesResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.probabilities) {
    xfer += oprot->writeFieldBegin("probabilities", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->probabilities.size()));
      std::vector<double> ::const_iterator _iter234;
      for (_iter234 = this->probabilities.begin(); _iter234 != this->probabilities.end(); ++_iter234)
      {
        xfer += oprot->writeDouble((*_iter234));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbabilitiesResp &a, GetProbabilitiesResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.probabilities, b.probabilities);
  swap(a.__isset, b.__isset);
}

GetProbabilitiesResp::GetProbabilitiesResp(const GetProbabilitiesResp& other235) {
  base = other235.base;
  probabilities = other235.probabilities;
  __isset = other235.__isset;
}
GetProbabilitiesResp& GetProbabilitiesResp::operator=(const GetProbabilitiesResp& other236) {
  base = other236.base;
  probabilities = other236.probabilities;
  __isset = other236.__isset;
  return *this;
}
void GetProbabilitiesResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbabilitiesResp(";
  out << "base=" << to_string(base);
  out << ", " << "probabilities="; (__isset.probabilities ? (out << to_string(probabilities)) : (out << "<null>"));
  out << ")";
}


