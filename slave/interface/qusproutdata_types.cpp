/**
 * Autogenerated by Thrift Compiler (0.15.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "qusproutdata_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kExecCmdTypeValues[] = {
  ExecCmdType::ExecTypeDefault,
  ExecCmdType::ExecTypeCpuSingle,
  ExecCmdType::ExecTypeCpuMpi,
  ExecCmdType::ExecTypeGpuSingle
};
const char* _kExecCmdTypeNames[] = {
  "ExecTypeDefault",
  "ExecTypeCpuSingle",
  "ExecTypeCpuMpi",
  "ExecTypeGpuSingle"
};
const std::map<int, const char*> _ExecCmdType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kExecCmdTypeValues, _kExecCmdTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ExecCmdType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExecCmdType_VALUES_TO_NAMES.find(val);
  if (it != _ExecCmdType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ExecCmdType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExecCmdType_VALUES_TO_NAMES.find(val);
  if (it != _ExecCmdType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPauliOperTypeValues[] = {
  PauliOperType::POT_PAULI_I,
  PauliOperType::POT_PAULI_X,
  PauliOperType::POT_PAULI_Y,
  PauliOperType::POT_PAULI_Z
};
const char* _kPauliOperTypeNames[] = {
  "POT_PAULI_I",
  "POT_PAULI_X",
  "POT_PAULI_Y",
  "POT_PAULI_Z"
};
const std::map<int, const char*> _PauliOperType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kPauliOperTypeValues, _kPauliOperTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PauliOperType::type& val) {
  std::map<int, const char*>::const_iterator it = _PauliOperType_VALUES_TO_NAMES.find(val);
  if (it != _PauliOperType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PauliOperType::type& val) {
  std::map<int, const char*>::const_iterator it = _PauliOperType_VALUES_TO_NAMES.find(val);
  if (it != _PauliOperType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Amplitude::~Amplitude() noexcept {
}


void Amplitude::__set_reals(const std::vector<double> & val) {
  this->reals = val;
}

void Amplitude::__set_imags(const std::vector<double> & val) {
  this->imags = val;
}

void Amplitude::__set_startind(const int32_t val) {
  this->startind = val;
}

void Amplitude::__set_numamps(const int32_t val) {
  this->numamps = val;
}
std::ostream& operator<<(std::ostream& out, const Amplitude& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Amplitude::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reals = false;
  bool isset_imags = false;
  bool isset_startind = false;
  bool isset_numamps = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->reals.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->reals.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readDouble(this->reals[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_reals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->imags.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->imags.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readDouble(this->imags[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          isset_imags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->startind);
          isset_startind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numamps);
          isset_numamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_imags)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_startind)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Amplitude::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Amplitude");

  xfer += oprot->writeFieldBegin("reals", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->reals.size()));
    std::vector<double> ::const_iterator _iter10;
    for (_iter10 = this->reals.begin(); _iter10 != this->reals.end(); ++_iter10)
    {
      xfer += oprot->writeDouble((*_iter10));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("imags", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->imags.size()));
    std::vector<double> ::const_iterator _iter11;
    for (_iter11 = this->imags.begin(); _iter11 != this->imags.end(); ++_iter11)
    {
      xfer += oprot->writeDouble((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startind", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->startind);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numamps", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->numamps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Amplitude &a, Amplitude &b) {
  using ::std::swap;
  swap(a.reals, b.reals);
  swap(a.imags, b.imags);
  swap(a.startind, b.startind);
  swap(a.numamps, b.numamps);
}

Amplitude::Amplitude(const Amplitude& other12) {
  reals = other12.reals;
  imags = other12.imags;
  startind = other12.startind;
  numamps = other12.numamps;
}
Amplitude& Amplitude::operator=(const Amplitude& other13) {
  reals = other13.reals;
  imags = other13.imags;
  startind = other13.startind;
  numamps = other13.numamps;
  return *this;
}
void Amplitude::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Amplitude(";
  out << "reals=" << to_string(reals);
  out << ", " << "imags=" << to_string(imags);
  out << ", " << "startind=" << to_string(startind);
  out << ", " << "numamps=" << to_string(numamps);
  out << ")";
}


Matrix::~Matrix() noexcept {
}


void Matrix::__set_reals(const std::vector<std::vector<double> > & val) {
  this->reals = val;
}

void Matrix::__set_imags(const std::vector<std::vector<double> > & val) {
  this->imags = val;
}

void Matrix::__set_unitary(const bool val) {
  this->unitary = val;
}
std::ostream& operator<<(std::ostream& out, const Matrix& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Matrix::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reals = false;
  bool isset_imags = false;
  bool isset_unitary = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->reals.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->reals.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              {
                this->reals[_i18].clear();
                uint32_t _size19;
                ::apache::thrift::protocol::TType _etype22;
                xfer += iprot->readListBegin(_etype22, _size19);
                this->reals[_i18].resize(_size19);
                uint32_t _i23;
                for (_i23 = 0; _i23 < _size19; ++_i23)
                {
                  xfer += iprot->readDouble(this->reals[_i18][_i23]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_reals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->imags.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->imags.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              {
                this->imags[_i28].clear();
                uint32_t _size29;
                ::apache::thrift::protocol::TType _etype32;
                xfer += iprot->readListBegin(_etype32, _size29);
                this->imags[_i28].resize(_size29);
                uint32_t _i33;
                for (_i33 = 0; _i33 < _size29; ++_i33)
                {
                  xfer += iprot->readDouble(this->imags[_i28][_i33]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_imags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->unitary);
          isset_unitary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_imags)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unitary)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Matrix::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Matrix");

  xfer += oprot->writeFieldBegin("reals", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->reals.size()));
    std::vector<std::vector<double> > ::const_iterator _iter34;
    for (_iter34 = this->reals.begin(); _iter34 != this->reals.end(); ++_iter34)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*_iter34).size()));
        std::vector<double> ::const_iterator _iter35;
        for (_iter35 = (*_iter34).begin(); _iter35 != (*_iter34).end(); ++_iter35)
        {
          xfer += oprot->writeDouble((*_iter35));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("imags", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->imags.size()));
    std::vector<std::vector<double> > ::const_iterator _iter36;
    for (_iter36 = this->imags.begin(); _iter36 != this->imags.end(); ++_iter36)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*_iter36).size()));
        std::vector<double> ::const_iterator _iter37;
        for (_iter37 = (*_iter36).begin(); _iter37 != (*_iter36).end(); ++_iter37)
        {
          xfer += oprot->writeDouble((*_iter37));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unitary", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->unitary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Matrix &a, Matrix &b) {
  using ::std::swap;
  swap(a.reals, b.reals);
  swap(a.imags, b.imags);
  swap(a.unitary, b.unitary);
}

Matrix::Matrix(const Matrix& other38) {
  reals = other38.reals;
  imags = other38.imags;
  unitary = other38.unitary;
}
Matrix& Matrix::operator=(const Matrix& other39) {
  reals = other39.reals;
  imags = other39.imags;
  unitary = other39.unitary;
  return *this;
}
void Matrix::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Matrix(";
  out << "reals=" << to_string(reals);
  out << ", " << "imags=" << to_string(imags);
  out << ", " << "unitary=" << to_string(unitary);
  out << ")";
}


Cmdex::~Cmdex() noexcept {
}


void Cmdex::__set_amp(const Amplitude& val) {
  this->amp = val;
__isset.amp = true;
}

void Cmdex::__set_mat(const Matrix& val) {
  this->mat = val;
__isset.mat = true;
}
std::ostream& operator<<(std::ostream& out, const Cmdex& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cmdex::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->amp.read(iprot);
          this->__isset.amp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mat.read(iprot);
          this->__isset.mat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cmdex::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cmdex");

  if (this->__isset.amp) {
    xfer += oprot->writeFieldBegin("amp", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->amp.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mat) {
    xfer += oprot->writeFieldBegin("mat", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->mat.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cmdex &a, Cmdex &b) {
  using ::std::swap;
  swap(a.amp, b.amp);
  swap(a.mat, b.mat);
  swap(a.__isset, b.__isset);
}

Cmdex::Cmdex(const Cmdex& other40) {
  amp = other40.amp;
  mat = other40.mat;
  __isset = other40.__isset;
}
Cmdex& Cmdex::operator=(const Cmdex& other41) {
  amp = other41.amp;
  mat = other41.mat;
  __isset = other41.__isset;
  return *this;
}
void Cmdex::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cmdex(";
  out << "amp="; (__isset.amp ? (out << to_string(amp)) : (out << "<null>"));
  out << ", " << "mat="; (__isset.mat ? (out << to_string(mat)) : (out << "<null>"));
  out << ")";
}


Cmd::~Cmd() noexcept {
}


void Cmd::__set_gate(const std::string& val) {
  this->gate = val;
}

void Cmd::__set_targets(const std::vector<int32_t> & val) {
  this->targets = val;
}

void Cmd::__set_controls(const std::vector<int32_t> & val) {
  this->controls = val;
}

void Cmd::__set_rotation(const std::vector<double> & val) {
  this->rotation = val;
}

void Cmd::__set_desc(const std::string& val) {
  this->desc = val;
}

void Cmd::__set_inverse(const bool val) {
  this->inverse = val;
}

void Cmd::__set_cmdex(const Cmdex& val) {
  this->cmdex = val;
__isset.cmdex = true;
}
std::ostream& operator<<(std::ostream& out, const Cmd& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cmd::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_gate = false;
  bool isset_targets = false;
  bool isset_controls = false;
  bool isset_rotation = false;
  bool isset_desc = false;
  bool isset_inverse = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gate);
          isset_gate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->targets.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += iprot->readI32(this->targets[_i46]);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->controls.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->controls.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readI32(this->controls[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          isset_controls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rotation.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->rotation.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += iprot->readDouble(this->rotation[_i56]);
            }
            xfer += iprot->readListEnd();
          }
          isset_rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->desc);
          isset_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inverse);
          isset_inverse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cmdex.read(iprot);
          this->__isset.cmdex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_gate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_controls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rotation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_desc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inverse)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Cmd::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cmd");

  xfer += oprot->writeFieldBegin("gate", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->gate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targets.size()));
    std::vector<int32_t> ::const_iterator _iter57;
    for (_iter57 = this->targets.begin(); _iter57 != this->targets.end(); ++_iter57)
    {
      xfer += oprot->writeI32((*_iter57));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("controls", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->controls.size()));
    std::vector<int32_t> ::const_iterator _iter58;
    for (_iter58 = this->controls.begin(); _iter58 != this->controls.end(); ++_iter58)
    {
      xfer += oprot->writeI32((*_iter58));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotation", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->rotation.size()));
    std::vector<double> ::const_iterator _iter59;
    for (_iter59 = this->rotation.begin(); _iter59 != this->rotation.end(); ++_iter59)
    {
      xfer += oprot->writeDouble((*_iter59));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("desc", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->desc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inverse", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->inverse);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cmdex) {
    xfer += oprot->writeFieldBegin("cmdex", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->cmdex.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cmd &a, Cmd &b) {
  using ::std::swap;
  swap(a.gate, b.gate);
  swap(a.targets, b.targets);
  swap(a.controls, b.controls);
  swap(a.rotation, b.rotation);
  swap(a.desc, b.desc);
  swap(a.inverse, b.inverse);
  swap(a.cmdex, b.cmdex);
  swap(a.__isset, b.__isset);
}

Cmd::Cmd(const Cmd& other60) {
  gate = other60.gate;
  targets = other60.targets;
  controls = other60.controls;
  rotation = other60.rotation;
  desc = other60.desc;
  inverse = other60.inverse;
  cmdex = other60.cmdex;
  __isset = other60.__isset;
}
Cmd& Cmd::operator=(const Cmd& other61) {
  gate = other61.gate;
  targets = other61.targets;
  controls = other61.controls;
  rotation = other61.rotation;
  desc = other61.desc;
  inverse = other61.inverse;
  cmdex = other61.cmdex;
  __isset = other61.__isset;
  return *this;
}
void Cmd::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cmd(";
  out << "gate=" << to_string(gate);
  out << ", " << "targets=" << to_string(targets);
  out << ", " << "controls=" << to_string(controls);
  out << ", " << "rotation=" << to_string(rotation);
  out << ", " << "desc=" << to_string(desc);
  out << ", " << "inverse=" << to_string(inverse);
  out << ", " << "cmdex="; (__isset.cmdex ? (out << to_string(cmdex)) : (out << "<null>"));
  out << ")";
}


Circuit::~Circuit() noexcept {
}


void Circuit::__set_cmds(const std::vector<Cmd> & val) {
  this->cmds = val;
}
std::ostream& operator<<(std::ostream& out, const Circuit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Circuit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cmds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cmds.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->cmds.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += this->cmds[_i66].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_cmds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cmds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Circuit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Circuit");

  xfer += oprot->writeFieldBegin("cmds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cmds.size()));
    std::vector<Cmd> ::const_iterator _iter67;
    for (_iter67 = this->cmds.begin(); _iter67 != this->cmds.end(); ++_iter67)
    {
      xfer += (*_iter67).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Circuit &a, Circuit &b) {
  using ::std::swap;
  swap(a.cmds, b.cmds);
}

Circuit::Circuit(const Circuit& other68) {
  cmds = other68.cmds;
}
Circuit& Circuit::operator=(const Circuit& other69) {
  cmds = other69.cmds;
  return *this;
}
void Circuit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Circuit(";
  out << "cmds=" << to_string(cmds);
  out << ")";
}


MeasureResult::~MeasureResult() noexcept {
}


void MeasureResult::__set_id(const int32_t val) {
  this->id = val;
}

void MeasureResult::__set_value(const int32_t val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureResult");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureResult &a, MeasureResult &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.value, b.value);
}

MeasureResult::MeasureResult(const MeasureResult& other70) noexcept {
  id = other70.id;
  value = other70.value;
}
MeasureResult& MeasureResult::operator=(const MeasureResult& other71) noexcept {
  id = other71.id;
  value = other71.value;
  return *this;
}
void MeasureResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureResult(";
  out << "id=" << to_string(id);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


Outcome::~Outcome() noexcept {
}


void Outcome::__set_bitstr(const std::string& val) {
  this->bitstr = val;
}

void Outcome::__set_count(const int32_t val) {
  this->count = val;
}
std::ostream& operator<<(std::ostream& out, const Outcome& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Outcome::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_bitstr = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bitstr);
          isset_bitstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_bitstr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Outcome::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Outcome");

  xfer += oprot->writeFieldBegin("bitstr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bitstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Outcome &a, Outcome &b) {
  using ::std::swap;
  swap(a.bitstr, b.bitstr);
  swap(a.count, b.count);
}

Outcome::Outcome(const Outcome& other72) {
  bitstr = other72.bitstr;
  count = other72.count;
}
Outcome& Outcome::operator=(const Outcome& other73) {
  bitstr = other73.bitstr;
  count = other73.count;
  return *this;
}
void Outcome::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Outcome(";
  out << "bitstr=" << to_string(bitstr);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


Result::~Result() noexcept {
}


void Result::__set_measureSet(const std::vector<MeasureResult> & val) {
  this->measureSet = val;
}

void Result::__set_outcomeSet(const std::vector<Outcome> & val) {
  this->outcomeSet = val;
}
std::ostream& operator<<(std::ostream& out, const Result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_measureSet = false;
  bool isset_outcomeSet = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measureSet.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readListBegin(_etype77, _size74);
            this->measureSet.resize(_size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              xfer += this->measureSet[_i78].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_measureSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outcomeSet.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->outcomeSet.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += this->outcomeSet[_i83].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_outcomeSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_measureSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_outcomeSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("measureSet", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->measureSet.size()));
    std::vector<MeasureResult> ::const_iterator _iter84;
    for (_iter84 = this->measureSet.begin(); _iter84 != this->measureSet.end(); ++_iter84)
    {
      xfer += (*_iter84).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outcomeSet", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outcomeSet.size()));
    std::vector<Outcome> ::const_iterator _iter85;
    for (_iter85 = this->outcomeSet.begin(); _iter85 != this->outcomeSet.end(); ++_iter85)
    {
      xfer += (*_iter85).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.measureSet, b.measureSet);
  swap(a.outcomeSet, b.outcomeSet);
}

Result::Result(const Result& other86) {
  measureSet = other86.measureSet;
  outcomeSet = other86.outcomeSet;
}
Result& Result::operator=(const Result& other87) {
  measureSet = other87.measureSet;
  outcomeSet = other87.outcomeSet;
  return *this;
}
void Result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Result(";
  out << "measureSet=" << to_string(measureSet);
  out << ", " << "outcomeSet=" << to_string(outcomeSet);
  out << ")";
}


InitQubitsReq::~InitQubitsReq() noexcept {
}


void InitQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void InitQubitsReq::__set_qubits(const int32_t val) {
  this->qubits = val;
}

void InitQubitsReq::__set_density(const bool val) {
  this->density = val;
__isset.density = true;
}

void InitQubitsReq::__set_exec_type(const ExecCmdType::type val) {
  this->exec_type = val;
__isset.exec_type = true;
}

void InitQubitsReq::__set_hosts(const std::vector<std::string> & val) {
  this->hosts = val;
__isset.hosts = true;
}
std::ostream& operator<<(std::ostream& out, const InitQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->density);
          this->__isset.density = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast88;
          xfer += iprot->readI32(ecast88);
          this->exec_type = static_cast<ExecCmdType::type>(ecast88);
          this->__isset.exec_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hosts.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            xfer += iprot->readListBegin(_etype92, _size89);
            this->hosts.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += iprot->readString(this->hosts[_i93]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InitQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.density) {
    xfer += oprot->writeFieldBegin("density", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->density);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exec_type) {
    xfer += oprot->writeFieldBegin("exec_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->exec_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hosts) {
    xfer += oprot->writeFieldBegin("hosts", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hosts.size()));
      std::vector<std::string> ::const_iterator _iter94;
      for (_iter94 = this->hosts.begin(); _iter94 != this->hosts.end(); ++_iter94)
      {
        xfer += oprot->writeString((*_iter94));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitQubitsReq &a, InitQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
  swap(a.density, b.density);
  swap(a.exec_type, b.exec_type);
  swap(a.hosts, b.hosts);
  swap(a.__isset, b.__isset);
}

InitQubitsReq::InitQubitsReq(const InitQubitsReq& other95) {
  id = other95.id;
  qubits = other95.qubits;
  density = other95.density;
  exec_type = other95.exec_type;
  hosts = other95.hosts;
  __isset = other95.__isset;
}
InitQubitsReq& InitQubitsReq::operator=(const InitQubitsReq& other96) {
  id = other96.id;
  qubits = other96.qubits;
  density = other96.density;
  exec_type = other96.exec_type;
  hosts = other96.hosts;
  __isset = other96.__isset;
  return *this;
}
void InitQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ", " << "density="; (__isset.density ? (out << to_string(density)) : (out << "<null>"));
  out << ", " << "exec_type="; (__isset.exec_type ? (out << to_string(exec_type)) : (out << "<null>"));
  out << ", " << "hosts="; (__isset.hosts ? (out << to_string(hosts)) : (out << "<null>"));
  out << ")";
}


InitQubitsResp::~InitQubitsResp() noexcept {
}


void InitQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const InitQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InitQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitQubitsResp &a, InitQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

InitQubitsResp::InitQubitsResp(const InitQubitsResp& other97) {
  base = other97.base;
}
InitQubitsResp& InitQubitsResp::operator=(const InitQubitsResp& other98) {
  base = other98.base;
  return *this;
}
void InitQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


SendCircuitCmdReq::~SendCircuitCmdReq() noexcept {
}


void SendCircuitCmdReq::__set_id(const std::string& val) {
  this->id = val;
}

void SendCircuitCmdReq::__set_circuit(const Circuit& val) {
  this->circuit = val;
__isset.circuit = true;
}

void SendCircuitCmdReq::__set_final(const bool val) {
  this->final = val;
__isset.final = true;
}
std::ostream& operator<<(std::ostream& out, const SendCircuitCmdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SendCircuitCmdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->circuit.read(iprot);
          this->__isset.circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->final);
          this->__isset.final = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SendCircuitCmdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SendCircuitCmdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.circuit) {
    xfer += oprot->writeFieldBegin("circuit", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->circuit.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.final) {
    xfer += oprot->writeFieldBegin("final", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->final);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SendCircuitCmdReq &a, SendCircuitCmdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.circuit, b.circuit);
  swap(a.final, b.final);
  swap(a.__isset, b.__isset);
}

SendCircuitCmdReq::SendCircuitCmdReq(const SendCircuitCmdReq& other99) {
  id = other99.id;
  circuit = other99.circuit;
  final = other99.final;
  __isset = other99.__isset;
}
SendCircuitCmdReq& SendCircuitCmdReq::operator=(const SendCircuitCmdReq& other100) {
  id = other100.id;
  circuit = other100.circuit;
  final = other100.final;
  __isset = other100.__isset;
  return *this;
}
void SendCircuitCmdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SendCircuitCmdReq(";
  out << "id=" << to_string(id);
  out << ", " << "circuit="; (__isset.circuit ? (out << to_string(circuit)) : (out << "<null>"));
  out << ", " << "final="; (__isset.final ? (out << to_string(final)) : (out << "<null>"));
  out << ")";
}


SendCircuitCmdResp::~SendCircuitCmdResp() noexcept {
}


void SendCircuitCmdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const SendCircuitCmdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SendCircuitCmdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SendCircuitCmdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SendCircuitCmdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SendCircuitCmdResp &a, SendCircuitCmdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

SendCircuitCmdResp::SendCircuitCmdResp(const SendCircuitCmdResp& other101) {
  base = other101.base;
}
SendCircuitCmdResp& SendCircuitCmdResp::operator=(const SendCircuitCmdResp& other102) {
  base = other102.base;
  return *this;
}
void SendCircuitCmdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SendCircuitCmdResp(";
  out << "base=" << to_string(base);
  out << ")";
}


CancelCmdReq::~CancelCmdReq() noexcept {
}


void CancelCmdReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const CancelCmdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CancelCmdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CancelCmdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CancelCmdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CancelCmdReq &a, CancelCmdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

CancelCmdReq::CancelCmdReq(const CancelCmdReq& other103) {
  id = other103.id;
}
CancelCmdReq& CancelCmdReq::operator=(const CancelCmdReq& other104) {
  id = other104.id;
  return *this;
}
void CancelCmdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CancelCmdReq(";
  out << "id=" << to_string(id);
  out << ")";
}


CancelCmdResp::~CancelCmdResp() noexcept {
}


void CancelCmdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const CancelCmdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CancelCmdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CancelCmdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CancelCmdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CancelCmdResp &a, CancelCmdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

CancelCmdResp::CancelCmdResp(const CancelCmdResp& other105) {
  base = other105.base;
}
CancelCmdResp& CancelCmdResp::operator=(const CancelCmdResp& other106) {
  base = other106.base;
  return *this;
}
void CancelCmdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CancelCmdResp(";
  out << "base=" << to_string(base);
  out << ")";
}


GetProbAmpReq::~GetProbAmpReq() noexcept {
}


void GetProbAmpReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetProbAmpReq::__set_index(const int64_t val) {
  this->index = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbAmpReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbAmpReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_index = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->index);
          isset_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbAmpReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbAmpReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbAmpReq &a, GetProbAmpReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.index, b.index);
}

GetProbAmpReq::GetProbAmpReq(const GetProbAmpReq& other107) {
  id = other107.id;
  index = other107.index;
}
GetProbAmpReq& GetProbAmpReq::operator=(const GetProbAmpReq& other108) {
  id = other108.id;
  index = other108.index;
  return *this;
}
void GetProbAmpReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbAmpReq(";
  out << "id=" << to_string(id);
  out << ", " << "index=" << to_string(index);
  out << ")";
}


GetProbAmpResp::~GetProbAmpResp() noexcept {
}


void GetProbAmpResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbAmpResp::__set_amp(const double val) {
  this->amp = val;
__isset.amp = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbAmpResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbAmpResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->amp);
          this->__isset.amp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbAmpResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbAmpResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.amp) {
    xfer += oprot->writeFieldBegin("amp", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->amp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbAmpResp &a, GetProbAmpResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.amp, b.amp);
  swap(a.__isset, b.__isset);
}

GetProbAmpResp::GetProbAmpResp(const GetProbAmpResp& other109) {
  base = other109.base;
  amp = other109.amp;
  __isset = other109.__isset;
}
GetProbAmpResp& GetProbAmpResp::operator=(const GetProbAmpResp& other110) {
  base = other110.base;
  amp = other110.amp;
  __isset = other110.__isset;
  return *this;
}
void GetProbAmpResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbAmpResp(";
  out << "base=" << to_string(base);
  out << ", " << "amp="; (__isset.amp ? (out << to_string(amp)) : (out << "<null>"));
  out << ")";
}


GetProbOfOutcomeReq::~GetProbOfOutcomeReq() noexcept {
}


void GetProbOfOutcomeReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetProbOfOutcomeReq::__set_qubit(const int32_t val) {
  this->qubit = val;
}

void GetProbOfOutcomeReq::__set_outcom(const int32_t val) {
  this->outcom = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfOutcomeReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfOutcomeReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubit = false;
  bool isset_outcom = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubit);
          isset_qubit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->outcom);
          isset_outcom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_outcom)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfOutcomeReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfOutcomeReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubit", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outcom", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->outcom);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfOutcomeReq &a, GetProbOfOutcomeReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubit, b.qubit);
  swap(a.outcom, b.outcom);
}

GetProbOfOutcomeReq::GetProbOfOutcomeReq(const GetProbOfOutcomeReq& other111) {
  id = other111.id;
  qubit = other111.qubit;
  outcom = other111.outcom;
}
GetProbOfOutcomeReq& GetProbOfOutcomeReq::operator=(const GetProbOfOutcomeReq& other112) {
  id = other112.id;
  qubit = other112.qubit;
  outcom = other112.outcom;
  return *this;
}
void GetProbOfOutcomeReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfOutcomeReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubit=" << to_string(qubit);
  out << ", " << "outcom=" << to_string(outcom);
  out << ")";
}


GetProbOfOutcomeResp::~GetProbOfOutcomeResp() noexcept {
}


void GetProbOfOutcomeResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbOfOutcomeResp::__set_pro_outcome(const double val) {
  this->pro_outcome = val;
__isset.pro_outcome = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfOutcomeResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfOutcomeResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pro_outcome);
          this->__isset.pro_outcome = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfOutcomeResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfOutcomeResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pro_outcome) {
    xfer += oprot->writeFieldBegin("pro_outcome", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->pro_outcome);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfOutcomeResp &a, GetProbOfOutcomeResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.pro_outcome, b.pro_outcome);
  swap(a.__isset, b.__isset);
}

GetProbOfOutcomeResp::GetProbOfOutcomeResp(const GetProbOfOutcomeResp& other113) {
  base = other113.base;
  pro_outcome = other113.pro_outcome;
  __isset = other113.__isset;
}
GetProbOfOutcomeResp& GetProbOfOutcomeResp::operator=(const GetProbOfOutcomeResp& other114) {
  base = other114.base;
  pro_outcome = other114.pro_outcome;
  __isset = other114.__isset;
  return *this;
}
void GetProbOfOutcomeResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfOutcomeResp(";
  out << "base=" << to_string(base);
  out << ", " << "pro_outcome="; (__isset.pro_outcome ? (out << to_string(pro_outcome)) : (out << "<null>"));
  out << ")";
}


GetProbOfAllOutcomReq::~GetProbOfAllOutcomReq() noexcept {
}


void GetProbOfAllOutcomReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetProbOfAllOutcomReq::__set_targets(const std::vector<int32_t> & val) {
  this->targets = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfAllOutcomReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfAllOutcomReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_targets = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size115;
            ::apache::thrift::protocol::TType _etype118;
            xfer += iprot->readListBegin(_etype118, _size115);
            this->targets.resize(_size115);
            uint32_t _i119;
            for (_i119 = 0; _i119 < _size115; ++_i119)
            {
              xfer += iprot->readI32(this->targets[_i119]);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfAllOutcomReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfAllOutcomReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targets.size()));
    std::vector<int32_t> ::const_iterator _iter120;
    for (_iter120 = this->targets.begin(); _iter120 != this->targets.end(); ++_iter120)
    {
      xfer += oprot->writeI32((*_iter120));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfAllOutcomReq &a, GetProbOfAllOutcomReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.targets, b.targets);
}

GetProbOfAllOutcomReq::GetProbOfAllOutcomReq(const GetProbOfAllOutcomReq& other121) {
  id = other121.id;
  targets = other121.targets;
}
GetProbOfAllOutcomReq& GetProbOfAllOutcomReq::operator=(const GetProbOfAllOutcomReq& other122) {
  id = other122.id;
  targets = other122.targets;
  return *this;
}
void GetProbOfAllOutcomReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfAllOutcomReq(";
  out << "id=" << to_string(id);
  out << ", " << "targets=" << to_string(targets);
  out << ")";
}


GetProbOfAllOutcomResp::~GetProbOfAllOutcomResp() noexcept {
}


void GetProbOfAllOutcomResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbOfAllOutcomResp::__set_pro_outcomes(const std::vector<double> & val) {
  this->pro_outcomes = val;
__isset.pro_outcomes = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbOfAllOutcomResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbOfAllOutcomResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pro_outcomes.clear();
            uint32_t _size123;
            ::apache::thrift::protocol::TType _etype126;
            xfer += iprot->readListBegin(_etype126, _size123);
            this->pro_outcomes.resize(_size123);
            uint32_t _i127;
            for (_i127 = 0; _i127 < _size123; ++_i127)
            {
              xfer += iprot->readDouble(this->pro_outcomes[_i127]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pro_outcomes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbOfAllOutcomResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbOfAllOutcomResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pro_outcomes) {
    xfer += oprot->writeFieldBegin("pro_outcomes", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->pro_outcomes.size()));
      std::vector<double> ::const_iterator _iter128;
      for (_iter128 = this->pro_outcomes.begin(); _iter128 != this->pro_outcomes.end(); ++_iter128)
      {
        xfer += oprot->writeDouble((*_iter128));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbOfAllOutcomResp &a, GetProbOfAllOutcomResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.pro_outcomes, b.pro_outcomes);
  swap(a.__isset, b.__isset);
}

GetProbOfAllOutcomResp::GetProbOfAllOutcomResp(const GetProbOfAllOutcomResp& other129) {
  base = other129.base;
  pro_outcomes = other129.pro_outcomes;
  __isset = other129.__isset;
}
GetProbOfAllOutcomResp& GetProbOfAllOutcomResp::operator=(const GetProbOfAllOutcomResp& other130) {
  base = other130.base;
  pro_outcomes = other130.pro_outcomes;
  __isset = other130.__isset;
  return *this;
}
void GetProbOfAllOutcomResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbOfAllOutcomResp(";
  out << "base=" << to_string(base);
  out << ", " << "pro_outcomes="; (__isset.pro_outcomes ? (out << to_string(pro_outcomes)) : (out << "<null>"));
  out << ")";
}


GetAllStateReq::~GetAllStateReq() noexcept {
}


void GetAllStateReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetAllStateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllStateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetAllStateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllStateReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllStateReq &a, GetAllStateReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetAllStateReq::GetAllStateReq(const GetAllStateReq& other131) {
  id = other131.id;
}
GetAllStateReq& GetAllStateReq::operator=(const GetAllStateReq& other132) {
  id = other132.id;
  return *this;
}
void GetAllStateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllStateReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetAllStateResp::~GetAllStateResp() noexcept {
}


void GetAllStateResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetAllStateResp::__set_all_state(const std::vector<std::string> & val) {
  this->all_state = val;
__isset.all_state = true;
}
std::ostream& operator<<(std::ostream& out, const GetAllStateResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllStateResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->all_state.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _etype136;
            xfer += iprot->readListBegin(_etype136, _size133);
            this->all_state.resize(_size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              xfer += iprot->readString(this->all_state[_i137]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.all_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetAllStateResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllStateResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.all_state) {
    xfer += oprot->writeFieldBegin("all_state", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->all_state.size()));
      std::vector<std::string> ::const_iterator _iter138;
      for (_iter138 = this->all_state.begin(); _iter138 != this->all_state.end(); ++_iter138)
      {
        xfer += oprot->writeString((*_iter138));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllStateResp &a, GetAllStateResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.all_state, b.all_state);
  swap(a.__isset, b.__isset);
}

GetAllStateResp::GetAllStateResp(const GetAllStateResp& other139) {
  base = other139.base;
  all_state = other139.all_state;
  __isset = other139.__isset;
}
GetAllStateResp& GetAllStateResp::operator=(const GetAllStateResp& other140) {
  base = other140.base;
  all_state = other140.all_state;
  __isset = other140.__isset;
  return *this;
}
void GetAllStateResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllStateResp(";
  out << "base=" << to_string(base);
  out << ", " << "all_state="; (__isset.all_state ? (out << to_string(all_state)) : (out << "<null>"));
  out << ")";
}


ApplyQFTReq::~ApplyQFTReq() noexcept {
}


void ApplyQFTReq::__set_id(const std::string& val) {
  this->id = val;
}

void ApplyQFTReq::__set_targets(const std::vector<int32_t> & val) {
  this->targets = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyQFTReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyQFTReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_targets = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size141;
            ::apache::thrift::protocol::TType _etype144;
            xfer += iprot->readListBegin(_etype144, _size141);
            this->targets.resize(_size141);
            uint32_t _i145;
            for (_i145 = 0; _i145 < _size141; ++_i145)
            {
              xfer += iprot->readI32(this->targets[_i145]);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyQFTReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyQFTReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targets.size()));
    std::vector<int32_t> ::const_iterator _iter146;
    for (_iter146 = this->targets.begin(); _iter146 != this->targets.end(); ++_iter146)
    {
      xfer += oprot->writeI32((*_iter146));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyQFTReq &a, ApplyQFTReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.targets, b.targets);
}

ApplyQFTReq::ApplyQFTReq(const ApplyQFTReq& other147) {
  id = other147.id;
  targets = other147.targets;
}
ApplyQFTReq& ApplyQFTReq::operator=(const ApplyQFTReq& other148) {
  id = other148.id;
  targets = other148.targets;
  return *this;
}
void ApplyQFTReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyQFTReq(";
  out << "id=" << to_string(id);
  out << ", " << "targets=" << to_string(targets);
  out << ")";
}


ApplyQFTResp::~ApplyQFTResp() noexcept {
}


void ApplyQFTResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyQFTResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyQFTResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyQFTResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyQFTResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyQFTResp &a, ApplyQFTResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

ApplyQFTResp::ApplyQFTResp(const ApplyQFTResp& other149) {
  base = other149.base;
}
ApplyQFTResp& ApplyQFTResp::operator=(const ApplyQFTResp& other150) {
  base = other150.base;
  return *this;
}
void ApplyQFTResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyQFTResp(";
  out << "base=" << to_string(base);
  out << ")";
}


ApplyFullQFTReq::~ApplyFullQFTReq() noexcept {
}


void ApplyFullQFTReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyFullQFTReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyFullQFTReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyFullQFTReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyFullQFTReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyFullQFTReq &a, ApplyFullQFTReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

ApplyFullQFTReq::ApplyFullQFTReq(const ApplyFullQFTReq& other151) {
  id = other151.id;
}
ApplyFullQFTReq& ApplyFullQFTReq::operator=(const ApplyFullQFTReq& other152) {
  id = other152.id;
  return *this;
}
void ApplyFullQFTReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyFullQFTReq(";
  out << "id=" << to_string(id);
  out << ")";
}


ApplyFullQFTResp::~ApplyFullQFTResp() noexcept {
}


void ApplyFullQFTResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const ApplyFullQFTResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ApplyFullQFTResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplyFullQFTResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplyFullQFTResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplyFullQFTResp &a, ApplyFullQFTResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

ApplyFullQFTResp::ApplyFullQFTResp(const ApplyFullQFTResp& other153) {
  base = other153.base;
}
ApplyFullQFTResp& ApplyFullQFTResp::operator=(const ApplyFullQFTResp& other154) {
  base = other154.base;
  return *this;
}
void ApplyFullQFTResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplyFullQFTResp(";
  out << "base=" << to_string(base);
  out << ")";
}


RunCircuitReq::~RunCircuitReq() noexcept {
}


void RunCircuitReq::__set_id(const std::string& val) {
  this->id = val;
}

void RunCircuitReq::__set_shots(const int32_t val) {
  this->shots = val;
}
std::ostream& operator<<(std::ostream& out, const RunCircuitReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RunCircuitReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_shots = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shots);
          isset_shots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_shots)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RunCircuitReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RunCircuitReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shots", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->shots);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RunCircuitReq &a, RunCircuitReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.shots, b.shots);
}

RunCircuitReq::RunCircuitReq(const RunCircuitReq& other155) {
  id = other155.id;
  shots = other155.shots;
}
RunCircuitReq& RunCircuitReq::operator=(const RunCircuitReq& other156) {
  id = other156.id;
  shots = other156.shots;
  return *this;
}
void RunCircuitReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RunCircuitReq(";
  out << "id=" << to_string(id);
  out << ", " << "shots=" << to_string(shots);
  out << ")";
}


RunCircuitResp::~RunCircuitResp() noexcept {
}


void RunCircuitResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void RunCircuitResp::__set_result(const Result& val) {
  this->result = val;
__isset.result = true;
}
std::ostream& operator<<(std::ostream& out, const RunCircuitResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RunCircuitResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RunCircuitResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RunCircuitResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.result) {
    xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->result.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RunCircuitResp &a, RunCircuitResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

RunCircuitResp::RunCircuitResp(const RunCircuitResp& other157) {
  base = other157.base;
  result = other157.result;
  __isset = other157.__isset;
}
RunCircuitResp& RunCircuitResp::operator=(const RunCircuitResp& other158) {
  base = other158.base;
  result = other158.result;
  __isset = other158.__isset;
  return *this;
}
void RunCircuitResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RunCircuitResp(";
  out << "base=" << to_string(base);
  out << ", " << "result="; (__isset.result ? (out << to_string(result)) : (out << "<null>"));
  out << ")";
}


GetExpecPauliProdReq::~GetExpecPauliProdReq() noexcept {
}


void GetExpecPauliProdReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetExpecPauliProdReq::__set_pauli_prod(const std::vector<PauliProdInfo> & val) {
  this->pauli_prod = val;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliProdReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliProdReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_pauli_prod = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pauli_prod.clear();
            uint32_t _size159;
            ::apache::thrift::protocol::TType _etype162;
            xfer += iprot->readListBegin(_etype162, _size159);
            this->pauli_prod.resize(_size159);
            uint32_t _i163;
            for (_i163 = 0; _i163 < _size159; ++_i163)
            {
              xfer += this->pauli_prod[_i163].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_pauli_prod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pauli_prod)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliProdReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliProdReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pauli_prod", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pauli_prod.size()));
    std::vector<PauliProdInfo> ::const_iterator _iter164;
    for (_iter164 = this->pauli_prod.begin(); _iter164 != this->pauli_prod.end(); ++_iter164)
    {
      xfer += (*_iter164).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliProdReq &a, GetExpecPauliProdReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.pauli_prod, b.pauli_prod);
}

GetExpecPauliProdReq::GetExpecPauliProdReq(const GetExpecPauliProdReq& other165) {
  id = other165.id;
  pauli_prod = other165.pauli_prod;
}
GetExpecPauliProdReq& GetExpecPauliProdReq::operator=(const GetExpecPauliProdReq& other166) {
  id = other166.id;
  pauli_prod = other166.pauli_prod;
  return *this;
}
void GetExpecPauliProdReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliProdReq(";
  out << "id=" << to_string(id);
  out << ", " << "pauli_prod=" << to_string(pauli_prod);
  out << ")";
}


GetExpecPauliProdResp::~GetExpecPauliProdResp() noexcept {
}


void GetExpecPauliProdResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetExpecPauliProdResp::__set_expect(const double val) {
  this->expect = val;
__isset.expect = true;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliProdResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliProdResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->expect);
          this->__isset.expect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliProdResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliProdResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.expect) {
    xfer += oprot->writeFieldBegin("expect", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->expect);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliProdResp &a, GetExpecPauliProdResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.expect, b.expect);
  swap(a.__isset, b.__isset);
}

GetExpecPauliProdResp::GetExpecPauliProdResp(const GetExpecPauliProdResp& other167) {
  base = other167.base;
  expect = other167.expect;
  __isset = other167.__isset;
}
GetExpecPauliProdResp& GetExpecPauliProdResp::operator=(const GetExpecPauliProdResp& other168) {
  base = other168.base;
  expect = other168.expect;
  __isset = other168.__isset;
  return *this;
}
void GetExpecPauliProdResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliProdResp(";
  out << "base=" << to_string(base);
  out << ", " << "expect="; (__isset.expect ? (out << to_string(expect)) : (out << "<null>"));
  out << ")";
}


PauliProdInfo::~PauliProdInfo() noexcept {
}


void PauliProdInfo::__set_oper_type(const PauliOperType::type val) {
  this->oper_type = val;
}

void PauliProdInfo::__set_target(const int32_t val) {
  this->target = val;
}
std::ostream& operator<<(std::ostream& out, const PauliProdInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PauliProdInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_oper_type = false;
  bool isset_target = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast169;
          xfer += iprot->readI32(ecast169);
          this->oper_type = static_cast<PauliOperType::type>(ecast169);
          isset_oper_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->target);
          isset_target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_oper_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PauliProdInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PauliProdInfo");

  xfer += oprot->writeFieldBegin("oper_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->oper_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PauliProdInfo &a, PauliProdInfo &b) {
  using ::std::swap;
  swap(a.oper_type, b.oper_type);
  swap(a.target, b.target);
}

PauliProdInfo::PauliProdInfo(const PauliProdInfo& other170) noexcept {
  oper_type = other170.oper_type;
  target = other170.target;
}
PauliProdInfo& PauliProdInfo::operator=(const PauliProdInfo& other171) noexcept {
  oper_type = other171.oper_type;
  target = other171.target;
  return *this;
}
void PauliProdInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PauliProdInfo(";
  out << "oper_type=" << to_string(oper_type);
  out << ", " << "target=" << to_string(target);
  out << ")";
}


GetExpecPauliSumReq::~GetExpecPauliSumReq() noexcept {
}


void GetExpecPauliSumReq::__set_id(const std::string& val) {
  this->id = val;
}

void GetExpecPauliSumReq::__set_oper_type_list(const std::vector<PauliOperType::type> & val) {
  this->oper_type_list = val;
}

void GetExpecPauliSumReq::__set_term_coeff_list(const std::vector<double> & val) {
  this->term_coeff_list = val;
__isset.term_coeff_list = true;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliSumReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliSumReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_oper_type_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->oper_type_list.clear();
            uint32_t _size172;
            ::apache::thrift::protocol::TType _etype175;
            xfer += iprot->readListBegin(_etype175, _size172);
            this->oper_type_list.resize(_size172);
            uint32_t _i176;
            for (_i176 = 0; _i176 < _size172; ++_i176)
            {
              int32_t ecast177;
              xfer += iprot->readI32(ecast177);
              this->oper_type_list[_i176] = static_cast<PauliOperType::type>(ecast177);
            }
            xfer += iprot->readListEnd();
          }
          isset_oper_type_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->term_coeff_list.clear();
            uint32_t _size178;
            ::apache::thrift::protocol::TType _etype181;
            xfer += iprot->readListBegin(_etype181, _size178);
            this->term_coeff_list.resize(_size178);
            uint32_t _i182;
            for (_i182 = 0; _i182 < _size178; ++_i182)
            {
              xfer += iprot->readDouble(this->term_coeff_list[_i182]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.term_coeff_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_oper_type_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliSumReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliSumReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oper_type_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->oper_type_list.size()));
    std::vector<PauliOperType::type> ::const_iterator _iter183;
    for (_iter183 = this->oper_type_list.begin(); _iter183 != this->oper_type_list.end(); ++_iter183)
    {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter183)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.term_coeff_list) {
    xfer += oprot->writeFieldBegin("term_coeff_list", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->term_coeff_list.size()));
      std::vector<double> ::const_iterator _iter184;
      for (_iter184 = this->term_coeff_list.begin(); _iter184 != this->term_coeff_list.end(); ++_iter184)
      {
        xfer += oprot->writeDouble((*_iter184));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliSumReq &a, GetExpecPauliSumReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.oper_type_list, b.oper_type_list);
  swap(a.term_coeff_list, b.term_coeff_list);
  swap(a.__isset, b.__isset);
}

GetExpecPauliSumReq::GetExpecPauliSumReq(const GetExpecPauliSumReq& other185) {
  id = other185.id;
  oper_type_list = other185.oper_type_list;
  term_coeff_list = other185.term_coeff_list;
  __isset = other185.__isset;
}
GetExpecPauliSumReq& GetExpecPauliSumReq::operator=(const GetExpecPauliSumReq& other186) {
  id = other186.id;
  oper_type_list = other186.oper_type_list;
  term_coeff_list = other186.term_coeff_list;
  __isset = other186.__isset;
  return *this;
}
void GetExpecPauliSumReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliSumReq(";
  out << "id=" << to_string(id);
  out << ", " << "oper_type_list=" << to_string(oper_type_list);
  out << ", " << "term_coeff_list="; (__isset.term_coeff_list ? (out << to_string(term_coeff_list)) : (out << "<null>"));
  out << ")";
}


GetExpecPauliSumResp::~GetExpecPauliSumResp() noexcept {
}


void GetExpecPauliSumResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetExpecPauliSumResp::__set_expect(const double val) {
  this->expect = val;
__isset.expect = true;
}
std::ostream& operator<<(std::ostream& out, const GetExpecPauliSumResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetExpecPauliSumResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->expect);
          this->__isset.expect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetExpecPauliSumResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetExpecPauliSumResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.expect) {
    xfer += oprot->writeFieldBegin("expect", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->expect);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetExpecPauliSumResp &a, GetExpecPauliSumResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.expect, b.expect);
  swap(a.__isset, b.__isset);
}

GetExpecPauliSumResp::GetExpecPauliSumResp(const GetExpecPauliSumResp& other187) {
  base = other187.base;
  expect = other187.expect;
  __isset = other187.__isset;
}
GetExpecPauliSumResp& GetExpecPauliSumResp::operator=(const GetExpecPauliSumResp& other188) {
  base = other188.base;
  expect = other188.expect;
  __isset = other188.__isset;
  return *this;
}
void GetExpecPauliSumResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetExpecPauliSumResp(";
  out << "base=" << to_string(base);
  out << ", " << "expect="; (__isset.expect ? (out << to_string(expect)) : (out << "<null>"));
  out << ")";
}


MeasureQubitsReq::~MeasureQubitsReq() noexcept {
}


void MeasureQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void MeasureQubitsReq::__set_qubits(const std::vector<int32_t> & val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->qubits.clear();
            uint32_t _size189;
            ::apache::thrift::protocol::TType _etype192;
            xfer += iprot->readListBegin(_etype192, _size189);
            this->qubits.resize(_size189);
            uint32_t _i193;
            for (_i193 = 0; _i193 < _size189; ++_i193)
            {
              xfer += iprot->readI32(this->qubits[_i193]);
            }
            xfer += iprot->readListEnd();
          }
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->qubits.size()));
    std::vector<int32_t> ::const_iterator _iter194;
    for (_iter194 = this->qubits.begin(); _iter194 != this->qubits.end(); ++_iter194)
    {
      xfer += oprot->writeI32((*_iter194));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureQubitsReq &a, MeasureQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

MeasureQubitsReq::MeasureQubitsReq(const MeasureQubitsReq& other195) {
  id = other195.id;
  qubits = other195.qubits;
}
MeasureQubitsReq& MeasureQubitsReq::operator=(const MeasureQubitsReq& other196) {
  id = other196.id;
  qubits = other196.qubits;
  return *this;
}
void MeasureQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


MeasureQubitsResp::~MeasureQubitsResp() noexcept {
}


void MeasureQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void MeasureQubitsResp::__set_results(const std::vector<MeasureResult> & val) {
  this->results = val;
__isset.results = true;
}

void MeasureQubitsResp::__set_outcomes(const std::vector<Outcome> & val) {
  this->outcomes = val;
}
std::ostream& operator<<(std::ostream& out, const MeasureQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MeasureQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;
  bool isset_outcomes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size197;
            ::apache::thrift::protocol::TType _etype200;
            xfer += iprot->readListBegin(_etype200, _size197);
            this->results.resize(_size197);
            uint32_t _i201;
            for (_i201 = 0; _i201 < _size197; ++_i201)
            {
              xfer += this->results[_i201].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outcomes.clear();
            uint32_t _size202;
            ::apache::thrift::protocol::TType _etype205;
            xfer += iprot->readListBegin(_etype205, _size202);
            this->outcomes.resize(_size202);
            uint32_t _i206;
            for (_i206 = 0; _i206 < _size202; ++_i206)
            {
              xfer += this->outcomes[_i206].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_outcomes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_outcomes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MeasureQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.results) {
    xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
      std::vector<MeasureResult> ::const_iterator _iter207;
      for (_iter207 = this->results.begin(); _iter207 != this->results.end(); ++_iter207)
      {
        xfer += (*_iter207).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("outcomes", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outcomes.size()));
    std::vector<Outcome> ::const_iterator _iter208;
    for (_iter208 = this->outcomes.begin(); _iter208 != this->outcomes.end(); ++_iter208)
    {
      xfer += (*_iter208).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureQubitsResp &a, MeasureQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.results, b.results);
  swap(a.outcomes, b.outcomes);
  swap(a.__isset, b.__isset);
}

MeasureQubitsResp::MeasureQubitsResp(const MeasureQubitsResp& other209) {
  base = other209.base;
  results = other209.results;
  outcomes = other209.outcomes;
  __isset = other209.__isset;
}
MeasureQubitsResp& MeasureQubitsResp::operator=(const MeasureQubitsResp& other210) {
  base = other210.base;
  results = other210.results;
  outcomes = other210.outcomes;
  __isset = other210.__isset;
  return *this;
}
void MeasureQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureQubitsResp(";
  out << "base=" << to_string(base);
  out << ", " << "results="; (__isset.results ? (out << to_string(results)) : (out << "<null>"));
  out << ", " << "outcomes=" << to_string(outcomes);
  out << ")";
}


GateMatrix::~GateMatrix() noexcept {
}


void GateMatrix::__set_name(const std::string& val) {
  this->name = val;
}

void GateMatrix::__set_qubits(const int32_t val) {
  this->qubits = val;
}

void GateMatrix::__set_matrix(const std::vector<double> & val) {
  this->matrix = val;
}
std::ostream& operator<<(std::ostream& out, const GateMatrix& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GateMatrix::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_qubits = false;
  bool isset_matrix = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->matrix.clear();
            uint32_t _size211;
            ::apache::thrift::protocol::TType _etype214;
            xfer += iprot->readListBegin(_etype214, _size211);
            this->matrix.resize(_size211);
            uint32_t _i215;
            for (_i215 = 0; _i215 < _size211; ++_i215)
            {
              xfer += iprot->readDouble(this->matrix[_i215]);
            }
            xfer += iprot->readListEnd();
          }
          isset_matrix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_matrix)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GateMatrix::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GateMatrix");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matrix", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->matrix.size()));
    std::vector<double> ::const_iterator _iter216;
    for (_iter216 = this->matrix.begin(); _iter216 != this->matrix.end(); ++_iter216)
    {
      xfer += oprot->writeDouble((*_iter216));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GateMatrix &a, GateMatrix &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.qubits, b.qubits);
  swap(a.matrix, b.matrix);
}

GateMatrix::GateMatrix(const GateMatrix& other217) {
  name = other217.name;
  qubits = other217.qubits;
  matrix = other217.matrix;
}
GateMatrix& GateMatrix::operator=(const GateMatrix& other218) {
  name = other218.name;
  qubits = other218.qubits;
  matrix = other218.matrix;
  return *this;
}
void GateMatrix::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GateMatrix(";
  out << "name=" << to_string(name);
  out << ", " << "qubits=" << to_string(qubits);
  out << ", " << "matrix=" << to_string(matrix);
  out << ")";
}


AddCustomGateByMatrixReq::~AddCustomGateByMatrixReq() noexcept {
}


void AddCustomGateByMatrixReq::__set_id(const std::string& val) {
  this->id = val;
}

void AddCustomGateByMatrixReq::__set_gate(const GateMatrix& val) {
  this->gate = val;
}
std::ostream& operator<<(std::ostream& out, const AddCustomGateByMatrixReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddCustomGateByMatrixReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_gate = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gate.read(iprot);
          isset_gate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddCustomGateByMatrixReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddCustomGateByMatrixReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gate", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->gate.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddCustomGateByMatrixReq &a, AddCustomGateByMatrixReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.gate, b.gate);
}

AddCustomGateByMatrixReq::AddCustomGateByMatrixReq(const AddCustomGateByMatrixReq& other219) {
  id = other219.id;
  gate = other219.gate;
}
AddCustomGateByMatrixReq& AddCustomGateByMatrixReq::operator=(const AddCustomGateByMatrixReq& other220) {
  id = other220.id;
  gate = other220.gate;
  return *this;
}
void AddCustomGateByMatrixReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddCustomGateByMatrixReq(";
  out << "id=" << to_string(id);
  out << ", " << "gate=" << to_string(gate);
  out << ")";
}


AddCustomGateByMatrixResp::~AddCustomGateByMatrixResp() noexcept {
}


void AddCustomGateByMatrixResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AddCustomGateByMatrixResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddCustomGateByMatrixResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddCustomGateByMatrixResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddCustomGateByMatrixResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddCustomGateByMatrixResp &a, AddCustomGateByMatrixResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AddCustomGateByMatrixResp::AddCustomGateByMatrixResp(const AddCustomGateByMatrixResp& other221) {
  base = other221.base;
}
AddCustomGateByMatrixResp& AddCustomGateByMatrixResp::operator=(const AddCustomGateByMatrixResp& other222) {
  base = other222.base;
  return *this;
}
void AddCustomGateByMatrixResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddCustomGateByMatrixResp(";
  out << "base=" << to_string(base);
  out << ")";
}


SubCircuit::~SubCircuit() noexcept {
}


void SubCircuit::__set_name(const std::string& val) {
  this->name = val;
}

void SubCircuit::__set_circuit(const Circuit& val) {
  this->circuit = val;
}
std::ostream& operator<<(std::ostream& out, const SubCircuit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SubCircuit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_circuit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->circuit.read(iprot);
          isset_circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_circuit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SubCircuit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SubCircuit");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("circuit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->circuit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SubCircuit &a, SubCircuit &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.circuit, b.circuit);
}

SubCircuit::SubCircuit(const SubCircuit& other223) {
  name = other223.name;
  circuit = other223.circuit;
}
SubCircuit& SubCircuit::operator=(const SubCircuit& other224) {
  name = other224.name;
  circuit = other224.circuit;
  return *this;
}
void SubCircuit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SubCircuit(";
  out << "name=" << to_string(name);
  out << ", " << "circuit=" << to_string(circuit);
  out << ")";
}


AddSubCircuitReq::~AddSubCircuitReq() noexcept {
}


void AddSubCircuitReq::__set_id(const std::string& val) {
  this->id = val;
}

void AddSubCircuitReq::__set_sub_circuit(const SubCircuit& val) {
  this->sub_circuit = val;
}
std::ostream& operator<<(std::ostream& out, const AddSubCircuitReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddSubCircuitReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_sub_circuit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sub_circuit.read(iprot);
          isset_sub_circuit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sub_circuit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddSubCircuitReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddSubCircuitReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sub_circuit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->sub_circuit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddSubCircuitReq &a, AddSubCircuitReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.sub_circuit, b.sub_circuit);
}

AddSubCircuitReq::AddSubCircuitReq(const AddSubCircuitReq& other225) {
  id = other225.id;
  sub_circuit = other225.sub_circuit;
}
AddSubCircuitReq& AddSubCircuitReq::operator=(const AddSubCircuitReq& other226) {
  id = other226.id;
  sub_circuit = other226.sub_circuit;
  return *this;
}
void AddSubCircuitReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddSubCircuitReq(";
  out << "id=" << to_string(id);
  out << ", " << "sub_circuit=" << to_string(sub_circuit);
  out << ")";
}


AddSubCircuitResp::~AddSubCircuitResp() noexcept {
}


void AddSubCircuitResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AddSubCircuitResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddSubCircuitResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddSubCircuitResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddSubCircuitResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddSubCircuitResp &a, AddSubCircuitResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AddSubCircuitResp::AddSubCircuitResp(const AddSubCircuitResp& other227) {
  base = other227.base;
}
AddSubCircuitResp& AddSubCircuitResp::operator=(const AddSubCircuitResp& other228) {
  base = other228.base;
  return *this;
}
void AddSubCircuitResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddSubCircuitResp(";
  out << "base=" << to_string(base);
  out << ")";
}


AppendQubitsReq::~AppendQubitsReq() noexcept {
}


void AppendQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void AppendQubitsReq::__set_qubits(const int32_t val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const AppendQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppendQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppendQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppendQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppendQubitsReq &a, AppendQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

AppendQubitsReq::AppendQubitsReq(const AppendQubitsReq& other229) {
  id = other229.id;
  qubits = other229.qubits;
}
AppendQubitsReq& AppendQubitsReq::operator=(const AppendQubitsReq& other230) {
  id = other230.id;
  qubits = other230.qubits;
  return *this;
}
void AppendQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppendQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


AppendQubitsResp::~AppendQubitsResp() noexcept {
}


void AppendQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const AppendQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppendQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppendQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppendQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppendQubitsResp &a, AppendQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

AppendQubitsResp::AppendQubitsResp(const AppendQubitsResp& other231) {
  base = other231.base;
}
AppendQubitsResp& AppendQubitsResp::operator=(const AppendQubitsResp& other232) {
  base = other232.base;
  return *this;
}
void AppendQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppendQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


ResetQubitsReq::~ResetQubitsReq() noexcept {
}


void ResetQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}

void ResetQubitsReq::__set_qubits(const std::vector<int32_t> & val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const ResetQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResetQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->qubits.clear();
            uint32_t _size233;
            ::apache::thrift::protocol::TType _etype236;
            xfer += iprot->readListBegin(_etype236, _size233);
            this->qubits.resize(_size233);
            uint32_t _i237;
            for (_i237 = 0; _i237 < _size233; ++_i237)
            {
              xfer += iprot->readI32(this->qubits[_i237]);
            }
            xfer += iprot->readListEnd();
          }
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResetQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResetQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->qubits.size()));
    std::vector<int32_t> ::const_iterator _iter238;
    for (_iter238 = this->qubits.begin(); _iter238 != this->qubits.end(); ++_iter238)
    {
      xfer += oprot->writeI32((*_iter238));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResetQubitsReq &a, ResetQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.qubits, b.qubits);
}

ResetQubitsReq::ResetQubitsReq(const ResetQubitsReq& other239) {
  id = other239.id;
  qubits = other239.qubits;
}
ResetQubitsReq& ResetQubitsReq::operator=(const ResetQubitsReq& other240) {
  id = other240.id;
  qubits = other240.qubits;
  return *this;
}
void ResetQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResetQubitsReq(";
  out << "id=" << to_string(id);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


ResetQubitsResp::~ResetQubitsResp() noexcept {
}


void ResetQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const ResetQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResetQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResetQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResetQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResetQubitsResp &a, ResetQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

ResetQubitsResp::ResetQubitsResp(const ResetQubitsResp& other241) {
  base = other241.base;
}
ResetQubitsResp& ResetQubitsResp::operator=(const ResetQubitsResp& other242) {
  base = other242.base;
  return *this;
}
void ResetQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResetQubitsResp(";
  out << "base=" << to_string(base);
  out << ")";
}


GetStateOfAllQubitsReq::~GetStateOfAllQubitsReq() noexcept {
}


void GetStateOfAllQubitsReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetStateOfAllQubitsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetStateOfAllQubitsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetStateOfAllQubitsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetStateOfAllQubitsReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetStateOfAllQubitsReq &a, GetStateOfAllQubitsReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetStateOfAllQubitsReq::GetStateOfAllQubitsReq(const GetStateOfAllQubitsReq& other243) {
  id = other243.id;
}
GetStateOfAllQubitsReq& GetStateOfAllQubitsReq::operator=(const GetStateOfAllQubitsReq& other244) {
  id = other244.id;
  return *this;
}
void GetStateOfAllQubitsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetStateOfAllQubitsReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetStateOfAllQubitsResp::~GetStateOfAllQubitsResp() noexcept {
}


void GetStateOfAllQubitsResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetStateOfAllQubitsResp::__set_state_vector(const std::vector<double> & val) {
  this->state_vector = val;
}
std::ostream& operator<<(std::ostream& out, const GetStateOfAllQubitsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetStateOfAllQubitsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->state_vector.clear();
            uint32_t _size245;
            ::apache::thrift::protocol::TType _etype248;
            xfer += iprot->readListBegin(_etype248, _size245);
            this->state_vector.resize(_size245);
            uint32_t _i249;
            for (_i249 = 0; _i249 < _size245; ++_i249)
            {
              xfer += iprot->readDouble(this->state_vector[_i249]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.state_vector = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetStateOfAllQubitsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetStateOfAllQubitsResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state_vector", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->state_vector.size()));
    std::vector<double> ::const_iterator _iter250;
    for (_iter250 = this->state_vector.begin(); _iter250 != this->state_vector.end(); ++_iter250)
    {
      xfer += oprot->writeDouble((*_iter250));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetStateOfAllQubitsResp &a, GetStateOfAllQubitsResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.state_vector, b.state_vector);
  swap(a.__isset, b.__isset);
}

GetStateOfAllQubitsResp::GetStateOfAllQubitsResp(const GetStateOfAllQubitsResp& other251) {
  base = other251.base;
  state_vector = other251.state_vector;
  __isset = other251.__isset;
}
GetStateOfAllQubitsResp& GetStateOfAllQubitsResp::operator=(const GetStateOfAllQubitsResp& other252) {
  base = other252.base;
  state_vector = other252.state_vector;
  __isset = other252.__isset;
  return *this;
}
void GetStateOfAllQubitsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetStateOfAllQubitsResp(";
  out << "base=" << to_string(base);
  out << ", " << "state_vector=" << to_string(state_vector);
  out << ")";
}


GetProbabilitiesReq::~GetProbabilitiesReq() noexcept {
}


void GetProbabilitiesReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetProbabilitiesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbabilitiesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbabilitiesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbabilitiesReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbabilitiesReq &a, GetProbabilitiesReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetProbabilitiesReq::GetProbabilitiesReq(const GetProbabilitiesReq& other253) {
  id = other253.id;
}
GetProbabilitiesReq& GetProbabilitiesReq::operator=(const GetProbabilitiesReq& other254) {
  id = other254.id;
  return *this;
}
void GetProbabilitiesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbabilitiesReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetProbabilitiesResp::~GetProbabilitiesResp() noexcept {
}


void GetProbabilitiesResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetProbabilitiesResp::__set_probabilities(const std::vector<double> & val) {
  this->probabilities = val;
__isset.probabilities = true;
}
std::ostream& operator<<(std::ostream& out, const GetProbabilitiesResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetProbabilitiesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->probabilities.clear();
            uint32_t _size255;
            ::apache::thrift::protocol::TType _etype258;
            xfer += iprot->readListBegin(_etype258, _size255);
            this->probabilities.resize(_size255);
            uint32_t _i259;
            for (_i259 = 0; _i259 < _size255; ++_i259)
            {
              xfer += iprot->readDouble(this->probabilities[_i259]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.probabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetProbabilitiesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetProbabilitiesResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.probabilities) {
    xfer += oprot->writeFieldBegin("probabilities", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->probabilities.size()));
      std::vector<double> ::const_iterator _iter260;
      for (_iter260 = this->probabilities.begin(); _iter260 != this->probabilities.end(); ++_iter260)
      {
        xfer += oprot->writeDouble((*_iter260));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetProbabilitiesResp &a, GetProbabilitiesResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.probabilities, b.probabilities);
  swap(a.__isset, b.__isset);
}

GetProbabilitiesResp::GetProbabilitiesResp(const GetProbabilitiesResp& other261) {
  base = other261.base;
  probabilities = other261.probabilities;
  __isset = other261.__isset;
}
GetProbabilitiesResp& GetProbabilitiesResp::operator=(const GetProbabilitiesResp& other262) {
  base = other262.base;
  probabilities = other262.probabilities;
  __isset = other262.__isset;
  return *this;
}
void GetProbabilitiesResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetProbabilitiesResp(";
  out << "base=" << to_string(base);
  out << ", " << "probabilities="; (__isset.probabilities ? (out << to_string(probabilities)) : (out << "<null>"));
  out << ")";
}


GetTaskInfoReq::~GetTaskInfoReq() noexcept {
}


void GetTaskInfoReq::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const GetTaskInfoReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTaskInfoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTaskInfoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTaskInfoReq");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTaskInfoReq &a, GetTaskInfoReq &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

GetTaskInfoReq::GetTaskInfoReq(const GetTaskInfoReq& other221) {
  id = other221.id;
}
GetTaskInfoReq& GetTaskInfoReq::operator=(const GetTaskInfoReq& other222) {
  id = other222.id;
  return *this;
}
void GetTaskInfoReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTaskInfoReq(";
  out << "id=" << to_string(id);
  out << ")";
}


GetTaskInfoResp::~GetTaskInfoResp() noexcept {
}


void GetTaskInfoResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}

void GetTaskInfoResp::__set_state(const int32_t val) {
  this->state = val;
}
std::ostream& operator<<(std::ostream& out, const GetTaskInfoResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTaskInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->state);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTaskInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTaskInfoResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTaskInfoResp &a, GetTaskInfoResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.state, b.state);
}

GetTaskInfoResp::GetTaskInfoResp(const GetTaskInfoResp& other223) {
  base = other223.base;
  state = other223.state;
}
GetTaskInfoResp& GetTaskInfoResp::operator=(const GetTaskInfoResp& other224) {
  base = other224.base;
  state = other224.state;
  return *this;
}
void GetTaskInfoResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTaskInfoResp(";
  out << "base=" << to_string(base);
  out << ", " << "state=" << to_string(state);
  out << ")";
}


