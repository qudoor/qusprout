/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef resource_TYPES_H
#define resource_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>
#include "ecode_types.h"




struct GpuInfoType {
  enum type {
    GpuType_Default = 0,
    GpuType_Nvidia = 1
  };
};

extern const std::map<int, const char*> _GpuInfoType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const GpuInfoType::type& val);

std::string to_string(const GpuInfoType::type& val);

class RpcConnectInfo;

class MachineInfo;

class ResourceInfo;

class DeviceResourceDetail;

class RegisterReq;

class RegisterResp;

class UnRegisterReq;

class UnRegisterResp;

class HeartbeatReq;

class HeartbeatResp;


class RpcConnectInfo : public virtual ::apache::thrift::TBase {
 public:

  RpcConnectInfo(const RpcConnectInfo&);
  RpcConnectInfo& operator=(const RpcConnectInfo&);
  RpcConnectInfo() noexcept
                 : addr(),
                   port(0) {
  }

  virtual ~RpcConnectInfo() noexcept;
  std::string addr;
  int32_t port;

  void __set_addr(const std::string& val);

  void __set_port(const int32_t val);

  bool operator == (const RpcConnectInfo & rhs) const
  {
    if (!(addr == rhs.addr))
      return false;
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const RpcConnectInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RpcConnectInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RpcConnectInfo &a, RpcConnectInfo &b);

std::ostream& operator<<(std::ostream& out, const RpcConnectInfo& obj);

typedef struct _MachineInfo__isset {
  _MachineInfo__isset() : sys_name(false), sys_release(false), sys_version(false), sys_machine(false) {}
  bool sys_name :1;
  bool sys_release :1;
  bool sys_version :1;
  bool sys_machine :1;
} _MachineInfo__isset;

class MachineInfo : public virtual ::apache::thrift::TBase {
 public:

  MachineInfo(const MachineInfo&);
  MachineInfo& operator=(const MachineInfo&);
  MachineInfo() noexcept
              : addr(),
                sys_name(),
                sys_release(),
                sys_version(),
                sys_machine() {
  }

  virtual ~MachineInfo() noexcept;
  std::string addr;
  std::string sys_name;
  std::string sys_release;
  std::string sys_version;
  std::string sys_machine;

  _MachineInfo__isset __isset;

  void __set_addr(const std::string& val);

  void __set_sys_name(const std::string& val);

  void __set_sys_release(const std::string& val);

  void __set_sys_version(const std::string& val);

  void __set_sys_machine(const std::string& val);

  bool operator == (const MachineInfo & rhs) const
  {
    if (!(addr == rhs.addr))
      return false;
    if (__isset.sys_name != rhs.__isset.sys_name)
      return false;
    else if (__isset.sys_name && !(sys_name == rhs.sys_name))
      return false;
    if (__isset.sys_release != rhs.__isset.sys_release)
      return false;
    else if (__isset.sys_release && !(sys_release == rhs.sys_release))
      return false;
    if (__isset.sys_version != rhs.__isset.sys_version)
      return false;
    else if (__isset.sys_version && !(sys_version == rhs.sys_version))
      return false;
    if (__isset.sys_machine != rhs.__isset.sys_machine)
      return false;
    else if (__isset.sys_machine && !(sys_machine == rhs.sys_machine))
      return false;
    return true;
  }
  bool operator != (const MachineInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MachineInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(MachineInfo &a, MachineInfo &b);

std::ostream& operator<<(std::ostream& out, const MachineInfo& obj);

typedef struct _ResourceInfo__isset {
  _ResourceInfo__isset() : gpu_type(false), gpu_total_memory(false) {}
  bool gpu_type :1;
  bool gpu_total_memory :1;
} _ResourceInfo__isset;

class ResourceInfo : public virtual ::apache::thrift::TBase {
 public:

  ResourceInfo(const ResourceInfo&) noexcept;
  ResourceInfo& operator=(const ResourceInfo&) noexcept;
  ResourceInfo() noexcept
               : cpu_total_memory(0),
                 cpu_free_memory(0),
                 gpu_type(static_cast<GpuInfoType::type>(0)),
                 gpu_total_memory(0) {
  }

  virtual ~ResourceInfo() noexcept;
  int64_t cpu_total_memory;
  int64_t cpu_free_memory;
  /**
   * 
   * @see GpuInfoType
   */
  GpuInfoType::type gpu_type;
  int64_t gpu_total_memory;

  _ResourceInfo__isset __isset;

  void __set_cpu_total_memory(const int64_t val);

  void __set_cpu_free_memory(const int64_t val);

  void __set_gpu_type(const GpuInfoType::type val);

  void __set_gpu_total_memory(const int64_t val);

  bool operator == (const ResourceInfo & rhs) const
  {
    if (!(cpu_total_memory == rhs.cpu_total_memory))
      return false;
    if (!(cpu_free_memory == rhs.cpu_free_memory))
      return false;
    if (__isset.gpu_type != rhs.__isset.gpu_type)
      return false;
    else if (__isset.gpu_type && !(gpu_type == rhs.gpu_type))
      return false;
    if (__isset.gpu_total_memory != rhs.__isset.gpu_total_memory)
      return false;
    else if (__isset.gpu_total_memory && !(gpu_total_memory == rhs.gpu_total_memory))
      return false;
    return true;
  }
  bool operator != (const ResourceInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResourceInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ResourceInfo &a, ResourceInfo &b);

std::ostream& operator<<(std::ostream& out, const ResourceInfo& obj);


class DeviceResourceDetail : public virtual ::apache::thrift::TBase {
 public:

  DeviceResourceDetail(const DeviceResourceDetail&);
  DeviceResourceDetail& operator=(const DeviceResourceDetail&);
  DeviceResourceDetail() noexcept {
  }

  virtual ~DeviceResourceDetail() noexcept;
  MachineInfo machine;
  ResourceInfo resource;

  void __set_machine(const MachineInfo& val);

  void __set_resource(const ResourceInfo& val);

  bool operator == (const DeviceResourceDetail & rhs) const
  {
    if (!(machine == rhs.machine))
      return false;
    if (!(resource == rhs.resource))
      return false;
    return true;
  }
  bool operator != (const DeviceResourceDetail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DeviceResourceDetail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DeviceResourceDetail &a, DeviceResourceDetail &b);

std::ostream& operator<<(std::ostream& out, const DeviceResourceDetail& obj);


class RegisterReq : public virtual ::apache::thrift::TBase {
 public:

  RegisterReq(const RegisterReq&);
  RegisterReq& operator=(const RegisterReq&);
  RegisterReq() noexcept
              : resource_id() {
  }

  virtual ~RegisterReq() noexcept;
  std::string resource_id;
  RpcConnectInfo rpc;
  DeviceResourceDetail device;

  void __set_resource_id(const std::string& val);

  void __set_rpc(const RpcConnectInfo& val);

  void __set_device(const DeviceResourceDetail& val);

  bool operator == (const RegisterReq & rhs) const
  {
    if (!(resource_id == rhs.resource_id))
      return false;
    if (!(rpc == rhs.rpc))
      return false;
    if (!(device == rhs.device))
      return false;
    return true;
  }
  bool operator != (const RegisterReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RegisterReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RegisterReq &a, RegisterReq &b);

std::ostream& operator<<(std::ostream& out, const RegisterReq& obj);


class RegisterResp : public virtual ::apache::thrift::TBase {
 public:

  RegisterResp(const RegisterResp&);
  RegisterResp& operator=(const RegisterResp&);
  RegisterResp() noexcept {
  }

  virtual ~RegisterResp() noexcept;
   ::BaseCode base;

  void __set_base(const  ::BaseCode& val);

  bool operator == (const RegisterResp & rhs) const
  {
    if (!(base == rhs.base))
      return false;
    return true;
  }
  bool operator != (const RegisterResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RegisterResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RegisterResp &a, RegisterResp &b);

std::ostream& operator<<(std::ostream& out, const RegisterResp& obj);


class UnRegisterReq : public virtual ::apache::thrift::TBase {
 public:

  UnRegisterReq(const UnRegisterReq&);
  UnRegisterReq& operator=(const UnRegisterReq&);
  UnRegisterReq() noexcept
                : resource_id() {
  }

  virtual ~UnRegisterReq() noexcept;
  std::string resource_id;

  void __set_resource_id(const std::string& val);

  bool operator == (const UnRegisterReq & rhs) const
  {
    if (!(resource_id == rhs.resource_id))
      return false;
    return true;
  }
  bool operator != (const UnRegisterReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnRegisterReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(UnRegisterReq &a, UnRegisterReq &b);

std::ostream& operator<<(std::ostream& out, const UnRegisterReq& obj);


class UnRegisterResp : public virtual ::apache::thrift::TBase {
 public:

  UnRegisterResp(const UnRegisterResp&);
  UnRegisterResp& operator=(const UnRegisterResp&);
  UnRegisterResp() noexcept {
  }

  virtual ~UnRegisterResp() noexcept;
   ::BaseCode base;

  void __set_base(const  ::BaseCode& val);

  bool operator == (const UnRegisterResp & rhs) const
  {
    if (!(base == rhs.base))
      return false;
    return true;
  }
  bool operator != (const UnRegisterResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnRegisterResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(UnRegisterResp &a, UnRegisterResp &b);

std::ostream& operator<<(std::ostream& out, const UnRegisterResp& obj);

typedef struct _HeartbeatReq__isset {
  _HeartbeatReq__isset() : device(false) {}
  bool device :1;
} _HeartbeatReq__isset;

class HeartbeatReq : public virtual ::apache::thrift::TBase {
 public:

  HeartbeatReq(const HeartbeatReq&);
  HeartbeatReq& operator=(const HeartbeatReq&);
  HeartbeatReq() noexcept
               : resource_id(),
                 up_resource(0) {
  }

  virtual ~HeartbeatReq() noexcept;
  std::string resource_id;
  bool up_resource;
  DeviceResourceDetail device;

  _HeartbeatReq__isset __isset;

  void __set_resource_id(const std::string& val);

  void __set_up_resource(const bool val);

  void __set_device(const DeviceResourceDetail& val);

  bool operator == (const HeartbeatReq & rhs) const
  {
    if (!(resource_id == rhs.resource_id))
      return false;
    if (!(up_resource == rhs.up_resource))
      return false;
    if (__isset.device != rhs.__isset.device)
      return false;
    else if (__isset.device && !(device == rhs.device))
      return false;
    return true;
  }
  bool operator != (const HeartbeatReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeartbeatReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeartbeatReq &a, HeartbeatReq &b);

std::ostream& operator<<(std::ostream& out, const HeartbeatReq& obj);


class HeartbeatResp : public virtual ::apache::thrift::TBase {
 public:

  HeartbeatResp(const HeartbeatResp&);
  HeartbeatResp& operator=(const HeartbeatResp&);
  HeartbeatResp() noexcept {
  }

  virtual ~HeartbeatResp() noexcept;
   ::BaseCode base;

  void __set_base(const  ::BaseCode& val);

  bool operator == (const HeartbeatResp & rhs) const
  {
    if (!(base == rhs.base))
      return false;
    return true;
  }
  bool operator != (const HeartbeatResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeartbeatResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeartbeatResp &a, HeartbeatResp &b);

std::ostream& operator<<(std::ostream& out, const HeartbeatResp& obj);



#endif
