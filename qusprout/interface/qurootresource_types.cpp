/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "qurootresource_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kGpuTypeValues[] = {
  GpuType::GpuType_Default,
  GpuType::GpuType_Nvidia
};
const char* _kGpuTypeNames[] = {
  "GpuType_Default",
  "GpuType_Nvidia"
};
const std::map<int, const char*> _GpuType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kGpuTypeValues, _kGpuTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const GpuType::type& val) {
  std::map<int, const char*>::const_iterator it = _GpuType_VALUES_TO_NAMES.find(val);
  if (it != _GpuType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const GpuType::type& val) {
  std::map<int, const char*>::const_iterator it = _GpuType_VALUES_TO_NAMES.find(val);
  if (it != _GpuType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


AddrDetail::~AddrDetail() noexcept {
}


void AddrDetail::__set_addr(const std::string& val) {
  this->addr = val;
}

void AddrDetail::__set_port(const int32_t val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const AddrDetail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddrDetail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_addr = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          isset_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_addr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddrDetail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddrDetail");

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddrDetail &a, AddrDetail &b) {
  using ::std::swap;
  swap(a.addr, b.addr);
  swap(a.port, b.port);
}

AddrDetail::AddrDetail(const AddrDetail& other0) {
  addr = other0.addr;
  port = other0.port;
}
AddrDetail& AddrDetail::operator=(const AddrDetail& other1) {
  addr = other1.addr;
  port = other1.port;
  return *this;
}
void AddrDetail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddrDetail(";
  out << "addr=" << to_string(addr);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


MachineDetail::~MachineDetail() noexcept {
}


void MachineDetail::__set_addr(const std::string& val) {
  this->addr = val;
}

void MachineDetail::__set_sys_name(const std::string& val) {
  this->sys_name = val;
__isset.sys_name = true;
}

void MachineDetail::__set_sys_release(const std::string& val) {
  this->sys_release = val;
__isset.sys_release = true;
}

void MachineDetail::__set_sys_version(const std::string& val) {
  this->sys_version = val;
__isset.sys_version = true;
}

void MachineDetail::__set_sys_machine(const std::string& val) {
  this->sys_machine = val;
__isset.sys_machine = true;
}
std::ostream& operator<<(std::ostream& out, const MachineDetail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MachineDetail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_addr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          isset_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sys_name);
          this->__isset.sys_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sys_release);
          this->__isset.sys_release = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sys_version);
          this->__isset.sys_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sys_machine);
          this->__isset.sys_machine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_addr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MachineDetail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MachineDetail");

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sys_name) {
    xfer += oprot->writeFieldBegin("sys_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->sys_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sys_release) {
    xfer += oprot->writeFieldBegin("sys_release", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->sys_release);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sys_version) {
    xfer += oprot->writeFieldBegin("sys_version", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->sys_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sys_machine) {
    xfer += oprot->writeFieldBegin("sys_machine", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->sys_machine);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MachineDetail &a, MachineDetail &b) {
  using ::std::swap;
  swap(a.addr, b.addr);
  swap(a.sys_name, b.sys_name);
  swap(a.sys_release, b.sys_release);
  swap(a.sys_version, b.sys_version);
  swap(a.sys_machine, b.sys_machine);
  swap(a.__isset, b.__isset);
}

MachineDetail::MachineDetail(const MachineDetail& other2) {
  addr = other2.addr;
  sys_name = other2.sys_name;
  sys_release = other2.sys_release;
  sys_version = other2.sys_version;
  sys_machine = other2.sys_machine;
  __isset = other2.__isset;
}
MachineDetail& MachineDetail::operator=(const MachineDetail& other3) {
  addr = other3.addr;
  sys_name = other3.sys_name;
  sys_release = other3.sys_release;
  sys_version = other3.sys_version;
  sys_machine = other3.sys_machine;
  __isset = other3.__isset;
  return *this;
}
void MachineDetail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MachineDetail(";
  out << "addr=" << to_string(addr);
  out << ", " << "sys_name="; (__isset.sys_name ? (out << to_string(sys_name)) : (out << "<null>"));
  out << ", " << "sys_release="; (__isset.sys_release ? (out << to_string(sys_release)) : (out << "<null>"));
  out << ", " << "sys_version="; (__isset.sys_version ? (out << to_string(sys_version)) : (out << "<null>"));
  out << ", " << "sys_machine="; (__isset.sys_machine ? (out << to_string(sys_machine)) : (out << "<null>"));
  out << ")";
}


ResourceDetail::~ResourceDetail() noexcept {
}


void ResourceDetail::__set_cpu_total_memory(const int64_t val) {
  this->cpu_total_memory = val;
}

void ResourceDetail::__set_cpu_free_memory(const int64_t val) {
  this->cpu_free_memory = val;
}

void ResourceDetail::__set_gpu_type(const GpuType::type val) {
  this->gpu_type = val;
__isset.gpu_type = true;
}

void ResourceDetail::__set_gpu_total_memory(const int64_t val) {
  this->gpu_total_memory = val;
__isset.gpu_total_memory = true;
}
std::ostream& operator<<(std::ostream& out, const ResourceDetail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResourceDetail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cpu_total_memory = false;
  bool isset_cpu_free_memory = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cpu_total_memory);
          isset_cpu_total_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cpu_free_memory);
          isset_cpu_free_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->gpu_type = static_cast<GpuType::type>(ecast4);
          this->__isset.gpu_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gpu_total_memory);
          this->__isset.gpu_total_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cpu_total_memory)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cpu_free_memory)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResourceDetail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResourceDetail");

  xfer += oprot->writeFieldBegin("cpu_total_memory", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cpu_total_memory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cpu_free_memory", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->cpu_free_memory);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.gpu_type) {
    xfer += oprot->writeFieldBegin("gpu_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->gpu_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gpu_total_memory) {
    xfer += oprot->writeFieldBegin("gpu_total_memory", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->gpu_total_memory);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResourceDetail &a, ResourceDetail &b) {
  using ::std::swap;
  swap(a.cpu_total_memory, b.cpu_total_memory);
  swap(a.cpu_free_memory, b.cpu_free_memory);
  swap(a.gpu_type, b.gpu_type);
  swap(a.gpu_total_memory, b.gpu_total_memory);
  swap(a.__isset, b.__isset);
}

ResourceDetail::ResourceDetail(const ResourceDetail& other5) noexcept {
  cpu_total_memory = other5.cpu_total_memory;
  cpu_free_memory = other5.cpu_free_memory;
  gpu_type = other5.gpu_type;
  gpu_total_memory = other5.gpu_total_memory;
  __isset = other5.__isset;
}
ResourceDetail& ResourceDetail::operator=(const ResourceDetail& other6) noexcept {
  cpu_total_memory = other6.cpu_total_memory;
  cpu_free_memory = other6.cpu_free_memory;
  gpu_type = other6.gpu_type;
  gpu_total_memory = other6.gpu_total_memory;
  __isset = other6.__isset;
  return *this;
}
void ResourceDetail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResourceDetail(";
  out << "cpu_total_memory=" << to_string(cpu_total_memory);
  out << ", " << "cpu_free_memory=" << to_string(cpu_free_memory);
  out << ", " << "gpu_type="; (__isset.gpu_type ? (out << to_string(gpu_type)) : (out << "<null>"));
  out << ", " << "gpu_total_memory="; (__isset.gpu_total_memory ? (out << to_string(gpu_total_memory)) : (out << "<null>"));
  out << ")";
}


DeviceDetail::~DeviceDetail() noexcept {
}


void DeviceDetail::__set_machine(const MachineDetail& val) {
  this->machine = val;
}

void DeviceDetail::__set_resource(const ResourceDetail& val) {
  this->resource = val;
}
std::ostream& operator<<(std::ostream& out, const DeviceDetail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DeviceDetail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_machine = false;
  bool isset_resource = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->machine.read(iprot);
          isset_machine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource.read(iprot);
          isset_resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_machine)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resource)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DeviceDetail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeviceDetail");

  xfer += oprot->writeFieldBegin("machine", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->machine.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->resource.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeviceDetail &a, DeviceDetail &b) {
  using ::std::swap;
  swap(a.machine, b.machine);
  swap(a.resource, b.resource);
}

DeviceDetail::DeviceDetail(const DeviceDetail& other7) {
  machine = other7.machine;
  resource = other7.resource;
}
DeviceDetail& DeviceDetail::operator=(const DeviceDetail& other8) {
  machine = other8.machine;
  resource = other8.resource;
  return *this;
}
void DeviceDetail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeviceDetail(";
  out << "machine=" << to_string(machine);
  out << ", " << "resource=" << to_string(resource);
  out << ")";
}


TcpResourceDetail::~TcpResourceDetail() noexcept {
}


void TcpResourceDetail::__set_addr_detail(const AddrDetail& val) {
  this->addr_detail = val;
}

void TcpResourceDetail::__set_dev_list(const std::map<std::string, DeviceDetail> & val) {
  this->dev_list = val;
}
std::ostream& operator<<(std::ostream& out, const TcpResourceDetail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TcpResourceDetail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_addr_detail = false;
  bool isset_dev_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->addr_detail.read(iprot);
          isset_addr_detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->dev_list.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _ktype10;
            ::apache::thrift::protocol::TType _vtype11;
            xfer += iprot->readMapBegin(_ktype10, _vtype11, _size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              std::string _key14;
              xfer += iprot->readString(_key14);
              DeviceDetail& _val15 = this->dev_list[_key14];
              xfer += _val15.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_dev_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_addr_detail)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dev_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TcpResourceDetail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TcpResourceDetail");

  xfer += oprot->writeFieldBegin("addr_detail", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->addr_detail.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dev_list", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dev_list.size()));
    std::map<std::string, DeviceDetail> ::const_iterator _iter16;
    for (_iter16 = this->dev_list.begin(); _iter16 != this->dev_list.end(); ++_iter16)
    {
      xfer += oprot->writeString(_iter16->first);
      xfer += _iter16->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TcpResourceDetail &a, TcpResourceDetail &b) {
  using ::std::swap;
  swap(a.addr_detail, b.addr_detail);
  swap(a.dev_list, b.dev_list);
}

TcpResourceDetail::TcpResourceDetail(const TcpResourceDetail& other17) {
  addr_detail = other17.addr_detail;
  dev_list = other17.dev_list;
}
TcpResourceDetail& TcpResourceDetail::operator=(const TcpResourceDetail& other18) {
  addr_detail = other18.addr_detail;
  dev_list = other18.dev_list;
  return *this;
}
void TcpResourceDetail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TcpResourceDetail(";
  out << "addr_detail=" << to_string(addr_detail);
  out << ", " << "dev_list=" << to_string(dev_list);
  out << ")";
}


GateCapacity::~GateCapacity() noexcept {
}


void GateCapacity::__set_device(const std::string& val) {
  this->device = val;
}

void GateCapacity::__set_gates(const std::vector<std::string> & val) {
  this->gates = val;
}
std::ostream& operator<<(std::ostream& out, const GateCapacity& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GateCapacity::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_device = false;
  bool isset_gates = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->device);
          isset_device = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gates.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->gates.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += iprot->readString(this->gates[_i23]);
            }
            xfer += iprot->readListEnd();
          }
          isset_gates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_device)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gates)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GateCapacity::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GateCapacity");

  xfer += oprot->writeFieldBegin("device", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->device);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gates", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->gates.size()));
    std::vector<std::string> ::const_iterator _iter24;
    for (_iter24 = this->gates.begin(); _iter24 != this->gates.end(); ++_iter24)
    {
      xfer += oprot->writeString((*_iter24));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GateCapacity &a, GateCapacity &b) {
  using ::std::swap;
  swap(a.device, b.device);
  swap(a.gates, b.gates);
}

GateCapacity::GateCapacity(const GateCapacity& other25) {
  device = other25.device;
  gates = other25.gates;
}
GateCapacity& GateCapacity::operator=(const GateCapacity& other26) {
  device = other26.device;
  gates = other26.gates;
  return *this;
}
void GateCapacity::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GateCapacity(";
  out << "device=" << to_string(device);
  out << ", " << "gates=" << to_string(gates);
  out << ")";
}


DeviceCapacity::~DeviceCapacity() noexcept {
}


void DeviceCapacity::__set_gate_cap_list(const std::vector<GateCapacity> & val) {
  this->gate_cap_list = val;
}
std::ostream& operator<<(std::ostream& out, const DeviceCapacity& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DeviceCapacity::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_gate_cap_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gate_cap_list.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->gate_cap_list.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += this->gate_cap_list[_i31].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_gate_cap_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_gate_cap_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DeviceCapacity::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeviceCapacity");

  xfer += oprot->writeFieldBegin("gate_cap_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->gate_cap_list.size()));
    std::vector<GateCapacity> ::const_iterator _iter32;
    for (_iter32 = this->gate_cap_list.begin(); _iter32 != this->gate_cap_list.end(); ++_iter32)
    {
      xfer += (*_iter32).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeviceCapacity &a, DeviceCapacity &b) {
  using ::std::swap;
  swap(a.gate_cap_list, b.gate_cap_list);
}

DeviceCapacity::DeviceCapacity(const DeviceCapacity& other33) {
  gate_cap_list = other33.gate_cap_list;
}
DeviceCapacity& DeviceCapacity::operator=(const DeviceCapacity& other34) {
  gate_cap_list = other34.gate_cap_list;
  return *this;
}
void DeviceCapacity::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeviceCapacity(";
  out << "gate_cap_list=" << to_string(gate_cap_list);
  out << ")";
}


ResourceRegisterReq::~ResourceRegisterReq() noexcept {
}


void ResourceRegisterReq::__set_resource_id(const std::string& val) {
  this->resource_id = val;
}

void ResourceRegisterReq::__set_name(const std::string& val) {
  this->name = val;
}

void ResourceRegisterReq::__set_protocol(const int32_t val) {
  this->protocol = val;
}

void ResourceRegisterReq::__set_tcp_resource(const TcpResourceDetail& val) {
  this->tcp_resource = val;
}

void ResourceRegisterReq::__set_cap(const DeviceCapacity& val) {
  this->cap = val;
}
std::ostream& operator<<(std::ostream& out, const ResourceRegisterReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResourceRegisterReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resource_id = false;
  bool isset_name = false;
  bool isset_protocol = false;
  bool isset_tcp_resource = false;
  bool isset_cap = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource_id);
          isset_resource_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->protocol);
          isset_protocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tcp_resource.read(iprot);
          isset_tcp_resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cap.read(iprot);
          isset_cap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resource_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_protocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tcp_resource)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cap)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResourceRegisterReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResourceRegisterReq");

  xfer += oprot->writeFieldBegin("resource_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resource_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("protocol", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->protocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tcp_resource", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->tcp_resource.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cap", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->cap.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResourceRegisterReq &a, ResourceRegisterReq &b) {
  using ::std::swap;
  swap(a.resource_id, b.resource_id);
  swap(a.name, b.name);
  swap(a.protocol, b.protocol);
  swap(a.tcp_resource, b.tcp_resource);
  swap(a.cap, b.cap);
}

ResourceRegisterReq::ResourceRegisterReq(const ResourceRegisterReq& other35) {
  resource_id = other35.resource_id;
  name = other35.name;
  protocol = other35.protocol;
  tcp_resource = other35.tcp_resource;
  cap = other35.cap;
}
ResourceRegisterReq& ResourceRegisterReq::operator=(const ResourceRegisterReq& other36) {
  resource_id = other36.resource_id;
  name = other36.name;
  protocol = other36.protocol;
  tcp_resource = other36.tcp_resource;
  cap = other36.cap;
  return *this;
}
void ResourceRegisterReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResourceRegisterReq(";
  out << "resource_id=" << to_string(resource_id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "protocol=" << to_string(protocol);
  out << ", " << "tcp_resource=" << to_string(tcp_resource);
  out << ", " << "cap=" << to_string(cap);
  out << ")";
}


ResourceRegisterResp::~ResourceRegisterResp() noexcept {
}


void ResourceRegisterResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const ResourceRegisterResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResourceRegisterResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResourceRegisterResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResourceRegisterResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResourceRegisterResp &a, ResourceRegisterResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

ResourceRegisterResp::ResourceRegisterResp(const ResourceRegisterResp& other37) {
  base = other37.base;
}
ResourceRegisterResp& ResourceRegisterResp::operator=(const ResourceRegisterResp& other38) {
  base = other38.base;
  return *this;
}
void ResourceRegisterResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResourceRegisterResp(";
  out << "base=" << to_string(base);
  out << ")";
}


UnResourceRegisterReq::~UnResourceRegisterReq() noexcept {
}


void UnResourceRegisterReq::__set_resource_id(const std::string& val) {
  this->resource_id = val;
}
std::ostream& operator<<(std::ostream& out, const UnResourceRegisterReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnResourceRegisterReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resource_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource_id);
          isset_resource_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resource_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnResourceRegisterReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnResourceRegisterReq");

  xfer += oprot->writeFieldBegin("resource_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resource_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnResourceRegisterReq &a, UnResourceRegisterReq &b) {
  using ::std::swap;
  swap(a.resource_id, b.resource_id);
}

UnResourceRegisterReq::UnResourceRegisterReq(const UnResourceRegisterReq& other39) {
  resource_id = other39.resource_id;
}
UnResourceRegisterReq& UnResourceRegisterReq::operator=(const UnResourceRegisterReq& other40) {
  resource_id = other40.resource_id;
  return *this;
}
void UnResourceRegisterReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnResourceRegisterReq(";
  out << "resource_id=" << to_string(resource_id);
  out << ")";
}


UnResourceRegisterResp::~UnResourceRegisterResp() noexcept {
}


void UnResourceRegisterResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const UnResourceRegisterResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnResourceRegisterResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnResourceRegisterResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnResourceRegisterResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnResourceRegisterResp &a, UnResourceRegisterResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

UnResourceRegisterResp::UnResourceRegisterResp(const UnResourceRegisterResp& other41) {
  base = other41.base;
}
UnResourceRegisterResp& UnResourceRegisterResp::operator=(const UnResourceRegisterResp& other42) {
  base = other42.base;
  return *this;
}
void UnResourceRegisterResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnResourceRegisterResp(";
  out << "base=" << to_string(base);
  out << ")";
}


HeartReq::~HeartReq() noexcept {
}


void HeartReq::__set_resource_id(const std::string& val) {
  this->resource_id = val;
}

void HeartReq::__set_up_resource(const bool val) {
  this->up_resource = val;
}

void HeartReq::__set_dev_list(const std::map<std::string, DeviceDetail> & val) {
  this->dev_list = val;
__isset.dev_list = true;
}
std::ostream& operator<<(std::ostream& out, const HeartReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resource_id = false;
  bool isset_up_resource = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource_id);
          isset_resource_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->up_resource);
          isset_up_resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->dev_list.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _ktype44;
            ::apache::thrift::protocol::TType _vtype45;
            xfer += iprot->readMapBegin(_ktype44, _vtype45, _size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              std::string _key48;
              xfer += iprot->readString(_key48);
              DeviceDetail& _val49 = this->dev_list[_key48];
              xfer += _val49.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.dev_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resource_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_up_resource)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartReq");

  xfer += oprot->writeFieldBegin("resource_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resource_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("up_resource", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->up_resource);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dev_list) {
    xfer += oprot->writeFieldBegin("dev_list", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dev_list.size()));
      std::map<std::string, DeviceDetail> ::const_iterator _iter50;
      for (_iter50 = this->dev_list.begin(); _iter50 != this->dev_list.end(); ++_iter50)
      {
        xfer += oprot->writeString(_iter50->first);
        xfer += _iter50->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartReq &a, HeartReq &b) {
  using ::std::swap;
  swap(a.resource_id, b.resource_id);
  swap(a.up_resource, b.up_resource);
  swap(a.dev_list, b.dev_list);
  swap(a.__isset, b.__isset);
}

HeartReq::HeartReq(const HeartReq& other51) {
  resource_id = other51.resource_id;
  up_resource = other51.up_resource;
  dev_list = other51.dev_list;
  __isset = other51.__isset;
}
HeartReq& HeartReq::operator=(const HeartReq& other52) {
  resource_id = other52.resource_id;
  up_resource = other52.up_resource;
  dev_list = other52.dev_list;
  __isset = other52.__isset;
  return *this;
}
void HeartReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartReq(";
  out << "resource_id=" << to_string(resource_id);
  out << ", " << "up_resource=" << to_string(up_resource);
  out << ", " << "dev_list="; (__isset.dev_list ? (out << to_string(dev_list)) : (out << "<null>"));
  out << ")";
}


HeartResp::~HeartResp() noexcept {
}


void HeartResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const HeartResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartResp &a, HeartResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

HeartResp::HeartResp(const HeartResp& other53) {
  base = other53.base;
}
HeartResp& HeartResp::operator=(const HeartResp& other54) {
  base = other54.base;
  return *this;
}
void HeartResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartResp(";
  out << "base=" << to_string(base);
  out << ")";
}


