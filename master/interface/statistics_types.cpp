/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "statistics_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kGpuTypeValues[] = {
  GpuType::GpuType_Default,
  GpuType::GpuType_Nvidia
};
const char* _kGpuTypeNames[] = {
  "GpuType_Default",
  "GpuType_Nvidia"
};
const std::map<int, const char*> _GpuType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kGpuTypeValues, _kGpuTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const GpuType::type& val) {
  std::map<int, const char*>::const_iterator it = _GpuType_VALUES_TO_NAMES.find(val);
  if (it != _GpuType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const GpuType::type& val) {
  std::map<int, const char*>::const_iterator it = _GpuType_VALUES_TO_NAMES.find(val);
  if (it != _GpuType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


BaseTag::~BaseTag() noexcept {
}


void BaseTag::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void BaseTag::__set_type(const  ::ExecCmdType::type val) {
  this->type = val;
}
std::ostream& operator<<(std::ostream& out, const BaseTag& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BaseTag::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hostname = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = static_cast< ::ExecCmdType::type>(ecast0);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BaseTag::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BaseTag");

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BaseTag &a, BaseTag &b) {
  using ::std::swap;
  swap(a.hostname, b.hostname);
  swap(a.type, b.type);
}

BaseTag::BaseTag(const BaseTag& other1) {
  hostname = other1.hostname;
  type = other1.type;
}
BaseTag& BaseTag::operator=(const BaseTag& other2) {
  hostname = other2.hostname;
  type = other2.type;
  return *this;
}
void BaseTag::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BaseTag(";
  out << "hostname=" << to_string(hostname);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


QubitTag::~QubitTag() noexcept {
}


void QubitTag::__set_base(const BaseTag& val) {
  this->base = val;
}

void QubitTag::__set_qubits(const int32_t val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const QubitTag& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t QubitTag::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t QubitTag::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("QubitTag");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QubitTag &a, QubitTag &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.qubits, b.qubits);
}

QubitTag::QubitTag(const QubitTag& other3) {
  base = other3.base;
  qubits = other3.qubits;
}
QubitTag& QubitTag::operator=(const QubitTag& other4) {
  base = other4.base;
  qubits = other4.qubits;
  return *this;
}
void QubitTag::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "QubitTag(";
  out << "base=" << to_string(base);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


InterfaceTag::~InterfaceTag() noexcept {
}


void InterfaceTag::__set_base(const BaseTag& val) {
  this->base = val;
}

void InterfaceTag::__set_interface_name(const std::string& val) {
  this->interface_name = val;
}

void InterfaceTag::__set_qubits(const int32_t val) {
  this->qubits = val;
}
std::ostream& operator<<(std::ostream& out, const InterfaceTag& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InterfaceTag::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;
  bool isset_interface_name = false;
  bool isset_qubits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->interface_name);
          isset_interface_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qubits);
          isset_qubits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_interface_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qubits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InterfaceTag::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InterfaceTag");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("interface_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->interface_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qubits", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->qubits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InterfaceTag &a, InterfaceTag &b) {
  using ::std::swap;
  swap(a.base, b.base);
  swap(a.interface_name, b.interface_name);
  swap(a.qubits, b.qubits);
}

InterfaceTag::InterfaceTag(const InterfaceTag& other5) {
  base = other5.base;
  interface_name = other5.interface_name;
  qubits = other5.qubits;
}
InterfaceTag& InterfaceTag::operator=(const InterfaceTag& other6) {
  base = other6.base;
  interface_name = other6.interface_name;
  qubits = other6.qubits;
  return *this;
}
void InterfaceTag::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InterfaceTag(";
  out << "base=" << to_string(base);
  out << ", " << "interface_name=" << to_string(interface_name);
  out << ", " << "qubits=" << to_string(qubits);
  out << ")";
}


SisAllTaskNum::~SisAllTaskNum() noexcept {
}


void SisAllTaskNum::__set_tag(const QubitTag& val) {
  this->tag = val;
}

void SisAllTaskNum::__set_num(const int32_t val) {
  this->num = val;
}
std::ostream& operator<<(std::ostream& out, const SisAllTaskNum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SisAllTaskNum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tag = false;
  bool isset_num = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tag.read(iprot);
          isset_tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          isset_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SisAllTaskNum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SisAllTaskNum");

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tag.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SisAllTaskNum &a, SisAllTaskNum &b) {
  using ::std::swap;
  swap(a.tag, b.tag);
  swap(a.num, b.num);
}

SisAllTaskNum::SisAllTaskNum(const SisAllTaskNum& other7) {
  tag = other7.tag;
  num = other7.num;
}
SisAllTaskNum& SisAllTaskNum::operator=(const SisAllTaskNum& other8) {
  tag = other8.tag;
  num = other8.num;
  return *this;
}
void SisAllTaskNum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SisAllTaskNum(";
  out << "tag=" << to_string(tag);
  out << ", " << "num=" << to_string(num);
  out << ")";
}


SisCurrTaskNum::~SisCurrTaskNum() noexcept {
}


void SisCurrTaskNum::__set_tag(const QubitTag& val) {
  this->tag = val;
}

void SisCurrTaskNum::__set_num(const int32_t val) {
  this->num = val;
}

void SisCurrTaskNum::__set_timeout_num(const int32_t val) {
  this->timeout_num = val;
}
std::ostream& operator<<(std::ostream& out, const SisCurrTaskNum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SisCurrTaskNum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tag = false;
  bool isset_num = false;
  bool isset_timeout_num = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tag.read(iprot);
          isset_tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          isset_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout_num);
          isset_timeout_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeout_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SisCurrTaskNum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SisCurrTaskNum");

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tag.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeout_num", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->timeout_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SisCurrTaskNum &a, SisCurrTaskNum &b) {
  using ::std::swap;
  swap(a.tag, b.tag);
  swap(a.num, b.num);
  swap(a.timeout_num, b.timeout_num);
}

SisCurrTaskNum::SisCurrTaskNum(const SisCurrTaskNum& other9) {
  tag = other9.tag;
  num = other9.num;
  timeout_num = other9.timeout_num;
}
SisCurrTaskNum& SisCurrTaskNum::operator=(const SisCurrTaskNum& other10) {
  tag = other10.tag;
  num = other10.num;
  timeout_num = other10.timeout_num;
  return *this;
}
void SisCurrTaskNum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SisCurrTaskNum(";
  out << "tag=" << to_string(tag);
  out << ", " << "num=" << to_string(num);
  out << ", " << "timeout_num=" << to_string(timeout_num);
  out << ")";
}


SisInterfaceCount::~SisInterfaceCount() noexcept {
}


void SisInterfaceCount::__set_tag(const InterfaceTag& val) {
  this->tag = val;
}

void SisInterfaceCount::__set_count(const int32_t val) {
  this->count = val;
}
std::ostream& operator<<(std::ostream& out, const SisInterfaceCount& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SisInterfaceCount::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tag = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tag.read(iprot);
          isset_tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SisInterfaceCount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SisInterfaceCount");

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tag.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SisInterfaceCount &a, SisInterfaceCount &b) {
  using ::std::swap;
  swap(a.tag, b.tag);
  swap(a.count, b.count);
}

SisInterfaceCount::SisInterfaceCount(const SisInterfaceCount& other11) {
  tag = other11.tag;
  count = other11.count;
}
SisInterfaceCount& SisInterfaceCount::operator=(const SisInterfaceCount& other12) {
  tag = other12.tag;
  count = other12.count;
  return *this;
}
void SisInterfaceCount::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SisInterfaceCount(";
  out << "tag=" << to_string(tag);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


SisInterfaceTime::~SisInterfaceTime() noexcept {
}


void SisInterfaceTime::__set_tag(const InterfaceTag& val) {
  this->tag = val;
}

void SisInterfaceTime::__set_elapsed(const int32_t val) {
  this->elapsed = val;
}

void SisInterfaceTime::__set_count(const int32_t val) {
  this->count = val;
}
std::ostream& operator<<(std::ostream& out, const SisInterfaceTime& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SisInterfaceTime::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tag = false;
  bool isset_elapsed = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tag.read(iprot);
          isset_tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->elapsed);
          isset_elapsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_elapsed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SisInterfaceTime::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SisInterfaceTime");

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tag.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("elapsed", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->elapsed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SisInterfaceTime &a, SisInterfaceTime &b) {
  using ::std::swap;
  swap(a.tag, b.tag);
  swap(a.elapsed, b.elapsed);
  swap(a.count, b.count);
}

SisInterfaceTime::SisInterfaceTime(const SisInterfaceTime& other13) {
  tag = other13.tag;
  elapsed = other13.elapsed;
  count = other13.count;
}
SisInterfaceTime& SisInterfaceTime::operator=(const SisInterfaceTime& other14) {
  tag = other14.tag;
  elapsed = other14.elapsed;
  count = other14.count;
  return *this;
}
void SisInterfaceTime::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SisInterfaceTime(";
  out << "tag=" << to_string(tag);
  out << ", " << "elapsed=" << to_string(elapsed);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


SisCodeCount::~SisCodeCount() noexcept {
}


void SisCodeCount::__set_tag(const InterfaceTag& val) {
  this->tag = val;
}

void SisCodeCount::__set_code(const int32_t val) {
  this->code = val;
}

void SisCodeCount::__set_count(const int32_t val) {
  this->count = val;
}
std::ostream& operator<<(std::ostream& out, const SisCodeCount& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SisCodeCount::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tag = false;
  bool isset_code = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tag.read(iprot);
          isset_tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SisCodeCount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SisCodeCount");

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tag.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SisCodeCount &a, SisCodeCount &b) {
  using ::std::swap;
  swap(a.tag, b.tag);
  swap(a.code, b.code);
  swap(a.count, b.count);
}

SisCodeCount::SisCodeCount(const SisCodeCount& other15) {
  tag = other15.tag;
  code = other15.code;
  count = other15.count;
}
SisCodeCount& SisCodeCount::operator=(const SisCodeCount& other16) {
  tag = other16.tag;
  code = other16.code;
  count = other16.count;
  return *this;
}
void SisCodeCount::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SisCodeCount(";
  out << "tag=" << to_string(tag);
  out << ", " << "code=" << to_string(code);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


MachineFixedInfo::~MachineFixedInfo() noexcept {
}


void MachineFixedInfo::__set_cpu_num(const int32_t val) {
  this->cpu_num = val;
}

void MachineFixedInfo::__set_cpu_memory(const int64_t val) {
  this->cpu_memory = val;
}

void MachineFixedInfo::__set_gpu_type(const GpuType::type val) {
  this->gpu_type = val;
__isset.gpu_type = true;
}

void MachineFixedInfo::__set_gpu_memory(const int64_t val) {
  this->gpu_memory = val;
__isset.gpu_memory = true;
}
std::ostream& operator<<(std::ostream& out, const MachineFixedInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MachineFixedInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cpu_num = false;
  bool isset_cpu_memory = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cpu_num);
          isset_cpu_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cpu_memory);
          isset_cpu_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->gpu_type = static_cast<GpuType::type>(ecast17);
          this->__isset.gpu_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gpu_memory);
          this->__isset.gpu_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cpu_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cpu_memory)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MachineFixedInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MachineFixedInfo");

  xfer += oprot->writeFieldBegin("cpu_num", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cpu_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cpu_memory", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->cpu_memory);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.gpu_type) {
    xfer += oprot->writeFieldBegin("gpu_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->gpu_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gpu_memory) {
    xfer += oprot->writeFieldBegin("gpu_memory", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->gpu_memory);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MachineFixedInfo &a, MachineFixedInfo &b) {
  using ::std::swap;
  swap(a.cpu_num, b.cpu_num);
  swap(a.cpu_memory, b.cpu_memory);
  swap(a.gpu_type, b.gpu_type);
  swap(a.gpu_memory, b.gpu_memory);
  swap(a.__isset, b.__isset);
}

MachineFixedInfo::MachineFixedInfo(const MachineFixedInfo& other18) noexcept {
  cpu_num = other18.cpu_num;
  cpu_memory = other18.cpu_memory;
  gpu_type = other18.gpu_type;
  gpu_memory = other18.gpu_memory;
  __isset = other18.__isset;
}
MachineFixedInfo& MachineFixedInfo::operator=(const MachineFixedInfo& other19) noexcept {
  cpu_num = other19.cpu_num;
  cpu_memory = other19.cpu_memory;
  gpu_type = other19.gpu_type;
  gpu_memory = other19.gpu_memory;
  __isset = other19.__isset;
  return *this;
}
void MachineFixedInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MachineFixedInfo(";
  out << "cpu_num=" << to_string(cpu_num);
  out << ", " << "cpu_memory=" << to_string(cpu_memory);
  out << ", " << "gpu_type="; (__isset.gpu_type ? (out << to_string(gpu_type)) : (out << "<null>"));
  out << ", " << "gpu_memory="; (__isset.gpu_memory ? (out << to_string(gpu_memory)) : (out << "<null>"));
  out << ")";
}


MachineDynamicInfo::~MachineDynamicInfo() noexcept {
}


void MachineDynamicInfo::__set_cpu_used_memory(const int64_t val) {
  this->cpu_used_memory = val;
}

void MachineDynamicInfo::__set_gpu_used_memory(const int64_t val) {
  this->gpu_used_memory = val;
__isset.gpu_used_memory = true;
}
std::ostream& operator<<(std::ostream& out, const MachineDynamicInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MachineDynamicInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cpu_used_memory = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cpu_used_memory);
          isset_cpu_used_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gpu_used_memory);
          this->__isset.gpu_used_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cpu_used_memory)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MachineDynamicInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MachineDynamicInfo");

  xfer += oprot->writeFieldBegin("cpu_used_memory", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cpu_used_memory);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.gpu_used_memory) {
    xfer += oprot->writeFieldBegin("gpu_used_memory", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->gpu_used_memory);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MachineDynamicInfo &a, MachineDynamicInfo &b) {
  using ::std::swap;
  swap(a.cpu_used_memory, b.cpu_used_memory);
  swap(a.gpu_used_memory, b.gpu_used_memory);
  swap(a.__isset, b.__isset);
}

MachineDynamicInfo::MachineDynamicInfo(const MachineDynamicInfo& other20) noexcept {
  cpu_used_memory = other20.cpu_used_memory;
  gpu_used_memory = other20.gpu_used_memory;
  __isset = other20.__isset;
}
MachineDynamicInfo& MachineDynamicInfo::operator=(const MachineDynamicInfo& other21) noexcept {
  cpu_used_memory = other21.cpu_used_memory;
  gpu_used_memory = other21.gpu_used_memory;
  __isset = other21.__isset;
  return *this;
}
void MachineDynamicInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MachineDynamicInfo(";
  out << "cpu_used_memory=" << to_string(cpu_used_memory);
  out << ", " << "gpu_used_memory="; (__isset.gpu_used_memory ? (out << to_string(gpu_used_memory)) : (out << "<null>"));
  out << ")";
}


StatisticsInfo::~StatisticsInfo() noexcept {
}


void StatisticsInfo::__set_fixed_info(const MachineFixedInfo& val) {
  this->fixed_info = val;
}

void StatisticsInfo::__set_dyna_info(const MachineDynamicInfo& val) {
  this->dyna_info = val;
}

void StatisticsInfo::__set_curr_task_num(const std::vector<SisCurrTaskNum> & val) {
  this->curr_task_num = val;
}

void StatisticsInfo::__set_all_task_num(const std::map<std::string, SisAllTaskNum> & val) {
  this->all_task_num = val;
}

void StatisticsInfo::__set_inter_cout(const std::map<std::string, SisInterfaceCount> & val) {
  this->inter_cout = val;
}

void StatisticsInfo::__set_inter_time(const std::map<std::string, SisInterfaceTime> & val) {
  this->inter_time = val;
}

void StatisticsInfo::__set_code_count(const std::map<std::string, SisCodeCount> & val) {
  this->code_count = val;
}

void StatisticsInfo::__set_begin_time(const int64_t val) {
  this->begin_time = val;
}

void StatisticsInfo::__set_end_time(const int64_t val) {
  this->end_time = val;
}
std::ostream& operator<<(std::ostream& out, const StatisticsInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StatisticsInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fixed_info = false;
  bool isset_dyna_info = false;
  bool isset_curr_task_num = false;
  bool isset_all_task_num = false;
  bool isset_inter_cout = false;
  bool isset_inter_time = false;
  bool isset_code_count = false;
  bool isset_begin_time = false;
  bool isset_end_time = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fixed_info.read(iprot);
          isset_fixed_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dyna_info.read(iprot);
          isset_dyna_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->curr_task_num.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->curr_task_num.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->curr_task_num[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_curr_task_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->all_task_num.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _ktype28;
            ::apache::thrift::protocol::TType _vtype29;
            xfer += iprot->readMapBegin(_ktype28, _vtype29, _size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              std::string _key32;
              xfer += iprot->readString(_key32);
              SisAllTaskNum& _val33 = this->all_task_num[_key32];
              xfer += _val33.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_all_task_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->inter_cout.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _ktype35;
            ::apache::thrift::protocol::TType _vtype36;
            xfer += iprot->readMapBegin(_ktype35, _vtype36, _size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              std::string _key39;
              xfer += iprot->readString(_key39);
              SisInterfaceCount& _val40 = this->inter_cout[_key39];
              xfer += _val40.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_inter_cout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->inter_time.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _ktype42;
            ::apache::thrift::protocol::TType _vtype43;
            xfer += iprot->readMapBegin(_ktype42, _vtype43, _size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              std::string _key46;
              xfer += iprot->readString(_key46);
              SisInterfaceTime& _val47 = this->inter_time[_key46];
              xfer += _val47.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_inter_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->code_count.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _ktype49;
            ::apache::thrift::protocol::TType _vtype50;
            xfer += iprot->readMapBegin(_ktype49, _vtype50, _size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              std::string _key53;
              xfer += iprot->readString(_key53);
              SisCodeCount& _val54 = this->code_count[_key53];
              xfer += _val54.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_code_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->begin_time);
          isset_begin_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_time);
          isset_end_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fixed_info)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dyna_info)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_curr_task_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_all_task_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inter_cout)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inter_time)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_code_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_begin_time)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_time)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StatisticsInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StatisticsInfo");

  xfer += oprot->writeFieldBegin("fixed_info", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->fixed_info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dyna_info", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->dyna_info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("curr_task_num", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->curr_task_num.size()));
    std::vector<SisCurrTaskNum> ::const_iterator _iter55;
    for (_iter55 = this->curr_task_num.begin(); _iter55 != this->curr_task_num.end(); ++_iter55)
    {
      xfer += (*_iter55).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("all_task_num", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->all_task_num.size()));
    std::map<std::string, SisAllTaskNum> ::const_iterator _iter56;
    for (_iter56 = this->all_task_num.begin(); _iter56 != this->all_task_num.end(); ++_iter56)
    {
      xfer += oprot->writeString(_iter56->first);
      xfer += _iter56->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inter_cout", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->inter_cout.size()));
    std::map<std::string, SisInterfaceCount> ::const_iterator _iter57;
    for (_iter57 = this->inter_cout.begin(); _iter57 != this->inter_cout.end(); ++_iter57)
    {
      xfer += oprot->writeString(_iter57->first);
      xfer += _iter57->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inter_time", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->inter_time.size()));
    std::map<std::string, SisInterfaceTime> ::const_iterator _iter58;
    for (_iter58 = this->inter_time.begin(); _iter58 != this->inter_time.end(); ++_iter58)
    {
      xfer += oprot->writeString(_iter58->first);
      xfer += _iter58->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code_count", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->code_count.size()));
    std::map<std::string, SisCodeCount> ::const_iterator _iter59;
    for (_iter59 = this->code_count.begin(); _iter59 != this->code_count.end(); ++_iter59)
    {
      xfer += oprot->writeString(_iter59->first);
      xfer += _iter59->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("begin_time", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->begin_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_time", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->end_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StatisticsInfo &a, StatisticsInfo &b) {
  using ::std::swap;
  swap(a.fixed_info, b.fixed_info);
  swap(a.dyna_info, b.dyna_info);
  swap(a.curr_task_num, b.curr_task_num);
  swap(a.all_task_num, b.all_task_num);
  swap(a.inter_cout, b.inter_cout);
  swap(a.inter_time, b.inter_time);
  swap(a.code_count, b.code_count);
  swap(a.begin_time, b.begin_time);
  swap(a.end_time, b.end_time);
}

StatisticsInfo::StatisticsInfo(const StatisticsInfo& other60) {
  fixed_info = other60.fixed_info;
  dyna_info = other60.dyna_info;
  curr_task_num = other60.curr_task_num;
  all_task_num = other60.all_task_num;
  inter_cout = other60.inter_cout;
  inter_time = other60.inter_time;
  code_count = other60.code_count;
  begin_time = other60.begin_time;
  end_time = other60.end_time;
}
StatisticsInfo& StatisticsInfo::operator=(const StatisticsInfo& other61) {
  fixed_info = other61.fixed_info;
  dyna_info = other61.dyna_info;
  curr_task_num = other61.curr_task_num;
  all_task_num = other61.all_task_num;
  inter_cout = other61.inter_cout;
  inter_time = other61.inter_time;
  code_count = other61.code_count;
  begin_time = other61.begin_time;
  end_time = other61.end_time;
  return *this;
}
void StatisticsInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StatisticsInfo(";
  out << "fixed_info=" << to_string(fixed_info);
  out << ", " << "dyna_info=" << to_string(dyna_info);
  out << ", " << "curr_task_num=" << to_string(curr_task_num);
  out << ", " << "all_task_num=" << to_string(all_task_num);
  out << ", " << "inter_cout=" << to_string(inter_cout);
  out << ", " << "inter_time=" << to_string(inter_time);
  out << ", " << "code_count=" << to_string(code_count);
  out << ", " << "begin_time=" << to_string(begin_time);
  out << ", " << "end_time=" << to_string(end_time);
  out << ")";
}


