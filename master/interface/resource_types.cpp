/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "resource_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kGpuInfoTypeValues[] = {
  GpuInfoType::GpuType_Default,
  GpuInfoType::GpuType_Nvidia
};
const char* _kGpuInfoTypeNames[] = {
  "GpuType_Default",
  "GpuType_Nvidia"
};
const std::map<int, const char*> _GpuInfoType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kGpuInfoTypeValues, _kGpuInfoTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const GpuInfoType::type& val) {
  std::map<int, const char*>::const_iterator it = _GpuInfoType_VALUES_TO_NAMES.find(val);
  if (it != _GpuInfoType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const GpuInfoType::type& val) {
  std::map<int, const char*>::const_iterator it = _GpuInfoType_VALUES_TO_NAMES.find(val);
  if (it != _GpuInfoType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


RpcConnectInfo::~RpcConnectInfo() noexcept {
}


void RpcConnectInfo::__set_addr(const std::string& val) {
  this->addr = val;
}

void RpcConnectInfo::__set_port(const int32_t val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const RpcConnectInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RpcConnectInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_addr = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          isset_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_addr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RpcConnectInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RpcConnectInfo");

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RpcConnectInfo &a, RpcConnectInfo &b) {
  using ::std::swap;
  swap(a.addr, b.addr);
  swap(a.port, b.port);
}

RpcConnectInfo::RpcConnectInfo(const RpcConnectInfo& other0) {
  addr = other0.addr;
  port = other0.port;
}
RpcConnectInfo& RpcConnectInfo::operator=(const RpcConnectInfo& other1) {
  addr = other1.addr;
  port = other1.port;
  return *this;
}
void RpcConnectInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RpcConnectInfo(";
  out << "addr=" << to_string(addr);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


MachineInfo::~MachineInfo() noexcept {
}


void MachineInfo::__set_addr(const std::string& val) {
  this->addr = val;
}

void MachineInfo::__set_sys_name(const std::string& val) {
  this->sys_name = val;
__isset.sys_name = true;
}

void MachineInfo::__set_sys_release(const std::string& val) {
  this->sys_release = val;
__isset.sys_release = true;
}

void MachineInfo::__set_sys_version(const std::string& val) {
  this->sys_version = val;
__isset.sys_version = true;
}

void MachineInfo::__set_sys_machine(const std::string& val) {
  this->sys_machine = val;
__isset.sys_machine = true;
}
std::ostream& operator<<(std::ostream& out, const MachineInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MachineInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_addr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          isset_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sys_name);
          this->__isset.sys_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sys_release);
          this->__isset.sys_release = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sys_version);
          this->__isset.sys_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sys_machine);
          this->__isset.sys_machine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_addr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MachineInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MachineInfo");

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sys_name) {
    xfer += oprot->writeFieldBegin("sys_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->sys_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sys_release) {
    xfer += oprot->writeFieldBegin("sys_release", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->sys_release);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sys_version) {
    xfer += oprot->writeFieldBegin("sys_version", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->sys_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sys_machine) {
    xfer += oprot->writeFieldBegin("sys_machine", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->sys_machine);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MachineInfo &a, MachineInfo &b) {
  using ::std::swap;
  swap(a.addr, b.addr);
  swap(a.sys_name, b.sys_name);
  swap(a.sys_release, b.sys_release);
  swap(a.sys_version, b.sys_version);
  swap(a.sys_machine, b.sys_machine);
  swap(a.__isset, b.__isset);
}

MachineInfo::MachineInfo(const MachineInfo& other2) {
  addr = other2.addr;
  sys_name = other2.sys_name;
  sys_release = other2.sys_release;
  sys_version = other2.sys_version;
  sys_machine = other2.sys_machine;
  __isset = other2.__isset;
}
MachineInfo& MachineInfo::operator=(const MachineInfo& other3) {
  addr = other3.addr;
  sys_name = other3.sys_name;
  sys_release = other3.sys_release;
  sys_version = other3.sys_version;
  sys_machine = other3.sys_machine;
  __isset = other3.__isset;
  return *this;
}
void MachineInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MachineInfo(";
  out << "addr=" << to_string(addr);
  out << ", " << "sys_name="; (__isset.sys_name ? (out << to_string(sys_name)) : (out << "<null>"));
  out << ", " << "sys_release="; (__isset.sys_release ? (out << to_string(sys_release)) : (out << "<null>"));
  out << ", " << "sys_version="; (__isset.sys_version ? (out << to_string(sys_version)) : (out << "<null>"));
  out << ", " << "sys_machine="; (__isset.sys_machine ? (out << to_string(sys_machine)) : (out << "<null>"));
  out << ")";
}


ResourceInfo::~ResourceInfo() noexcept {
}


void ResourceInfo::__set_cpu_total_memory(const int64_t val) {
  this->cpu_total_memory = val;
}

void ResourceInfo::__set_cpu_free_memory(const int64_t val) {
  this->cpu_free_memory = val;
}

void ResourceInfo::__set_gpu_type(const GpuInfoType::type val) {
  this->gpu_type = val;
__isset.gpu_type = true;
}

void ResourceInfo::__set_gpu_total_memory(const int64_t val) {
  this->gpu_total_memory = val;
__isset.gpu_total_memory = true;
}
std::ostream& operator<<(std::ostream& out, const ResourceInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResourceInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cpu_total_memory = false;
  bool isset_cpu_free_memory = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cpu_total_memory);
          isset_cpu_total_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cpu_free_memory);
          isset_cpu_free_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->gpu_type = static_cast<GpuInfoType::type>(ecast4);
          this->__isset.gpu_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gpu_total_memory);
          this->__isset.gpu_total_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cpu_total_memory)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cpu_free_memory)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResourceInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResourceInfo");

  xfer += oprot->writeFieldBegin("cpu_total_memory", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cpu_total_memory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cpu_free_memory", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->cpu_free_memory);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.gpu_type) {
    xfer += oprot->writeFieldBegin("gpu_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->gpu_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gpu_total_memory) {
    xfer += oprot->writeFieldBegin("gpu_total_memory", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->gpu_total_memory);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResourceInfo &a, ResourceInfo &b) {
  using ::std::swap;
  swap(a.cpu_total_memory, b.cpu_total_memory);
  swap(a.cpu_free_memory, b.cpu_free_memory);
  swap(a.gpu_type, b.gpu_type);
  swap(a.gpu_total_memory, b.gpu_total_memory);
  swap(a.__isset, b.__isset);
}

ResourceInfo::ResourceInfo(const ResourceInfo& other5) noexcept {
  cpu_total_memory = other5.cpu_total_memory;
  cpu_free_memory = other5.cpu_free_memory;
  gpu_type = other5.gpu_type;
  gpu_total_memory = other5.gpu_total_memory;
  __isset = other5.__isset;
}
ResourceInfo& ResourceInfo::operator=(const ResourceInfo& other6) noexcept {
  cpu_total_memory = other6.cpu_total_memory;
  cpu_free_memory = other6.cpu_free_memory;
  gpu_type = other6.gpu_type;
  gpu_total_memory = other6.gpu_total_memory;
  __isset = other6.__isset;
  return *this;
}
void ResourceInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResourceInfo(";
  out << "cpu_total_memory=" << to_string(cpu_total_memory);
  out << ", " << "cpu_free_memory=" << to_string(cpu_free_memory);
  out << ", " << "gpu_type="; (__isset.gpu_type ? (out << to_string(gpu_type)) : (out << "<null>"));
  out << ", " << "gpu_total_memory="; (__isset.gpu_total_memory ? (out << to_string(gpu_total_memory)) : (out << "<null>"));
  out << ")";
}


DeviceResourceDetail::~DeviceResourceDetail() noexcept {
}


void DeviceResourceDetail::__set_machine(const MachineInfo& val) {
  this->machine = val;
}

void DeviceResourceDetail::__set_resource(const ResourceInfo& val) {
  this->resource = val;
}
std::ostream& operator<<(std::ostream& out, const DeviceResourceDetail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DeviceResourceDetail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_machine = false;
  bool isset_resource = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->machine.read(iprot);
          isset_machine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource.read(iprot);
          isset_resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_machine)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resource)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DeviceResourceDetail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeviceResourceDetail");

  xfer += oprot->writeFieldBegin("machine", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->machine.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->resource.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeviceResourceDetail &a, DeviceResourceDetail &b) {
  using ::std::swap;
  swap(a.machine, b.machine);
  swap(a.resource, b.resource);
}

DeviceResourceDetail::DeviceResourceDetail(const DeviceResourceDetail& other7) {
  machine = other7.machine;
  resource = other7.resource;
}
DeviceResourceDetail& DeviceResourceDetail::operator=(const DeviceResourceDetail& other8) {
  machine = other8.machine;
  resource = other8.resource;
  return *this;
}
void DeviceResourceDetail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeviceResourceDetail(";
  out << "machine=" << to_string(machine);
  out << ", " << "resource=" << to_string(resource);
  out << ")";
}


RegisterReq::~RegisterReq() noexcept {
}


void RegisterReq::__set_resource_id(const std::string& val) {
  this->resource_id = val;
}

void RegisterReq::__set_rpc(const RpcConnectInfo& val) {
  this->rpc = val;
}

void RegisterReq::__set_device(const DeviceResourceDetail& val) {
  this->device = val;
}
std::ostream& operator<<(std::ostream& out, const RegisterReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RegisterReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resource_id = false;
  bool isset_rpc = false;
  bool isset_device = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource_id);
          isset_resource_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rpc.read(iprot);
          isset_rpc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->device.read(iprot);
          isset_device = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resource_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rpc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_device)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RegisterReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RegisterReq");

  xfer += oprot->writeFieldBegin("resource_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resource_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rpc", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->rpc.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("device", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->device.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RegisterReq &a, RegisterReq &b) {
  using ::std::swap;
  swap(a.resource_id, b.resource_id);
  swap(a.rpc, b.rpc);
  swap(a.device, b.device);
}

RegisterReq::RegisterReq(const RegisterReq& other9) {
  resource_id = other9.resource_id;
  rpc = other9.rpc;
  device = other9.device;
}
RegisterReq& RegisterReq::operator=(const RegisterReq& other10) {
  resource_id = other10.resource_id;
  rpc = other10.rpc;
  device = other10.device;
  return *this;
}
void RegisterReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RegisterReq(";
  out << "resource_id=" << to_string(resource_id);
  out << ", " << "rpc=" << to_string(rpc);
  out << ", " << "device=" << to_string(device);
  out << ")";
}


RegisterResp::~RegisterResp() noexcept {
}


void RegisterResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const RegisterResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RegisterResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RegisterResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RegisterResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RegisterResp &a, RegisterResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

RegisterResp::RegisterResp(const RegisterResp& other11) {
  base = other11.base;
}
RegisterResp& RegisterResp::operator=(const RegisterResp& other12) {
  base = other12.base;
  return *this;
}
void RegisterResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RegisterResp(";
  out << "base=" << to_string(base);
  out << ")";
}


UnRegisterReq::~UnRegisterReq() noexcept {
}


void UnRegisterReq::__set_resource_id(const std::string& val) {
  this->resource_id = val;
}
std::ostream& operator<<(std::ostream& out, const UnRegisterReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnRegisterReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resource_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource_id);
          isset_resource_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resource_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnRegisterReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnRegisterReq");

  xfer += oprot->writeFieldBegin("resource_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resource_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnRegisterReq &a, UnRegisterReq &b) {
  using ::std::swap;
  swap(a.resource_id, b.resource_id);
}

UnRegisterReq::UnRegisterReq(const UnRegisterReq& other13) {
  resource_id = other13.resource_id;
}
UnRegisterReq& UnRegisterReq::operator=(const UnRegisterReq& other14) {
  resource_id = other14.resource_id;
  return *this;
}
void UnRegisterReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnRegisterReq(";
  out << "resource_id=" << to_string(resource_id);
  out << ")";
}


UnRegisterResp::~UnRegisterResp() noexcept {
}


void UnRegisterResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const UnRegisterResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnRegisterResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnRegisterResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnRegisterResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnRegisterResp &a, UnRegisterResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

UnRegisterResp::UnRegisterResp(const UnRegisterResp& other15) {
  base = other15.base;
}
UnRegisterResp& UnRegisterResp::operator=(const UnRegisterResp& other16) {
  base = other16.base;
  return *this;
}
void UnRegisterResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnRegisterResp(";
  out << "base=" << to_string(base);
  out << ")";
}


HeartbeatReq::~HeartbeatReq() noexcept {
}


void HeartbeatReq::__set_resource_id(const std::string& val) {
  this->resource_id = val;
}

void HeartbeatReq::__set_up_resource(const bool val) {
  this->up_resource = val;
}

void HeartbeatReq::__set_device(const DeviceResourceDetail& val) {
  this->device = val;
__isset.device = true;
}
std::ostream& operator<<(std::ostream& out, const HeartbeatReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartbeatReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resource_id = false;
  bool isset_up_resource = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource_id);
          isset_resource_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->up_resource);
          isset_up_resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->device.read(iprot);
          this->__isset.device = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resource_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_up_resource)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartbeatReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatReq");

  xfer += oprot->writeFieldBegin("resource_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resource_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("up_resource", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->up_resource);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.device) {
    xfer += oprot->writeFieldBegin("device", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->device.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatReq &a, HeartbeatReq &b) {
  using ::std::swap;
  swap(a.resource_id, b.resource_id);
  swap(a.up_resource, b.up_resource);
  swap(a.device, b.device);
  swap(a.__isset, b.__isset);
}

HeartbeatReq::HeartbeatReq(const HeartbeatReq& other17) {
  resource_id = other17.resource_id;
  up_resource = other17.up_resource;
  device = other17.device;
  __isset = other17.__isset;
}
HeartbeatReq& HeartbeatReq::operator=(const HeartbeatReq& other18) {
  resource_id = other18.resource_id;
  up_resource = other18.up_resource;
  device = other18.device;
  __isset = other18.__isset;
  return *this;
}
void HeartbeatReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatReq(";
  out << "resource_id=" << to_string(resource_id);
  out << ", " << "up_resource=" << to_string(up_resource);
  out << ", " << "device="; (__isset.device ? (out << to_string(device)) : (out << "<null>"));
  out << ")";
}


HeartbeatResp::~HeartbeatResp() noexcept {
}


void HeartbeatResp::__set_base(const  ::BaseCode& val) {
  this->base = val;
}
std::ostream& operator<<(std::ostream& out, const HeartbeatResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartbeatResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_base = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base.read(iprot);
          isset_base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_base)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartbeatResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatResp");

  xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->base.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatResp &a, HeartbeatResp &b) {
  using ::std::swap;
  swap(a.base, b.base);
}

HeartbeatResp::HeartbeatResp(const HeartbeatResp& other19) {
  base = other19.base;
}
HeartbeatResp& HeartbeatResp::operator=(const HeartbeatResp& other20) {
  base = other20.base;
  return *this;
}
void HeartbeatResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatResp(";
  out << "base=" << to_string(base);
  out << ")";
}


